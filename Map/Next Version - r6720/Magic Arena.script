//Script version r978_AI_Test (01 feb 2020)

const

//Skills cooldowns

  LANCE_ROAD_DELAY = 80;
  LANCE_FIELD_DELAY = 80;
  LANCE_WINE_DELAY = 250;

  BARB_ROAD_DELAY = 70;
  BARB_FIELD_DELAY = 150;
  BARB_WINE_DELAY = 300;

  XBOW_ROAD_DELAY = 60;
  XBOW_FIELD_DELAY = 160;
  XBOW_WINE_DELAY = 180;

  SWORD_ROAD_DELAY = 110;
  SWORD_FIELD_DELAY = 130;
  SWORD_WINE_DELAY = 250;

  PIKE_ROAD_DELAY = 140;
  PIKE_FIELD_DELAY = 170;
  PIKE_WINE_DELAY = 350;

  BOWMAN_ROAD_DELAY = 120;
  BOWMAN_FIELD_DELAY = 140;
  BOWMAN_WINE_DELAY = 250;

  AXE_ROAD_DELAY = 110;
  AXE_FIELD_DELAY = 140;
  AXE_WINE_DELAY = 1400;

  VAGA_ROAD_DELAY = 100;
  VAGA_FIELD_DELAY = 180;
  VAGA_WINE_DELAY = 600;

  WARRIOR_ROAD_DELAY = 100;
  WARRIOR_FIELD_DELAY = 120;
  WARRIOR_WINE_DELAY = 250;

  KNIGHT_ROAD_DELAY = 100;
  KNIGHT_FIELD_DELAY = 140;
  KNIGHT_WINE_DELAY = 180;

  ROGUE_ROAD_DELAY = 60;
  ROGUE_FIELD_DELAY = 90;
  ROGUE_WINE_DELAY = 0;

  SCOUT_ROAD_DELAY = 90;
  SCOUT_FIELD_DELAY = 150;
  SCOUT_WINE_DELAY = 300;

  REBEL_ROAD_DELAY = 100;
  REBEL_FIELD_DELAY = 120;
  REBEL_WINE_DELAY = 280;

//Skills parameters

  TELEPORT_RADIUS = 5;
  SACRIFICIAL_RADIUS = 8;
  TOTEM_ADD_RADIUS = 7;
  MILIZOMBIE_RADIUS = 4;
  MAX_MILIZOMBIE = 100;
  IN_FEAR_RADIUS = 4;
  FEAR_LURE_CHANCE = 1;
  BOMB_RADIUS = 7;
  ROCKET_USAGE_RADIUS = 50;
  PRISON_USAGE_RADIUS = 6;
  PRISON_RADIUS = 3;
  GRAVITY_RADIUS1 = 5;
  FIRE_RADIUS = 4;
  SHOCK_RADIUS = 6;
  REGEN_RADIUS = 6;
  THREADS_RADIUS = 5;
  THREADS_ALLY_RADIUS = 7;
  STEAL_RADIUS = 9;
  STEALSKILL_LURE_CHANCE = 0.7;
  MIND_RADIUS = 3;
  SILENCE_SCOUT_RADIUS = 4;
  TOWER_RADIUS = 6;
  EXILE_RADIUS = 4;
  EXILE_ALLY_RADIUS = 7;
  SHIELD_RADIUS = 7;
  SHIELD_AREA_RADIUS = 3;
  REPLICA_RADIUS = 5;
  REPLICA_DELAY = 15;
  REPLICA_KILL_CHANCE = 0.65;
  REPLICA_LURE_CHANCE = 0.45;
  RIFT_USAGE_RADIUS = 5;
  RIFT_ZOMBIE_RADIUS = 5;
  RIFT_ADD_ILLUSIONS = 2;
  MIRROR_TIME = 60;
  REBEL_ZOMBIE_LIFE = 300;
  STRONGWILL_RADIUS = 5;

  RAGE_RADIUS = 5;
  TOTEM_RADIUS = 4;
  VISE_RADIUS = 5;
  EXP_RADIUS = 6;
  GRAVITY_RADIUS = 5;
  FIREWORKS1_RADIUS = 4;
  FIREWORKS2_RADIUS = 4;
  DEAFENING_RADIUS = 4;
  MENTAL_RADIUS = 3;
  
  RAGE_CYCLES = 1;
  TOTEM_CYCLES = 5;
  VISE_CYCLES = 1;
  EXP_CYCLES = 2;
  GRAVITY_CYCLES = 1;
  FIREWORKS1_CYCLES = 1;
  FIREWORKS2_CYCLES = 1;
  DEAFENING_CYCLES = 1;
  SPURT_LENGTH = 12;
  BOOMERANG_LENGTH = 10;
  MENTAL_CYCLES = 1;
  MENTAL_DISTANCE = 8;
  TEN_K_SPEARS_WAVES = 1;
  BOWMAN_CHARGES = 4;
  SNAKE_CHARGES = 2;

//Skills speed

  XBOW_ROAD_SPEED = 4;
  XBOW_WINE_SPEED = 8;

  LANCE_ROAD_SPEED = 3;
  LANCE_WINE_SPEED = 15;

  BARB_ROAD_SPEED = 0.5;
  BARB_FIELD_SPEED = 1.6;
  BARB_WINE_SPEED = 0.3;

  SWORD_ROAD_SPEED = 1.25;

  PIKE_ROAD_SPEED = 1;

  BOWMAN_ROAD_SPEED = 0.7;
  BOWMAN_WINE_SPEED = 3;

  AXE_FIELD_SPEED = 2.5;

  VAGA_ROAD_SPEED = 1;
  VAGA_FIELD_SPEED = 2;

  WARRIOR_ROAD_SPEED = 2;

  KNIGHT_FIELD_SPEED = 3;
  KNIGHT_WINE_SPEED = 3;

  ROGUE_ROAD_SPEED = 2;

  SCOUT_ROAD_SPEED = 1;

//Skills objects

  LANCE_OBJECT = 21;
  LANCE_OBJECT2 = 18;
  LANCE_OBJECT3 = 19;

  XBOW_OBJECT = 54;
  XBOW_OBJECT2 = 57;
  XBOW_OBJECT3 = 24;

  BARB_OBJECT = 214;
  BARB_OBJECT2 = 210;
  BARB_OBJECT3 = 220;
  BARB_OBJECT4 = 216;
  BARB_OBJECT5 = 218;

  SWORD_OBJECT = 68;
  SWORD_OBJECT1 = 70;

  PIKE_OBJECT = 13;
  PIKE_OBJECT2 = 45;
  PIKE_OBJECT3 = 46;
  PIKE_OBJECT4 = 47;
  PIKE_OBJECT5 = 16;
  PIKE_OBJECT6 = 41;
  PIKE_OBJECT7 = 42;
  PIKE_OBJECT8 = 43;
  PIKE_OBJECT9 = 14;
  PIKE_OBJECT10 = 57;
  PIKE_OBJECT11 = 54;

  BOWMAN_OBJECT = 58;
  BOWMAN_OBJECT2 = 55;
  BOWMAN_OBJECT3 = 50;
  BOWMAN_OBJECT4 = 24;
  BOWMAN_OBJECT5 = 215;
  BOWMAN_OBJECT6 = 3;
  BOWMAN_ROCKET = 0;
  BOWMAN_ROCKET2 = 24;
  
  AXE_OBJECT = 60;
  AXE_OBJECT2 = 23;
  AXE_OBJECT3 = 5;
  AXE_OBJECT4 = 6;
  AXE_OBJECT5 = 196;
  AXE_OBJECT6 = 24;

  VAGA_OBJECT = 7;
  VAGA_OBJECT3 = 62;
  VAGA_OBJECT4 = 60;
  VAGA_OBJECT5 = 6;
  VAGA_OBJECT6 = 73;
  VAGA_OBJECT8 = 59;
  VAGA_OBJECT9 = 60;
  VAGA_OBJECT10 = 23;
  VAGA_OBJECT11 = 5;
  VAGA_OBJECT12 = 6;

  SHIELD_OBJECT = 182;
  SHIELD_OBJECT2 = 183;
  SHIELD_OBJECT3 = 184;
  SHIELD_OBJECT4 = 185;
  SHIELD_OBJECT5 = 186;
  SHIELD_OBJECT6 = 187;
  SHIELD_OBJECT7 = 188;
  SHIELD_OBJECT8 = 189;

  WARRIOR_OBJECT = 18;
  WARRIOR_OBJECT2 = 21;
  WARRIOR_OBJECT3 = 24;
  WARRIOR_OBJECT4 = 4;
  WARRIOR_OBJECT5 = 59;
  WARRIOR_OBJECT6 = 58;
  WARRIOR_OBJECT7 = 196;

  KNIGHT_OBJECT = 62;
  KNIGHT_OBJECT2 = 12;
  KNIGHT_OBJECT3 = 69;
  KNIGHT_OBJECT4 = 181;

  ROGUE_OBJECT = 24;
  ROGUE_OBJECT2 = 192;
  ROGUE_OBJECT3 = 195;

  SCOUT_OBJECT3 = 211;
  SCOUT_OBJECT4 = 213;
  SCOUT_OBJECT5 = 19;
  SCOUT_OBJECT6 = 126;
  SCOUT_OBJECT7 = 112;

  REBEL_OBJECT = 192;

  CIRCLE_FILL_OBJ = 17;
  UNIVERSAL_KILL_OBJ = 180;

  EXILE_TILE = 122;
  INFERNAL_TILE = 155;

//Runes

  RUNE_X = 35;
  RUNE_Y1 = 63;
  RUNE_Y2 = 86;
  RUNE_TIMER = 600;
  RUNE_ZOMBIE_LIFE = 1800;
  RUNE_REGEN_OBJ = 7;
  RUNE_DOUBLE_OBJ = 105;
  RUNE_ILLUSION_OBJ = 203;
  RUNE_MAGIC_IMMUNITY_OBJ = 63;
  RUNE_RECHARGE_OBJ = 88;
  RUNE_DOUBLE_TIME = 450;
  RUNE_MAGIC_IMMUNITY_TIME = 250;
  RUNE_ILLUSION_TIME = 1800;
  RUNE_RECHARGE_TIME = 600;
  RUNE_ILLUSIONS_COUNT = 4;
  RUNE_CHECK_RADIUS = 10;

//Animation

  MAGIC_IMMUNITY_ANIMATION = 20;
  TOTAL_IMMUNITY_ANIMATION = 33;
  DOUBLE_ANIMATION = 28;
  SILENCE_ANIMATION = 14;
  FEAR_ANIMATION = 220;
  STUN_ANIMATION = 16;
  MIND_ANIMATION = 9;
  RECHARGE_ANIMATION = 0;
  ANIMATION_CHECK_RADIUS = 4;

//Player stats

  MAGIC_IMMUNITY_TIME = 60;
  TOTAL_IMMUNITY_TIME = 60;
  STUNNED_TIME = 50;
  STUNNED_ANIMATION_TIME = 15;
  IN_FEAR_TIME = 70;
  START_HP = 10;
  MAX_HP = 10;
  CHOOSE_HERO_TIMER = 350;
  GAME_START_TIME = 440;
  ZOMBIE_STORM_TIME = 100;
  STORM_CHANCE = 0.7;
  PRISON_TIME = 60;
  CIRCLE_DEF_TIME = 6;
  WEREWOLF_TIME = 450;
  REGEN_TIME = 40;
  DELAY_OF_TURNING = 2;
  VAGA_DELAY_OF_TURNING = 10;
  REGEN_DELAY = 400;
  SHOCK_TIME = 20;
  SKILL_RESPAWN_TIME = 1;
  THREADS_DELAY = 14;
  DEAFENING_TIME = 50;
  SPURT_TIME = 35;
  STOLEN_SKILL_TIME = 1200;
  CAPTURE_MIND_TIME = 169;
  TRACK_TIME = 100;
  TRACK_DELAY = 3;
  TRACK_FACTOR = 3;
  GRAVITY_MOVE_TIME = 20;
  SILENCE_SCOUT_TIME = 50;
  SILENCE_SCOUT_DELAY = 12;
  EXILE_TIME = 30;
  EXILE_DELAY = 2;
  SHIELD_TIME = 80;
  AXE_SHIELD_TIME = 20;
  TOWER_DELAY = 25;
  RIFT_DELAY = 10;

//Game mechanics

  DESYNC_FACTOR = 1;
  RELIEF_CHANGE_FACTOR = 7;
  RELIEF_REGEN_TIME = 300;
  CLEANUP_TIME = 20;
  PLANT_TREES_TIME = 25;
  PLANT_TREES_FACTOR = 0.65;
  TREE_AGE1 = 1500;
  TREE_AGE2 = 3000;
  TREE_AGE3 = 4800;
  TREE_AGE4 = 7200;
  TREES_GROW_FACTOR = 20;
  AVOID_FACTOR = 3;
  RECHARGE_FACTOR = 0.25;
  ZOMBIE_STORM_FACTOR = 20;
  AI_IGNORE_FACTOR = 5;
  HEAL_CHECK_RADIUS = 4;
  HEAL_CHECK_TIME = 50;
  CLEAR_ARRAY_FACTOR = 5;
  MOVEMENT_DISTANCE = 3;
  MOVEMENT_FACTOR = 2;
  MAX_CIRCLES_AT_ONCE = 4;
  RECHOICE_TIME = 150;
  RECHOICE_MAX_TIME = 3000;
  GAMEPLAY_STATUS_TIME = 75;
  AI_RUNE_CHECK_TIME = 25;
  STORM_CHECK_RADIUS = 6;
  TILES_RECHECK_TIME = 100;
  SKILL_CANCEL_OBJ = -2;
  REBORN_TIME = 50;
  EFFECT_CHECK_FACTOR = 6;
  RECRUIT_HUNGER = 161;
  VICTORY_DELAY = 300;
  TOWERS_CHECK_FACTOR = 10;
  TOWERS_TILES_FACTOR = 2;
  ZOMBIE_TAKE_RUNES = True;
  IDLE_CHECK_TIME = 200;

  NEW_ARENA = True;
  DEBUG_MODE = True;
  CHANGE_RELIEF = True;
  AI_ENABLED = True;
  SHOW_ERROR_MSG = True;
  DEATH_ANIMATION = False;
  KILL_STREAK = True;
  RANDOM_ANIMATIONS = True;

//Border

  BORDER_TIME1 = 60;
  BORDER_TIME2 = 40;
  BORDER_TIME3 = 20;
  BORDER_SPACES_TIME = 20;
  ARENA_CYCLES = 10;

//Battlefield

  MIN_X = 12;
  MAX_X = 59;
  MIN_Y = 51;
  MAX_Y = 98;
  TEMP_AI_X = 2;
  TEMP_AI_Y = 15;
  CENTERSCREEN_X = 17;
  CENTERSCREEN_Y = 17;
  TEMP_PLAYER = 11;
  AI_TEMP_PLAYER = 10;

//Sound

  DOUBLE_KILL_CHECK_TIME = 75;
  TRIPLE_KILL_CHECK_TIME = 150;
  RAMPAGE_CHECK_TIME = 225;
  MAX_TIME_BETWEEN_KILLS = 75;

type
  aSkill = (sNone, sBorder,
            sFieryLance, sTeleport, s10kSpears,
            sCrackingEarth, sWaveOfRage, sTotem,
            sSpikedEarth, sZombieSummon, sFear,
            sAccurateShot, sSuddenDeath, sSniperShot,
            sRocket, sPrison, sRevengeFromNowhere,
            sGravity, sDeadlyFireworks, sWerewolf,
            sStrongWill, sSweepingBlow,
            sDisorientation, sTrack, sRegen,
            sViseOfDeath, sSacrificialTeleport, sTower,
            sFierySnake, sExile, sShield,
            sThreadsOfDeath, sDeafeningClatter, sRagingSpurt,
            sMentalBurst, sSteal, sUniversal,
            sBoomerang, sSilence, sMind,
            sReplica, sRift, sMirror);


type
  aObjectType = (otKill, otStun, otRegen, otSave, otNeutral);


type
  aPlayer = Record
    SpawnX: Integer;
    SpawnY: Integer;
    TempSpawnX: Integer;
    TempSpawnY: Integer;
    Hero: Integer;
    HeroType: Integer;
    HeroMindType: Integer;
    TempHeroMindType: Integer;
    HeroMagicImmunity: Boolean;
    HeroMagicImmunityTime: Integer;
    TempHeroMagicImmunity: Boolean;
    TempHeroMagicImmunityTime: Integer;
    HeroChosen: Boolean;
    HP: Integer;
    RoadSkillDelay: Integer;
    FieldSkillDelay: Integer;
    WineSkillDelay: Integer;
    Direction: Integer;
    TempDirection: Integer;
    TribuneX: Integer;
    TribuneY: Integer;
    HeroStunnedTime: Integer;
    HeroStunned: Boolean;
    HeroInFearTime: Integer;
    HeroInFear: Boolean;
    HeroFearGiver: Integer;
    ZombiePlayer: Integer;
    TempZombiePlayer: Integer;
    DefenceTime: Integer;
    WerewolfTime: Integer;
    VagaX: Integer;
    VagaY: Integer;
    VagaDir: Integer;
    VagaAppearTime: Integer;
    VagaAppearTimeBack: Integer;
    RegenDelay: Integer;
    ClearPikeObjTime: Integer;
    GravityX: Integer;
    GravityY: Integer;
    RespawnCheckTime: Integer;
    DDTime : Integer;
    DD: Boolean;
    TempDDTime : Integer;
    TempDD: Boolean;
    PlayersTeam: Integer;
    TempPlayersTeam: Integer;
    UsedPlayersTeam: Boolean;
    CastingSkill: Boolean;
    SkillTime: Integer;
    SkillCastX: Integer;
    SkillCastY: Integer;
    SkillCastDir: Integer;
    SkillCastRespawnTime: Integer;
    HeroSilent: Boolean;
    HeroSilentTime: Integer;
    HeroSilentStartTime: Integer;
    AIChoiceTime: Integer;
    ThreadsUnitDir: Integer;
    ThreadsTime: Integer;
    ThreadsStartTime: Integer;
    ThreadsAttackTime: Integer;
    ThreadsAttacker: Integer;
    ThreadsTarget: Integer;
    ThreadsX: Integer;
    ThreadsY: Integer;
    ThreadsDX: Integer;
    ThreadsDY: Integer;
    Preparing: Boolean;
    PreparingTime: Integer;
    ReCharge: Boolean;
    ReChargeTime: Integer;
    TempReCharge: Boolean;
    TempReChargeTime: Integer;
    LastUsedSkill: aSkill;
    StolenSkill: aSkill;
    StolenSkillName: ANSIString;
    StolenSkillTime: Integer;
    TempStolenSkill: aSkill;
    TempStolenSkillName: ANSIString;
    TempStolenSkillTime: Integer;
    TempHeroType: Integer;
    MindTime: Integer;
    MindTime2: Integer;
    CaptureMind: Boolean;
    CaptureMindTime: Integer;
    MindStunned: Boolean;
    StunnedMindTime: Integer;
    MindMagicImmunityTime: Integer;
    MindAppearTime: Integer;
    MindAppearTimeBack: Integer;
    MindX: Integer;
    MindY: Integer;
    MindDir: Integer;
    CancelSkillMindSilent: Integer;
    PikeX: Integer;
    PikeY: Integer;
    PikeDir: Integer;
    KnightAppearTime: Integer;
    KnightX: Integer;
    KnightY: Integer;
    KnightDir: Integer;
    TempHero: Integer;
    TempX: Integer;
    TempY: Integer;
    SkillDirection: Integer;
    TrackStartTime: Integer;
    TrackStopTime: Integer;
    SettingTrack: Boolean;
    ReChoice: Boolean;
    ReChoiceTime: Integer;
    ReChoiceAllowed: Boolean;
    PlayerStatus: ANSIString;
    PlayerStatusTime: Integer;
    KillStatus: ANSIString;
    KillStatusTime: Integer;
    Kills: Integer;
    MovedByGravity: Boolean;
    GravityTime: Integer;
    ScoutSilenceGiver: Integer;
    ScoutSilenceStartTime: Integer;
    KillStreak: Integer;
    KillStreakStatus: ANSIString;
    KillStreakStatusTime: Integer;
    KillTimes: array of Integer;
    KillsCountTime: Integer;
    TempKill: Integer;
    TempKill2: Integer;
    DoubleKill: Boolean;
    TripleKill: Boolean;
    Rampage: Boolean;
    GravityUser: Integer;
    MovedByThreads: Boolean;
    SpurtStartTime: Integer;
    SpurtEndTime: Integer;
    CurrentSpurtLength: Integer;
    RebornTime: Integer;
    RebornMindTime: Integer;
    RebornMindTime2: Integer;
    HeroReborn: Boolean;
    TempHeroReborn: Boolean;
    TempRebornTime: Integer;
    MovedToTribune: Boolean;
    FireworkTime: Integer;
    FireworkX: Integer;
    FireworkY: Integer;
    HeroExileTime: Integer;
    HeroExileBackTime: Integer;
    HeroExileX: Integer;
    HeroExileY: Integer;
    HeroExileGiver: Integer;
    HeroExileDir: Integer;
    HeroExiled: Boolean;
    LastX: Integer;
    LastY: Integer;
    TempLastX: Integer;
    TempLastY: Integer;
    LastDir: Integer;
    HeroTotalImmunity: Boolean;
    HeroTotalImmunityTime: Integer;
    TempHeroTotalImmunity: Boolean;
    TempHeroTotalImmunityTime: Integer;
    RocketX: Integer;
    RocketY: Integer;
    RocketTime: Integer;
    SuddenX: Integer;
    SuddenY: Integer;
    SuddenTime: Integer;
    TowerTime: Integer;
    TowerX: Integer;
    TowerY: Integer;
    Defeat: Boolean;
    RoadSkillCancelTime: Integer;
    FieldSkillCancelTime: Integer;
    WineSkillCancelTime: Integer;
    TeleportTime: Integer;
    TeleportX: Integer;
    TeleportY: Integer;
    TeleportDir: Integer;
    ReplicaTime: Integer;
    ReplicaX: Integer;
    ReplicaY: Integer;
    ReplicaDir: Integer;
    ReplicaType: Integer;
    ReplicaTarget: Integer;
    RiftTime: Integer;
    RiftX: Integer;
    RiftY: Integer;
    RiftDir: Integer;
    MirrorTime: Integer;
    RocketCharges: Integer;
    RocketChargeTime: Integer;
    SnakeCharges: Integer;
    SnakeChargeTime: Integer;
    LastRoadSkill: aSkill;
    LastFieldSkill: aSkill;
    LastWineSkill: aSkill;
    LureType: Integer;
    LureX: Integer;
    LureY: Integer;
    LureDir: Integer;
    LureTime: Integer;
    LureHunger: Integer;
    LureZombieType: Integer;
    ZombieStunTime: Integer;
    AITarget: Integer;
    AIThreadsTime: Integer;
    AISpurtTime : Integer;
    AIKnightCombo: Boolean;
    AIKnightComboTime: Integer;
    LastSnakeTime: Integer;
    LastSnakeRandom: Integer;
    ShieldStartTime: Integer;
    ShieldEndTime: Integer;
  end;


type
  aZombie = Record
    ZombieOwner: Integer;
    ZombieID: Integer;
    ZombieHunger: Integer;
    ZombieType: Integer;
    ZombieTeleportTime: Integer;
    ZombieKillTime: Integer;
    ZombieThreadsTime: Integer;
    ZombieThreadsX: Integer;
    ZombieThreadsY: Integer;
    ZombieThreadsDir: Integer;
  end;


type
  aCircle = Record
    AddTime: Integer;
    X: Integer;
    Y: Integer;
    Radius: Integer;
    Obj: Integer;
  end;


type
  aTile = Record
    X: Integer;
    Y: Integer;
    Owner: Integer;
    Skill: aSkill;
    Relief: Integer;
    ReliefRefreshTime: Integer;
    ObjectRefreshTime: Integer;
    TreeTime: Integer;
    TileType: Integer;
    TileDirection: Integer;
    ShieldTime: Integer;
    TrackTime: Integer;
    PrisonTime: Integer;
    StunTime: Integer;
  end;


var
  CurrentMaxX, CurrentMinX, CurrentMaxY, CurrentMinY: Integer;
  Players: array[0..11] of aPlayer;
  ClearTilesRoadTimes, SetTilesRoadTimes, TilesRoadX, TilesRoadY, TilesRoadObjects,
  ClearTilesFieldTimes, SetTilesFieldTimes, TilesFieldX, TilesFieldY, TilesFieldObjects,
  ClearTilesWineTimes, SetTilesWineTimes, TilesWineX, TilesWineY, TilesWineObjects: array[0..11] of array of Integer;
  RageCircles, TotemCircles, ViseCircles, ExpCircles,
  FireworksCircles1, FireworksCircles2, FireworksCircles3, FireworksCircles4, 
  FireworksCircles5, KnightCircles, RogueCircles, StolenRogueCircles: array[0..11] of array[0..MAX_CIRCLES_AT_ONCE - 1] of array of aCircle;
  GravityCircles: array[0..11] of array of aCircle;
  RageCirclesCounter, TotemCirclesCounter, ViseCirclesCounter, ExpCirclesCounter,
  FireworksCircles1Counter, FireworksCircles2Counter, FireworksCircles3Counter, FireworksCircles4Counter, 
  FireworksCircles5Counter, KnightCirclesCounter, RogueCirclesCounter, StolenRogueCirclesCounter: array[0..11] of Integer;
  TilesRoadLength, TilesFieldLength, TilesWineLength: array[0..11] of Integer;
  RageCirclesLength, TotemCirclesLength, ViseCirclesLength, ExpCirclesLength,
  FireworksCircles1Length, FireworksCircles2Length, FireworksCircles3Length, 
  FireworksCircles4Length, FireworksCircles5Length, KnightCirclesLength, RogueCirclesLength, StolenRogueCirclesLength: array[0..11] of array[0..MAX_CIRCLES_AT_ONCE - 1] of Integer;
  GravityCirclesLength, TimeToClearGravityArray: array[0..11] of Integer;
  TimeToClearRageArray, TimeToClearTotemArray, TimeToClearViseArray, TimeToClearExpArray,
  TimeToClearFireworks1Array, TimeToClearFireworks2Array, TimeToClearFireworks3Array, 
  TimeToClearFireworks4Array, TimeToClearFireworks5Array, TimeToClearKnightArray,
  TimeToClearRogueArray, TimeToClearStolenRogueArray: array[0..11] of array[0..MAX_CIRCLES_AT_ONCE - 1] of Integer;
  PikeObjects, ShieldObjects: array[0..7] of Integer;
  Tiles: array[MIN_X..MAX_X] of array[MIN_Y..MAX_Y] of aTile;
  TeamChoice: array[0..1] of ANSIString;
  TeamInfo, Scores: array[0..1] of ANSIString;
  ClearRoadTilesArrayTime, ClearFieldTilesArrayTime, ClearWineTilesArrayTime: array[0..11] of Integer;
  RuneTime: Integer;
  M, M2, Q: array[0..7] of Integer;
  AISoldiers: array of Integer;
  SpurtTimes, SpurtX, SpurtY, SpurtDir: array[0..11] of array[0..SPURT_LENGTH - 1] of Integer;
  RUNE_Y: Integer;
  OldX, OldY, NewX, NewY: array[0..11] of Integer;
  PlayersLeft, SortedPlayersLeft, PlayersRight, SortedPlayersRight: array of Integer;
  Zombies: array of aZombie;
  LastAttacker, LastAttackerUnitType, LastAttackerZombieType: Integer;
  FirstBlood: Boolean;
  RuneTaken: Boolean;
  RuneObject: Integer;
  GameOver: Boolean;
  VictoryTime: Integer;
  RuneCleanupTime: array[0..7] of Integer;
  ArenaCycles, ArenaTime, ArenaTime2: Integer;


function InRange(aValue, aMin, aMax: Integer): Boolean;
begin
  if aMin < aMax then
    Result := (aValue >= aMin)
              and (aValue <= aMax)
  else
    Result := (aValue >= aMax)
              and (aValue <= aMin);
end;


function IfThen(Bool: Boolean; aTrue, aFalse: Integer): Integer;
begin
  if Bool then
    Result := aTrue
  else
    Result := aFalse;
end;


function Max(I1, I2: Integer): Integer;
begin
  Result := IfThen(I1 > I2, I1, I2);
end;


function IfThenStr(Bool: Boolean; aTrue, aFalse: ANSIString): ANSIString;
begin
  if Bool then
    Result := aTrue
  else
    Result := aFalse;
end;


procedure LogError(aMsg: ANSIString; aValues: array of Integer; aShowMsg: Boolean);
var
  I: Integer;
  Values: ANSIString;
begin
  Values := ' ';
  for I := Low(aValues) to High(aValues) do
    Values := Values + IntToStr(aValues[I]) + IfThenStr(I <> High(aValues), ', ', '');
  Actions.Log(aMsg + Values);
  if aShowMsg then
    Actions.ShowMsg(-1, '<$1000> ' + aMsg + Values);
end;


function TileOnBattlefield(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  Result := (InRange(X, CurrentMinX, CurrentMaxX))
            and (InRange(Y, CurrentMinY, CurrentMaxY))
            and (States.MapTileType(X, Y) <> 202)
            and (States.MapTileType(X, Y) <> 245);
end;


function TileOnChoiceArea(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  Result := (InRange(X, 15, 21))
            and (InRange(Y, 17, 18));
end;


function CanPlaceObject(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;

  Result := (TileOnBattlefield(X, Y))
            and (States.MapTileObject(X, Y) <> BARB_OBJECT3)
            and (States.MapTileObject(X, Y) <> BOWMAN_ROCKET)
            and (States.MapTileObject(X, Y) <> BOWMAN_OBJECT5)
            and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7)
            and (not InRange(States.MapTileObject(X, Y), SHIELD_OBJECT, SHIELD_OBJECT8));

end;


function ObjectType(aObj: Integer): aObjectType;
begin

  Result := otNeutral;

  if (aObj = LANCE_OBJECT)
  or (aObj = LANCE_OBJECT2)
  or (aObj = LANCE_OBJECT3)
  or (aObj = BARB_OBJECT)
  or (aObj = BARB_OBJECT2)
  or (aObj = BARB_OBJECT3)
  or (aObj = BARB_OBJECT4)
  or (aObj = BARB_OBJECT5)
  or (aObj = XBOW_OBJECT)
  or (aObj = XBOW_OBJECT2)
  or (aObj = XBOW_OBJECT3)
  or (aObj = PIKE_OBJECT)
  or (aObj = PIKE_OBJECT2)
  or (aObj = PIKE_OBJECT3)
  or (aObj = PIKE_OBJECT4)
  or (aObj = PIKE_OBJECT5)
  or (aObj = PIKE_OBJECT6)
  or (aObj = PIKE_OBJECT7)
  or (aObj = PIKE_OBJECT8)
  or (aObj = PIKE_OBJECT9)
  or (aObj = BOWMAN_OBJECT)
  or (aObj = BOWMAN_OBJECT2)
  or (aObj = BOWMAN_OBJECT3)
  or (aObj = BOWMAN_OBJECT4)
  or (aObj = BOWMAN_ROCKET)
  or (aObj = BOWMAN_ROCKET2)
  or (aObj = AXE_OBJECT2)
  or (aObj = AXE_OBJECT3)
  or (aObj = WARRIOR_OBJECT3)
  or (aObj = WARRIOR_OBJECT)
  or (aObj = WARRIOR_OBJECT2)
  or (aObj = WARRIOR_OBJECT5)
  or (aObj = WARRIOR_OBJECT6)
  or (aObj = KNIGHT_OBJECT4)
  or (aObj = ROGUE_OBJECT)
  or (aObj = ROGUE_OBJECT2)
  or (aObj = CIRCLE_FILL_OBJ)
  or (aObj = SCOUT_OBJECT3)
  or (aObj = VAGA_OBJECT8)
  or (aObj = SCOUT_OBJECT5)
  or (aObj = SCOUT_OBJECT6)
  or (aObj = PIKE_OBJECT10)
  or (aObj = PIKE_OBJECT11)
  or (aObj = UNIVERSAL_KILL_OBJ) then
    Result := otKill;

  if aObj = VAGA_OBJECT then
    Result := otRegen;

  if InRange(aObj, SWORD_OBJECT, VAGA_OBJECT6) then
    Result := otStun;

  if aObj = WARRIOR_OBJECT7 then
    Result := otSave;

end;


function UnbreakableObject(aObj: Integer): Boolean;
begin
  Result := (aObj = WARRIOR_OBJECT7)
            or (aObj = BOWMAN_ROCKET)
            or (aObj = BARB_OBJECT3)
            or (aObj = BOWMAN_OBJECT5);
end;


procedure KillUnneeded;
var
  Units: array of Integer;
  J, K: Integer;
begin
  for J := 0 to 7 do
  begin
    if States.PlayerEnabled(J) then
      Units := States.PlayerGetAllUnits(J);
    for K := 0 to Length(Units) - 1 do
      Actions.UnitKill(Units[K], True);
  end;

  Actions.UnitKill(States.UnitAt(26, 9), True);
  Actions.UnitKill(States.UnitAt(26, 11), True);
  Actions.UnitKill(States.UnitAt(26, 13), True);

end;


procedure AutoFeed;
var
  UnitsToFeed: array of Integer;
  I, K: Integer;
begin
  for I := 0 to 8 do
  begin
    if States.PlayerEnabled(I) then
      UnitsToFeed := States.PlayerGetAllUnits(I);
    for K := 0 to Length(UnitsToFeed) - 1 do
      Actions.UnitHungerSet(UnitsToFeed[K], States.UnitMaxHunger);
  end;
end;


procedure CheckTilesInfo;
var
  aX, aY: Integer;
begin
  for aX := CurrentMinX to CurrentMaxX do
  for aY := CurrentMinY to CurrentMaxY do
  begin
    Tiles[aX][aY].X := aX;
    Tiles[aX][aY].Y := aY;
    Tiles[aX][aY].Owner := -1;
    Tiles[aX][aY].Relief := States.MapTileHeight(aX, aY);
    Tiles[aX][aY].ReliefRefreshTime := 0;
    Tiles[aX][aY].ObjectRefreshTime := 0;
    Tiles[aX][aY].Skill := sNone;
    Tiles[aX][aY].TreeTime := 0;
    Tiles[aX][aY].TileType := States.MapTileType(aX, aY);
    Tiles[aX][aY].TileDirection := States.MapTileRotation(aX, aY);
    Tiles[aX][aY].ShieldTime := 0;
    Tiles[aX][aY].TrackTime := 0;
    Tiles[aX][aY].PrisonTime := 0;
    Tiles[aX][aY].StunTime := 0;
  end;
end;


procedure RegenRelief;
var
  aX, aY: Integer;
begin

  if not CHANGE_RELIEF then
    Exit;

  for aX := CurrentMinX to CurrentMaxX do
  for aY := CurrentMinY to CurrentMaxY do
    if (States.MapTileHeight(aX, aY) <> Tiles[aX][aY].Relief)
    and (States.GameTime > Tiles[aX][aY].ReliefRefreshTime) then
      Actions.MapTileHeightSet(aX, aY, Tiles[aX][aY].Relief);

end;


procedure CheckTileCleanup(CheckShields: Boolean);
var
  aX, aY, aObj: Integer;
begin
  for aX := CurrentMinX to CurrentMaxX do
  for aY := CurrentMinY to CurrentMaxY do
  begin
    if (States.MapTileType(aX, aY) = Tiles[aX][aY].TileType)
    and (States.MapTileRotation(aX, aY) <> Tiles[aX][aY].TileDirection) then
      Actions.MapTileSet(aX, aY, Tiles[aX][aY].TileType, Tiles[aX][aY].TileDirection);
    if CheckShields then
    begin
      aObj := States.MapTileObject(aX, aY);
      if (aObj = WARRIOR_OBJECT7)
      and (TileOnBattlefield(aX, aY))
      and (States.GameTime > Tiles[aX][aY].ShieldTime) then
        Actions.MapTileObjectSet(aX, aY, 255);
      if (aObj = BOWMAN_OBJECT5)
      and (TileOnBattlefield(aX, aY))
      and (States.GameTime > Tiles[aX][aY].PrisonTime) then
        Actions.MapTileObjectSet(aX, aY, 255);
      if (ObjectType(aObj) = otStun)
      and (TileOnBattlefield(aX, aY))
      and (States.GameTime > Tiles[aX][aY].StunTime) then
        Actions.MapTileObjectSet(aX, aY, 255);
      if (aObj = VAGA_OBJECT8)
      and (TileOnBattlefield(aX, aY))
      and (States.GameTime > Tiles[aX][aY].TrackTime) then
        Actions.MapTileObjectSet(aX, aY, 255);
      if (aObj <> 255)
      and (not InRange(aObj, 149, 172))
      and (TileOnBattlefield(aX, aY))
      and (States.GameTime > Tiles[aX][aY].ObjectRefreshTime)
      and (InRange(Tiles[aX][aY].Owner, 0, 11)) then
        if States.PlayerIsAI(Tiles[aX][aY].Owner) then
          Actions.MapTileObjectSet(aX, aY, 255);
    end;
  end;
end;


procedure AIHeroChoice(P: Integer);
begin

  try

    if not AI_ENABLED then
      Exit;

    case States.KaMRandomI(6) of
      0: Players[P].HeroType := 16;
      1: Players[P].HeroType := 23;
      2: Players[P].HeroType := 18;
      3: Players[P].HeroType := 19;
      4: Players[P].HeroType := 17;
      5: Players[P].HeroType := 22;
      //6: Players[P].HeroType := 20;
      //7: Players[P].HeroType := 26;
    end;

    Players[P].TempHeroType := Players[P].HeroType;
    Players[P].HeroChosen := True;
    Actions.GiveUnit(8, 13, 13, 14, 4);

    if InRange(P, 0, 3) then
      TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
    if InRange(P, 4, 7) then
      TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);

  except

    LogError('Exception in the script: cannot choose hero for invalid AI player:', [P], SHOW_ERROR_MSG);

  end;

end;


procedure SetScreen;
var
  I: Integer;
begin
  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      Actions.CinematicStart(I);
      Actions.CinematicPanTo(I, CENTERSCREEN_X, CENTERSCREEN_Y, 0);
      Actions.CinematicEnd(I);
    end;
end;


procedure SortScoresLeft;
var
  I, Temp: Integer;
begin
  if Length(PlayersLeft) <= 0 then
    Exit;

  for I := Length(PlayersLeft) - 1 downto 1 do
    if Players[SortedPlayersLeft[I]].Kills > Players[SortedPlayersLeft[I - 1]].Kills then
      begin
        Temp := SortedPlayersLeft[I - 1];
        SortedPlayersLeft[I - 1] := SortedPlayersLeft[I];
        SortedPlayersLeft[I] := Temp;
      end;
end;


procedure SortScoresRight;
var
  I, Temp: Integer;
begin
  if Length(PlayersRight) <= 0 then
    Exit;

  for I := Length(PlayersRight) - 1 downto 1 do
    if Players[SortedPlayersRight[I]].Kills > Players[SortedPlayersRight[I - 1]].Kills then
      begin
        Temp := SortedPlayersRight[I - 1];
        SortedPlayersRight[I - 1] := SortedPlayersRight[I];
        SortedPlayersRight[I] := Temp;
      end;
end;


procedure SetPlayersLeft;
var
  I: Integer;
begin
  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
    begin
      if (States.PlayerIsAI(I))
      and (not AI_ENABLED) then
        Exit;
      SetLength(PlayersLeft, Length(PlayersLeft) + 1);
      PlayersLeft[Length(PlayersLeft) - 1] := I;
      SetLength(SortedPlayersLeft, Length(SortedPlayersLeft) + 1);
      SortedPlayersLeft[Length(SortedPlayersLeft) - 1] := I;
    end;
end;


procedure SetPlayersRight;
var
  I: Integer;
begin
  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
    begin
      if (States.PlayerIsAI(I))
      and (not AI_ENABLED) then
        Exit;
      SetLength(PlayersRight, Length(PlayersRight) + 1);
      PlayersRight[Length(PlayersRight) - 1] := I;
      SetLength(SortedPlayersRight, Length(SortedPlayersRight) + 1);
      SortedPlayersRight[Length(SortedPlayersRight) - 1] := I;
    end;
end;


procedure OnMissionStart;
var
  I, K: Integer;
begin

  CurrentMinX := MIN_X;
  CurrentMaxX := MAX_X;
  CurrentMinY := MIN_Y;
  CurrentMaxY := MAX_Y;

  SetPlayersLeft;
  SetPlayersRight;

  AISoldiers := States.PlayerGetAllGroups(8);

  if States.KaMRandom > 0.5 then
    RUNE_Y := RUNE_Y1
  else
    RUNE_Y := RUNE_Y2;

  CheckTilesInfo;

  RuneTaken := True;
  RuneObject := 255;

  ArenaCycles := -1;
  ArenaTime := 0;
  ArenaTime2 := 0;

  FirstBlood := False;

  GameOver := False;
  VictoryTime := 0;

  LastAttacker := -1;
  LastAttackerUnitType := -1;
  LastAttackerZombieType := -1;

  PikeObjects[0] := PIKE_OBJECT;
  PikeObjects[1] := PIKE_OBJECT2;
  PikeObjects[2] := PIKE_OBJECT3;
  PikeObjects[3] := PIKE_OBJECT4;
  PikeObjects[4] := PIKE_OBJECT5;
  PikeObjects[5] := PIKE_OBJECT6;
  PikeObjects[6] := PIKE_OBJECT7;
  PikeObjects[7] := PIKE_OBJECT8;

  ShieldObjects[0] := SHIELD_OBJECT;
  ShieldObjects[1] := SHIELD_OBJECT2;
  ShieldObjects[2] := SHIELD_OBJECT3;
  ShieldObjects[3] := SHIELD_OBJECT4;
  ShieldObjects[4] := SHIELD_OBJECT5;
  ShieldObjects[5] := SHIELD_OBJECT6;
  ShieldObjects[6] := SHIELD_OBJECT7;
  ShieldObjects[7] := SHIELD_OBJECT8;

  for I := 0 to 11 do
  for K := 0 to 11 do
  begin
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
    begin
      Actions.PlayerShareFog(I, K, False);
      Actions.PlayerShareFog(K, I, False);
    end;
  end;
  
  for I := 0 to 7 do
  begin
    M[I] := -1;
    M2[I] := -1;
    Q[I] := -1;
  end;

  for I := 0 to 3 do
    if States.PlayerEnabled(I) then
    begin
      Actions.PlayerAllianceChange(I, 11, True, True);
      Actions.PlayerAllianceChange(11, I, False, False);
    end;

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
    begin
      Actions.PlayerAllianceChange(I, 10, True, True);
      Actions.PlayerAllianceChange(10, I, False, False);
    end;

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
      Actions.PlayerAllianceChange(I, 8, True, True);

  KillUnneeded;

  AutoFeed;

  RuneTime := RUNE_TIMER;

  Actions.ShowMsg(-1, '<$0>');

  for I := 0 to 7 do
  for K := 0 to 7 do
  begin
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
    begin
      Actions.PlayerAllianceChange(I, K, True, True);
      Actions.PlayerAllianceChange(K, I, True, True);
    end;
  end;

  for I := 0 to 11 do
  for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
  begin
    RageCirclesLength[I][K] := 0;
    TotemCirclesLength[I][K] := 0;
    ViseCirclesLength[I][K] := 0;
    ExpCirclesLength[I][K] := 0;
    FireworksCircles1Length[I][K] := 0;
    FireworksCircles2Length[I][K] := 0;
    FireworksCircles3Length[I][K] := 0;
    FireworksCircles4Length[I][K] := 0;
    FireworksCircles5Length[I][K] := 0;
    KnightCirclesLength[I][K] := 0;
    RogueCirclesLength[I][K] := 0;
    StolenRogueCirclesLength[I][K] := 0;
  end;

  for I := 0 to 11 do
  begin
    ClearRoadTilesArrayTime[I] := -1;
    ClearFieldTilesArrayTime[I] := -1;
    ClearWineTilesArrayTime[I] := -1;
    TilesRoadLength[I] := 0;
    TilesFieldLength[I] := 0;
    TilesWineLength[I] := 0;
    RageCirclesCounter[I] := -1;
    TotemCirclesCounter[I] := -1;
    ViseCirclesCounter[I] := -1;
    ExpCirclesCounter[I] := -1;
    FireworksCircles1Counter[I] := -1;
    FireworksCircles2Counter[I] := -1;
    FireworksCircles3Counter[I] := -1;
    FireworksCircles4Counter[I] := -1;
    FireworksCircles5Counter[I] := -1;
    KnightCirclesCounter[I] := -1;
    RogueCirclesCounter[I] := -1;
    StolenRogueCirclesCounter[I] := -1;
  end;

  for I := 8 to 9 do
  begin
    Players[I].PlayersTeam := -1;
    Players[I].TempPlayersTeam := -1;
  end;

  Players[10].PlayersTeam := 0;
  Players[10].TempPlayersTeam := 0;

  Players[11].PlayersTeam := 1;
  Players[11].TempPlayersTeam := 1;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      Actions.FogCoverAll(I);

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      Actions.FogRevealRect(I, 4, 4, 30, 30);

  for I := 0 to 7 do
  begin
    with Players[I] do
    begin
      Hero := -1;
      HeroType := -1;
      HeroMagicImmunity := False;
      HeroChosen := False;
      HP := START_HP;
      RoadSkillDelay := 0;
      FieldSkillDelay := 0;
      WineSkillDelay := 0;
      HeroMagicImmunityTime := 0;
      HeroStunnedTime := 0;
      HeroStunned := False;
      HeroInFearTime := 0;
      HeroInFear := False;
      HeroFearGiver := -1;
      DefenceTime := 0;
      WerewolfTime := 0;
      VagaX := 0;
      VagaY := 0;
      VagaAppearTime := 0;
      VagaAppearTimeBack := 0
      VagaDir := 0;
      RegenDelay := 0;
      ClearPikeObjTime := 0;
      GravityX := 0;
      GravityY := 0;
      RespawnCheckTime := -1;
      DDTime := 0;
      DD := False;
      CastingSkill := False;
      SkillTime := 0;
      SkillCastX := 0;
      SkillCastY := 0;
      SkillCastDir := -1;
      SkillCastRespawnTime := 0;
      HeroSilent := False;
      HeroSilentTime := 0;
      HeroSilentStartTime := 0;
      AIChoiceTime := 10 + States.KaMRandomI(100) + States.KaMRandomI(200);
      ThreadsUnitDir := -1;
      ThreadsAttackTime := 0;
      ThreadsAttacker := -1;
      ThreadsTarget := -1;
      ThreadsTime := -1;
      ThreadsStartTime := -1;
      ThreadsDX := -1;
      ThreadsDY := -1;
      ThreadsX := -1;
      ThreadsY := -1;
      Preparing := False;
      PreparingTime := 0;
      ReCharge := False;
      ReChargeTime := 0;
      TempReCharge := False;
      TempReChargeTime := 0;
      LastUsedSkill := sNone;
      StolenSkill := sNone;
      StolenSkillName := '<$57>';
      TempHeroType := -1;
      StolenSkillTime := 0;
      MindTime := 0;
      MindTime2 := 0;
      CaptureMind := False;
      CaptureMindTime := 0;
      MindStunned := False;
      StunnedMindTime := 0;
      HeroMindType := -1;
      TempHeroMindType := -1;
      TempStolenSkill := sNone;
      TempStolenSkillName := '';
      TempStolenSkillTime := 0;
      MindMagicImmunityTime := 0;
      MindAppearTime := 0;
      MindAppearTimeBack := 0;
      MindX := 0;
      MindY := 0;
      MindDir := 0;
      CancelSkillMindSilent := 0;
      PikeX := 0;
      PikeY := 0;
      PikeDir := 0;
      KnightAppearTime := 0;
      KnightX := 0;
      KnightY := 0;
      KnightDir := 0;
      TempHero := -1;
      TempX := 2 + 2 * I;
      TempY := 2;
      SkillDirection := -1;
      TrackStartTime := 0;
      TrackStopTime := 0;
      SettingTrack := False;
      ReChoice := False;
      ReChoiceTime := 0;
      ReChoiceAllowed := True;
      Kills := 0;
      KillStatus := '';
      KillStatusTime := 0;
      PlayerStatus := '';
      PlayerStatusTime := 0;
      MovedByGravity := False;
      GravityTime := 0;
      ScoutSilenceStartTime := 0;
      ScoutSilenceGiver := -1;
      KillStreak := 0;
      KillStreakStatus := '';
      KillStreakStatusTime := 0;
      KillsCountTime := 0;
      DoubleKill := False;
      TripleKill := False;
      Rampage := False;
      GravityUser := -1;
      MovedByThreads := False;
      SpurtStartTime := 0;
      SpurtEndTime := 0;
      CurrentSpurtLength := 0;
      RebornTime := 0;
      RebornMindTime := 0;
      RebornMindTime2 := 0;
      HeroReborn := False;
      TempHeroReborn := False;
      TempRebornTime := 0;
      MovedToTribune := False;
      FireworkTime := 0;
      FireworkX := 0;
      FireworkY := 0;
      HeroExileTime := 0;
      HeroExileBackTime := 0;
      HeroExileX := 0;
      HeroExileY := 0;
      HeroExileGiver := -1;
      HeroExileDir := -1;
      HeroExiled := False;
      LastX := 0;
      LastY := 0;
      TempLastX := 0;
      TempLastY := 0;
      LastDir := -1;
      HeroTotalImmunity := False;
      HeroTotalImmunityTime := 0;
      RocketX := 0;
      RocketY := 0;
      RocketTime := 0;
      SuddenX := 0;
      SuddenY := 0;
      SuddenTime := 0;
      TowerTime := 0;
      TowerX := 0;
      TowerY := 0;
      Defeat := False;
      RoadSkillCancelTime := 0;
      FieldSkillCancelTime := 0;
      WineSkillCancelTime := 0;
      TeleportTime := 0;
      TeleportX := 0;
      TeleportY := 0;
      TeleportDir := -1;
      ReplicaTime := 0;
      ReplicaX := 0;
      ReplicaY := 0;
      ReplicaDir := -1;
      ReplicaType := -1;
      ReplicaTarget := -1;
      RiftTime := 0;
      RiftX := 0;
      RiftY := 0;
      RiftDir := -1;
      MirrorTime := 0;
      RocketCharges := BOWMAN_CHARGES;
      RocketChargeTime := 0;
      SnakeCharges := SNAKE_CHARGES;
      SnakeChargeTime := 0;
      LastRoadSkill := sNone;
      LastFieldSkill := sNone;
      LastWineSkill := sNone;
      LureType := 0;
      LureX := 0;
      LureY := 0;
      LureDir := 0;
      LureTime := 0;
      LureHunger := 0;
      LureZombieType := 0;
      ZombieStunTime := 0;
      AITarget := -1;
      AIThreadsTime := 0;
      AISpurtTime := 0;
      AIKnightCombo := False;
      AIKnightComboTime := 0;
      LastSnakeTime := 0;
      LastSnakeRandom := 0;
      ShieldStartTime := 0;
      ShieldEndTime := 0;
    end;
  end;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
      if (States.PlayerIsAI(I))
      and (not AI_ENABLED) then
        Players[I].HP := 0;

  for I := 0 to 3 do
  begin
    with Players[I] do
    begin
      SpawnX := 19;
      SpawnY := 58 + I * 11;
      Direction := 2;
      TribuneY := 3;
      TribuneX := 43 + 2 * I;
      ZombiePlayer := 10;
      PlayersTeam := 0;
      TempPlayersTeam := 0;
    end;
  end;

  for I := 4 to 7 do
  begin
    with Players[I] do
    begin
      SpawnX := 52;
      SpawnY := 58 + ((I - 4) * 11);
      Direction := 6;
      TribuneY := 26;
      TribuneX := 55 + ((I - 4) * 2);
      ZombiePlayer := 11;
      PlayersTeam := 1;
      TempPlayersTeam := 1;
    end;
  end;

  {for I := 0 to 11 do
  for K := 0 to 11 do
    if (States.PlayerEnabled(I))
    and (States.PlayerEnabled(K))
    and (I <> K) then
      if Players[I].PlayersTeam <> Players[K].PlayersTeam then
      begin
        Actions.PlayerShareBeacons(I, K, False);
        Actions.PlayerShareBeacons(K, I, False);
      end;}

end;


function TileOnRuneSpawn(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;

  Result := (X = RUNE_X)
            and (Y = RUNE_Y);

end;


function TileOnBattlefield_2(X, Y: Integer): Boolean;
begin
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;

  Result := TileOnBattlefield(X, Y);

  if TileOnRuneSpawn(X, Y) then
    Result := Result and RuneTaken;

end;


function RuneType: Integer;
begin
  case States.KaMRandomI(15) of
    0..2:    Result := RUNE_REGEN_OBJ;
    3..5:    Result := RUNE_DOUBLE_OBJ;
    6..8:    Result := RUNE_ILLUSION_OBJ;
    9..11:   Result := RUNE_MAGIC_IMMUNITY_OBJ;
    12..14:  Result := RUNE_RECHARGE_OBJ;
  end;
end;


procedure CheckRuneTime;
begin
  if RuneTime > 0 then
    RuneTime := RuneTime - 1;
  if RuneTime = 0 then
  begin
    if States.KaMRandomI(10) > 4 then
      RUNE_Y := RUNE_Y1
    else
      RUNE_Y := RUNE_Y2;
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y1, 255);
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y2, 255);
    Actions.MapTileObjectSet(RUNE_X, RUNE_Y, RuneType);
    RuneObject := RuneType;
    RuneTaken := False;
    Actions.PlayWAV(-1, 'Rune', 1);
    RuneTime := RUNE_TIMER;
  end;
end;


procedure CheckRuneCleanup;
var
  I: Integer;
begin
  try
    if States.MapTileObject(RUNE_X, RUNE_Y) = BARB_OBJECT3 then
      RuneTaken := True;
    for I := 0 to 7 do
      if States.GameTime = RuneCleanupTime[I] then
        RuneTaken := True;
    if (not RuneTaken)
    and (States.MapTileObject(RUNE_X, RUNE_Y) <> RuneObject) then
      Actions.MapTileObjectSet(RUNE_X, RUNE_Y, RuneObject);
    if (RuneTaken)
    and (States.MapTileObject(RUNE_X, RUNE_Y) = RuneObject) then
      Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
  except
    LogError('Something went wrong when trying to check rune cleanup:', [States.GameTime, RUNE_X, RUNE_Y, RuneObject], SHOW_ERROR_MSG);
  end;
end;


procedure CheckZombieArray;
var
  TempZombies: array of aZombie;
  I, K: Integer;
begin
  if Length(Zombies) <= 0 then
    Exit;
  try
    for I := 0 to Length(Zombies) - 1 do
      if Zombies[I].ZombieID > 0 then
        if not States.UnitDead(Zombies[I].ZombieID) then
        begin
          SetLength(TempZombies, Length(TempZombies) + 1);
          TempZombies[Length(TempZombies) - 1].ZombieID := Zombies[I].ZombieID;
          TempZombies[Length(TempZombies) - 1].ZombieOwner := Zombies[I].ZombieOwner;
          TempZombies[Length(TempZombies) - 1].ZombieHunger := Zombies[I].ZombieHunger;
          TempZombies[Length(TempZombies) - 1].ZombieType := Zombies[I].ZombieType;
          TempZombies[Length(TempZombies) - 1].ZombieTeleportTime := Zombies[I].ZombieTeleportTime;
          TempZombies[Length(TempZombies) - 1].ZombieKillTime := Zombies[I].ZombieKillTime;
          TempZombies[Length(TempZombies) - 1].ZombieThreadsTime := Zombies[I].ZombieThreadsTime;
          TempZombies[Length(TempZombies) - 1].ZombieThreadsX := Zombies[I].ZombieThreadsX;
          TempZombies[Length(TempZombies) - 1].ZombieThreadsY := Zombies[I].ZombieThreadsY;
          TempZombies[Length(TempZombies) - 1].ZombieThreadsDir := Zombies[I].ZombieThreadsDir;
        end;
    SetLength(Zombies, Length(TempZombies));
    if Length(Zombies) > 0 then
      for K := 0 to Length(Zombies) - 1 do
      begin
        Zombies[K].ZombieID := TempZombies[K].ZombieID;
        Zombies[K].ZombieOwner := TempZombies[K].ZombieOwner;
        Zombies[K].ZombieHunger := TempZombies[K].ZombieHunger;
        Zombies[K].ZombieType := TempZombies[K].ZombieType;
        Zombies[K].ZombieTeleportTime := TempZombies[K].ZombieTeleportTime;
        Zombies[K].ZombieKillTime := TempZombies[K].ZombieKillTime;
        Zombies[K].ZombieThreadsTime := TempZombies[K].ZombieThreadsTime;
        Zombies[K].ZombieThreadsX := TempZombies[K].ZombieThreadsX;
        Zombies[K].ZombieThreadsY := TempZombies[K].ZombieThreadsY;
        Zombies[K].ZombieThreadsDir := TempZombies[K].ZombieThreadsDir;
      end;
  except
    LogError('Exception in the script: Something went wrong when trying to resize Zombies array:', [Length(TempZombies), Length(Zombies)], SHOW_ERROR_MSG);
  end;
end;


procedure GetRuneEffect(P, aRune: Integer);
var
  I, Z: Integer;
begin
  try

    if RuneTaken then
      Exit;

    case aRune of

      RUNE_REGEN_OBJ:
        if (not Players[P].MindStunned)
        and (not Players[P].CaptureMind) then
          if (States.GameTime > Players[P].RegenDelay) then          
          begin
            Players[P].HP := Players[P].HP + 1;
            Players[P].RegenDelay := States.GameTime + REGEN_DELAY;
            RuneTaken := True;
            Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
          end;

      RUNE_DOUBLE_OBJ:
      begin
        Players[P].DD := True;
        Players[P].DDTime := States.GameTime + RUNE_DOUBLE_TIME;
        RuneTaken := True;
        Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
      end;

      RUNE_ILLUSION_OBJ:
        for I := 0 to RUNE_ILLUSIONS_COUNT - 1 do
        begin
          SetLength(Zombies, Length(Zombies) + 1);
          Zombies[Length(Zombies) - 1].ZombieOwner := P;
          Zombies[Length(Zombies) - 1].ZombieType := 3;
          Z := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].HeroType, RUNE_X + States.KaMRandomI(5) - States.KaMRandomI(5), RUNE_Y + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8), 1, 1);
          Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
          Actions.GroupHungerSet(Z, RUNE_ZOMBIE_LIFE);
          RuneTaken := True;
          Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
        end;

      RUNE_MAGIC_IMMUNITY_OBJ:
      begin
        Players[P].HeroMagicImmunity := True;
        Players[P].HeroMagicImmunityTime := States.GameTime + RUNE_MAGIC_IMMUNITY_TIME;
        RuneTaken := True;
        Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
      end;

      RUNE_RECHARGE_OBJ:
      begin
        Players[P].ReCharge := True;
        Players[P].ReChargeTime := States.GameTime + RUNE_RECHARGE_TIME;
        Players[P].RoadSkillDelay := 0;
        Players[P].FieldSkillDelay := 0;
        Players[P].WineSkillDelay := 0;
        Players[P].RocketCharges := BOWMAN_CHARGES;
        Players[P].RocketChargeTime := 0;
        Players[P].SnakeCharges := SNAKE_CHARGES;
        Players[P].SnakeChargeTime := 0;
        RuneTaken := True;
        Actions.MapTileObjectSet(RUNE_X, RUNE_Y, 255);
      end;

    end;

  except

    LogError('Exception in the script: cannot check rune effect for invalid player or object ' + IntToStr(aRune) + ' is not a rune:', [P, aRune], SHOW_ERROR_MSG);

  end;

end;


procedure ZombieTakeRune;
var
  I, aX, aY, O, aRune: Integer;
begin
  if RuneTaken then
    Exit;

  if not ZOMBIE_TAKE_RUNES then
    Exit;

  if Length(Zombies) > 0 then
    for I := 0 to Length(Zombies) - 1 do
      if not States.UnitDead(Zombies[I].ZombieID) then
      begin
        aX := States.UnitPositionX(Zombies[I].ZombieID);
        aY := States.UnitPositionY(Zombies[I].ZombieID);
        O := Zombies[I].ZombieOwner;
        if TileOnRuneSpawn(aX, aY) then
        begin
          aRune := States.MapTileObject(aX, aY);
          GetRuneEffect(O, aRune);
        end;
      end;
end;   


procedure CheckStolenSkillTime(P: Integer);
begin
  try
    if Players[P].StolenSkillTime = 0 then
    begin
      Players[P].StolenSkill := sNone;
      Players[P].StolenSkillName := '<$57>';
    end;

    if Players[P].StolenSkillTime > 0 then
      Players[P].StolenSkillTime := Players[P].StolenSkillTime - 1;
  except
    LogError('Exception in the script: cannot update stolen skill timer for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function HPString(P: Integer): ANSIString;
begin
  try
    if Players[P].HP <> 1 then
      Result := IntToStr(Players[P].HP)
    else
      case States.GameTime mod 25 of
        0..12:  Result := ' ';
        13..24: Result := IntToStr(Players[P].HP);
      end;
  except
    LogError('Exception in the script: cannot update HP string for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function HPColor(P: Integer): ANSIString;
begin
  try
    case Players[P].HP of
      9..20: Result := '[$00FF00]';
      7..8:  Result := '[$32CD9B]';
      5..6:  Result := '[$00FFFF]';
      3..4:  Result := '[$008CFF]';
      1..2:  Result := '[$0050FF]'
      else   Result := '[$000000]';
    end;
  except
    LogError('Exception in the script: cannot update HP counter highlight color for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function KillsColor(P: Integer): ANSIString;
begin
  try
    case Players[P].Kills of
      20..24:  Result := '[$0045FF]';
      15..19:  Result := '[$00A5FF]';
      10..14:  Result := '[$00D7FF]';
      5..9:    Result := '[$00FFFF]';
      0..4:    Result := '[$FFFFFF]'
      else     Result := '[$0000FF]';
    end;
  except
    LogError('Exception in the script: cannot update kills counter highlight color for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function ReChoiceColor(P: Integer): ANSIString;
begin
  try
    if Players[P].ReChoiceAllowed then
      Result := '[$00FF00]'
    else
      Result := '[$0000FF]';
  except
    LogError('Exception in the script: cannot update ReChoice status highlight color for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function GameplayStatus(P: Integer): ANSIString;
begin
  try
    if Players[P].PlayerStatusTime - States.GameTime > 0 then
      Result := '||' + Players[P].PlayerStatus
    else
      Result := '';
  except
    LogError('Exception in the script: cannot update gameplay status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function SacrificialTeleportColor(P: Integer): ANSIString;
begin
  try
    if (Players[P].HeroType = 20)
    and (Players[P].HP = 1) then
      Result := '[$0000FF]'
    else
      Result := '[$FFFFFF]';
  except
    LogError('Exception in the script: cannot update sacrificial teleport status highlight color for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


function StolenSacrificialTeleportColor(P: Integer): ANSIString;
begin
  try
    if (Players[P].HeroType = 25)
    and (Players[P].HP = 1)
    and (Players[P].StolenSkill = sSacrificialTeleport) then
      Result := '[$0000FF]'
    else
      Result := '[$FFFFFF]';
  except
    LogError('Exception in the script: cannot update stolen sacrificial teleport status highlight color for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end; 


function StatusKill(P: Integer): ANSIString;
begin
  if Players[P].KillStatusTime - States.GameTime > 0 then
    Result := '||' + Players[P].KillStatus

  else

    Result := '';
end;

function StatusKillStreak(P: Integer): ANSIString;
begin
  if Players[P].KillStreakStatusTime - States.GameTime > 0 then
    Result := '||' + Players[P].KillStreakStatus

  else

    Result := '';
end;


function RogueStatus(P: Integer): ANSIString;
begin

  if Players[P].HeroType <> 25 then
    Result := ''

  else

  begin

  if Players[P].StolenSkillTime > 0 then
    Result := '|[$56BAC2]<$59>[] |([$EBAEBA]' + Players[P].StolenSkillName + '[]) [$56BAC2]<$60>[] ' + IntToStr(Players[P].StolenSkillTime/10) + '[$56BAC2]. |<$61>[]'

  else

    Result := '';

  end;

end;


function RebornStatus(P: Integer): ANSIString;
begin
  if (Players[P].RebornTime - States.GameTime > 0)
  and not (Players[P].MindStunned) then
    Result := '|[$BAECDA]<$83>[] (' + IntToStr((Players[P].RebornTime - States.GameTime)/10) + ')'
    
  else

    Result := '';

end;

function RebornMindStatus(P: Integer): ANSIString;
begin
  if (Players[P].RebornMindTime - States.GameTime > 0) then
      Result := '|' + States.UnitTypeName(Players[P].HeroMindType) + ': [$BAECDA]<$83>[] (' + IntToStr((Players[P].RebornMindTime - States.GameTime)/10) + ')'
      
  else   
        
    Result := '';  
end;

function RebornMindStatus2(P: Integer): ANSIString;
begin
  if (Players[P].RebornMindTime2 - States.GameTime > 0) then
      Result := '|[$BAECDA]<$83>[] (' + IntToStr((Players[P].RebornMindTime2 - States.GameTime)/10) + ')'
      
  else   
        
    Result := '';  
end;

function DefeatStatus(P: Integer): ANSIString;
begin
  Result := '';
  if Players[P].HP <= 0 then
    Result := '|[$BEBAC6]<$133>[]';
end;


function FieryTrackStatus(P: Integer): ANSIString;
begin
  if Players[P].SettingTrack then
    Result := '|[$1528FE]<$23>[] (' + IntToStr((Players[P].TrackStopTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function DDStatus(P: Integer): ANSIString;
begin
  if Players[P].DDTime - States.GameTime > 0 then
    Result := '|[$A67F10]<$44>[] (' + IntToStr((Players[P].DDTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function RegenStatus(P: Integer): ANSIString;
begin
  if Players[P].RegenDelay - States.GameTime > 0 then
  begin
    if Players[P].HP < MAX_HP then
      Result := '|[$25FF10]<$1>[] (<$7> ' + IntToStr((Players[P].RegenDelay - States.GameTime)/10) + ')'
    else
      Result := '|[$BABCAA]<$140>[]';
  end

  else

    Result := '';
end;


function StunnedStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroStunned
  and not (Players[P].MindStunned) then
    Result := '|[$19A5DF]<$2>[] (' + IntToStr((Players[P].HeroStunnedTime - States.GameTime)/10) + ')'

  else

    Result := '';

  if Players[P].Preparing then
    Result := '';

end;


function FearStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroInFear then
    Result := '|[$52AADF]<$3>[] (' + IntToStr((Players[P].HeroInFearTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ImmortalStatus(P: Integer): ANSIString;
begin
  if (Players[P].HeroMagicImmunity)
  and not (Players[P].CaptureMind)
  and not (Players[P].MindStunned) then
    Result := '|[$1515DF]<$5>[] (' + IntToStr((Players[P].HeroMagicImmunityTime - States.GameTime)/10) + ')'

  else

    Result := '';

  if Players[P].Preparing then
    Result := '';

end;


function TotalImmunityStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroTotalImmunity
  and not (Players[P].MindStunned) then
    Result := '|[$2235EF]<$116>[] (' + IntToStr((Players[P].HeroTotalImmunityTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function MirrorStatus(P: Integer): ANSIString;
begin
  if Players[P].MirrorTime - States.GameTime > 0 then
    Result := '|[$528FAC]<$137>[] (' + IntToStr((Players[P].MirrorTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function WerewolfStatus(P: Integer): ANSIString;
begin
  if Players[P].WerewolfTime > States.GameTime then
    Result := '|[$5A6FAE]<$6>[] (' + IntToStr((Players[P].WerewolfTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function SilenceStatus(P: Integer): ANSIString;
begin
  if Players[P].HeroSilent then
    Result := '|[$BEBEAA]<$49>[] (' + IntToStr((Players[P].HeroSilentTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function PreparingStatus(P: Integer): ANSIString;
begin
  if Players[P].Preparing then
    Result := '|[$FAC667]<$53>[] (' + IntToStr((Players[P].PreparingTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ReChargeStatus(P: Integer): ANSIString;
begin
  if Players[P].ReCharge then
    Result := '|[$746CCC]<$54>[] (' + IntToStr((Players[P].ReChargeTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function MindStatus(P: Integer): ANSIString;
begin
  if (Players[P].CaptureMind)
  and (Players[P].CaptureMindTime - States.GameTime > 0) then
    Result := '|[$11FF11]<$104>[] ' + '[$' + States.PlayerColorText(M[P]) + ']' + States.PlayerName(M[P]) + '[$FFFFFF]; <$39>: ' + HPColor(M[P]) + IntToStr(Players[M[P]].HP) + '[$FFFFFF] (' + IntToStr((Players[P].CaptureMindTime - States.GameTime)/10) + ')[]' 

  else

    Result := '';
end;


function MindStunnedStatus(P: Integer): ANSIString;
begin
  if (Players[P].MindStunned)
  and (Players[P].StunnedMindTime - States.GameTime > 0)  then
    Result := '|[$0050FF]<$103>[] (' + IntToStr((Players[P].StunnedMindTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ExileStatus(P: Integer): ANSIString;
begin
  if (Players[P].HeroExiled)
  and (Players[P].HeroExileBackTime - States.GameTime > 0) then
    Result := '|[$DEFACA]<$109>[] (' + IntToStr((Players[P].HeroExileBackTime - States.GameTime)/10) + ')'

  else

    Result := '';
end;


function ShieldStatus(P: Integer): ANSIString;
var
  aX, aY: Integer;
begin
  Result := '';
  if Players[P].Hero > 0 then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  end;
  if TileOnBattlefield(aX, aY) then
    if (Tiles[aX][aY].ShieldTime > States.GameTime)
    and (States.MapTileObject(aX, aY) = WARRIOR_OBJECT7) then
      Result := '|[$FCA986]<$113>[] (' + IntToStr((Tiles[aX][aY].ShieldTime - States.GameTime)/10) + ')';
end;


function StatusText(P: Integer): ANSIString;
begin
  Result := ImmortalStatus(P) + StunnedStatus(P) + FearStatus(P) + WerewolfStatus(P) + RegenStatus(P) + DDStatus(P)
  + SilenceStatus(P) + PreparingStatus(P) + ExileStatus(P) + ShieldStatus(P) + ReChargeStatus(P) + RogueStatus(P) + MirrorStatus(P)
  + MindStatus(P) + MindStunnedStatus(P) + RebornStatus(P) + RebornMindStatus(P) + RebornMindStatus2(P) + FieryTrackStatus(P) 
  + TotalImmunityStatus(P) + StatusKill(P) + StatusKillStreak(P) + DefeatStatus(P) + GameplayStatus(P);
end;


procedure CheckDelays(P: Integer);
begin

  if Players[P].RoadSkillDelay > 0 then
    Players[P].RoadSkillDelay := Players[P].RoadSkillDelay - 1;

  if Players[P].FieldSkillDelay > 0 then
    Players[P].FieldSkillDelay := Players[P].FieldSkillDelay - 1;

  if Players[P].WineSkillDelay > 0 then
    Players[P].WineSkillDelay := Players[P].WineSkillDelay - 1;

  if (States.GameTime = Players[P].RocketChargeTime)
  and (Players[P].RocketCharges <= BOWMAN_CHARGES - 1) then
  begin
    Players[P].RocketCharges := Players[P].RocketCharges + 1;
    Players[P].RocketChargeTime := States.GameTime + Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
  end;

  if Players[P].RocketCharges = BOWMAN_CHARGES then
    Players[P].RocketChargeTime := 0;

  if (States.GameTime = Players[P].SnakeChargeTime)
  and (Players[P].SnakeCharges <= SNAKE_CHARGES - 1) then
  begin
    Players[P].SnakeCharges := Players[P].SnakeCharges + 1;
    Players[P].SnakeChargeTime := States.GameTime + Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
  end;

  if Players[P].SnakeCharges = SNAKE_CHARGES then
    Players[P].SnakeChargeTime := 0;

end;


function AIUnitsCount: Integer;
var
  I, K: Integer;
  Units: array of Integer;
begin
  Result := 0;
  for I := 10 to 11 do
  begin
    Units := States.PlayerGetAllUnits(I);
    for K := Low(Units) to High(Units) do
      if Units[K] > 0 then
        if (InRange(States.UnitType(Units[K]), 13, 27))
        and (States.UnitPositionY(Units[K]) > 5) then
          Result := Result + 1;
  end;
end;


function CanUseWineFieldSkill(X, Y: Integer): Boolean;
begin
  Result := False;
  if X <= 0 then
    Exit;
  if Y <= 0 then
    Exit;
  if TileOnBattlefield(X, Y) then 
    Result := (States.MapTileType(X, Y) <> 197)
              and (States.MapTileType(X, Y) <> 202)
              and (States.MapTileType(X, Y) <> 206)
              and (States.MapTileType(X, Y) <> 207)
              and (States.MapTileType(X, Y) <> 215)
              and (States.MapTileType(X, Y) <> 223)
              and (not States.IsRoadAt(8, X, Y))
              and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7);
end;


function SkillName(fSkill: aSkill): ANSIString;
begin
  case fSkill of

    sFieryLance: Result := '<$12>';
    sTeleport: Result := '<$20>';
    s10kSpears: Result := '<$28>';

    sCrackingEarth: Result := '<$14>';
    sWaveOfRage: Result := '<$22>';
    sTotem: Result := '<$30>';

    sSpikedEarth: Result := '<$9>';
    sZombieSummon: Result := '<$17>';
    sFear: Result := '<$25>';

    sAccurateShot: Result := '<$11>';
    sSuddenDeath: Result := '<$19>';
    sSniperShot: Result := '<$27>';

    sGravity: Result := '<$8>';
    sDeadlyFireworks: Result := '<$16>';
    sWerewolf: Result := '<$24>';

    sStrongWill: Result := '<$148>';
    sSweepingBlow: Result := '<$149>';

    sDisorientation: Result := '<$15>';
    sTrack: Result := '<$23>';
    sRegen: Result := '<$31>';

    sViseOfDeath: Result := '<$13>';
    sSacrificialTeleport: Result := '<$21>';
    sTower: Result := '<$29>';

    sRocket: Result := '<$10>';
    sPrison: Result := '<$18>';
    sRevengeFromNowhere: Result := '<$26>';

    sFierySnake: Result := '<$46>';
    sExile: Result := '<$112>';
    sShield: Result := '<$48>';

    sThreadsOfDeath: Result := '<$50>';
    sDeafeningClatter: Result := '<$51>';
    sRagingSpurt: Result := '<$52>';

    sMentalBurst: Result := '<$55>';
    sSteal: Result := '<$56>';
    sUniversal: Result := '';

    sBoomerang: Result := '<$80>';
    sSilence: Result := '<$81>';
    sMind: Result := '<$102>';

    sReplica: Result := '<$135>';
    sRift: Result := '<$136>';
    sMirror: Result := '<$137>';

    sNone: Result := '';

  end;
end;


function SkillInfo(fSkill: aSkill): ANSIString;
begin
  case fSkill of

    sFieryLance: Result := '<$301>';
    sTeleport: Result := '<$401>';
    s10kSpears: Result := '<$501>';

    sCrackingEarth: Result := '<$302>';
    sWaveOfRage: Result := '<$402>';
    sTotem: Result := '<$502>';

    sSpikedEarth: Result := '<$304>';
    sZombieSummon: Result := '<$404>';
    sFear: Result := '<$504>';

    sAccurateShot: Result := '<$303>';
    sSuddenDeath: Result := '<$403>';
    sSniperShot: Result := '<$503>';

    sGravity: Result := '<$307>';
    sDeadlyFireworks: Result := '<$407>';
    sWerewolf: Result := '<$507>';

    sDisorientation: Result := '<$313>';
    sTrack: Result := '<$413>';
    sRegen: Result := '<$513>';

    sViseOfDeath: Result := '<$306>';
    sSacrificialTeleport: Result := '<$406>';
    sTower: Result := '<$506>';

    sRocket: Result := '<$305>';
    sPrison: Result := '<$405>';
    sRevengeFromNowhere: Result := '<$505>';

    sFierySnake: Result := '<$308>';
    sExile: Result := '<$408>';
    sShield: Result := '<$508>';

    sThreadsOfDeath: Result := '<$309>';
    sDeafeningClatter: Result := '<$409>';
    sRagingSpurt: Result := '<$509>';

    sMentalBurst: Result := '<$310>';
    sSteal: Result := '<$410>';
    sUniversal: Result := '<$58>';

    sBoomerang: Result := '<$311>';
    sSilence: Result := '<$411>';
    sMind: Result := '<$511>';

    sReplica: Result := '<$312>';
    sRift: Result := '<$412>';
    sMirror: Result := '<$512>';

    sNone: Result := '<$57>'

    else Result := '';

  end;
end;


function RoadSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$4C818B]<$148>[]';
    16: Result := '[$2222B2]<$9>[]';
    17: Result := '[$0000FF]<$10>.[] <$138>: ' + IntToStr(Players[P].RocketCharges) + '/' + IntToStr(BOWMAN_CHARGES) + IfThenStr(Players[P].RocketCharges < BOWMAN_CHARGES, ' (+1 <$139> ' + IntToStr((Players[P].RocketChargeTime - States.GameTime)/10) + ')', '');
    18: Result := '[$00A5FF]<$11>[]';
    19: Result := '[$4782FF]<$12>[]';
    20: Result := '[$B8B8B8]<$13>[]';
    21: Result := '[$AAAAAA]<$80>[]';
    22: Result := '[$634BBA]<$50>[]';
    23: Result := '[$499AEE]<$14>[]';
    24: Result := '[$C2C3C5]<$135>[]';
    25: Result := '[$ADF346]<$55>[]';
    26: Result := '[$0022FF]<$46>.[] <$138>: ' + IntToStr(Players[P].SnakeCharges) + '/' + IntToStr(SNAKE_CHARGES) + IfThenStr(Players[P].SnakeCharges < SNAKE_CHARGES, ' (+1 <$139> ' + IntToStr((Players[P].SnakeChargeTime - States.GameTime)/10) + ')', '');
    27: Result := '[$FF7648]<$8>[]';
  end;
end;


function FieldSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$00A5FF]<$149>[]';
    16: Result := '[$578B2E]<$17>[]';
    17: Result := '[$8B668B]<$18>[]';
    18: Result := '[$0045FF]<$19>[]';
    19: Result := '[$FFFF97]<$20>[]';
    20: Result := '[$00008B]<$21>[]';
    21: Result := '[$BA5555]<$81>[]';
    22: Result := '[$902F9D]<$51>[]';
    23: Result := '[$4040FF]<$22>[]';
    24: Result := '[$9570BB]<$136>[]';
    25: Result := '[$CC7854]<$56>[]';
    26: Result := '[$528AAF]<$112>[]';
    27: Result := '[$00CDCD]<$16>[]';
  end;
end;


function WineSkillName(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '[$26368B]<$24>[]';
    16: Result := '[$8B008B]<$25>[]';
    17: Result := '[$00FFFF]<$26>[]';
    18: Result := '[$D30094]<$27>[]';
    19: Result := '[$00C7FF]<$28>[]';
    20: Result := '[$006400]<$29>[]';
    21: Result := '[$AAFFAA]<$102>[]';
    22: Result := '[$2580CE]<$52>[]';
    23: Result := '[$EE677A]<$30>[]';
    24: Result := '[$E6E1B4]<$137>[]';
    25: begin
          Result := '[$AE209F]' + Players[P].StolenSkillName + '[]';
          if Players[P].StolenSkillName = '<$10>' then
            Result := Result + '. <$138>: ' + IntToStr(Players[P].RocketCharges) + '/' + IntToStr(BOWMAN_CHARGES) + IfThenStr(Players[P].RocketCharges < BOWMAN_CHARGES, ' (+1 <$139> ' + IntToStr((Players[P].RocketChargeTime - States.GameTime)/10) + ')', '');
          if Players[P].StolenSkillName = '<$46>' then
            Result := Result + '. <$138>: ' + IntToStr(Players[P].SnakeCharges) + '/' + IntToStr(SNAKE_CHARGES) + IfThenStr(Players[P].SnakeCharges < SNAKE_CHARGES, ' (+1 <$139> ' + IntToStr((Players[P].SnakeChargeTime - States.GameTime)/10) + ')', '');
        end;
    26: Result := '[$1707A6]<$48>[]';
    27: Result := '[$00FC7C]<$31>[]';
  end;
end;


function RoadSkillInfo(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '<$307>';
    16: Result := '<$304>';
    17: Result := '<$305>';
    18: Result := '<$303>';
    19: Result := '<$301>';
    20: Result := '<$306>';
    21: Result := '<$311>';
    22: Result := '<$309>';
    23: Result := '<$302>';
    24: Result := '<$312>';
    25: Result := '<$310>';
    26: Result := '<$308>';
    27: Result := '<$313>';
  end;
end;


function FieldSkillInfo(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '<$407>';
    16: Result := '<$404>';
    17: Result := '<$405>';
    18: Result := '<$403>';
    19: Result := '<$401>';
    20: Result := '<$406>';
    21: Result := '<$411>';
    22: Result := '<$409>';
    23: Result := '<$402>';
    24: Result := '<$412>';
    25: Result := '<$410>';
    26: Result := '<$408>';
    27: Result := '<$413>';
  end;
end;


function WineSkillInfo(P, UT: Integer): ANSIString;
begin
  case UT of
    15: Result := '<$507>';
    16: Result := '<$504>';
    17: Result := '<$505>';
    18: Result := '<$503>';
    19: Result := '<$501>';
    20: Result := '<$506>';
    21: Result := '<$511>';
    22: Result := '<$509>';
    23: Result := '<$502>';
    24: Result := '<$512>';
    25: Result := '<$510>';
    26: Result := '<$508>';
    27: Result := '<$513>';
  end;
end;


function HeroDescription(P, UT: Integer): ANSIString;
begin
  case UT of
    15:  Result := '<$207>';
    16:  Result := '<$204>';
    17:  Result := '<$205>';
    18:  Result := '<$203>';
    19:  Result := '<$201>';
    20:  Result := '<$206>';
    21:  Result := '<$211>';
    22:  Result := '<$209>';
    23:  Result := '<$202>';
    24:  Result := '<$212>';
    25:  Result := '<$210>';
    26:  Result := '<$208>'
    else Result := '';
  end;
end;


function PlayerInfo(P: Integer): ANSIString;
begin
  if Players[P].ReChoice then
    Result := ' [$BECADA]<$66>[]; <$39>: ' + HPColor(P) + HPString(P) + '[]' 
  else
    Result := ' <$42>: ' + States.UnitTypeName(Players[P].HeroType) + '; <$39>: ' + HPColor(P) + HPString(P) + '[]';
end;


function BackX(P: Integer): Integer;
var
  aX, aD: Integer;
begin
  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
  case aD of
    0: Result := aX;
    1: Result := aX - 1;
    2: Result := aX - 1;
    3: Result := aX - 1;
    4: Result := aX;
    5: Result := aX + 1;
    6: Result := aX + 1;
    7: Result := aX + 1;
  end;
end;


function BackY(P: Integer): Integer;
var
  aY, aD: Integer;
begin
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  aD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
  case aD of
    0: Result := aY + 1;
    1: Result := aY + 1;
    2: Result := aY;
    3: Result := aY - 1;
    4: Result := aY - 1;
    5: Result := aY - 1;
    6: Result := aY;
    7: Result := aY + 1;
  end;
end;


function FrontX(P: Integer): Integer;
var
  aX, aD: Integer;
begin
  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
  case aD of
    0: Result := aX;
    1: Result := aX + 1;
    2: Result := aX + 1;
    3: Result := aX + 1;
    4: Result := aX;
    5: Result := aX - 1;
    6: Result := aX - 1;
    7: Result := aX - 1;
  end;
end;


function FrontY(P: Integer): Integer;
var
  aY, aD: Integer;
begin
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
  aD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
  case aD of
    0: Result := aY - 1;
    1: Result := aY - 1;
    2: Result := aY;
    3: Result := aY + 1;
    4: Result := aY + 1;
    5: Result := aY + 1;
    6: Result := aY;
    7: Result := aY - 1;
  end;
end;


procedure SetCircle(P, X, Y, R, aObj: Integer; aDef, aSaveCracking: Boolean; fSkill: aSkill);
var
  X1, X2, Y1, Y2, PosX, PosY: Integer;
  Tree: Boolean;
begin
  X1 := X - R;
  X2 := X + R;
  Y1 := Y - R;
  Y2 := Y + R;
  for PosX := X1 to X2 do
  for PosY := Y1 to Y2 do
  begin
    if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= R * R) then
      if TileOnBattlefield_2(PosX, PosY)
      and (PosX > 0)
      and (PosY > 0)
      and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
      and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
      and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
      and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
      and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
      and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT7)
      and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
      and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
      and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
      and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8)
      and (fSkill <> sDeadlyFireworks) then
      begin
        Tree := (aObj = 255)
        and (InRange(States.MapTileObject(PosX, PosY), 149, 172));
        if not Tree then
        begin
          if not Actions.MapTileObjectSet(PosX, PosY, aObj) then
            if ObjectType(aObj) = otKill then
              Actions.MapTileObjectSet(PosX, PosY, UNIVERSAL_KILL_OBJ);
          if (Tiles[PosX][PosY].Owner <> P)
          and (Tiles[PosX][PosY].Skill <> sTrack)
          and (Tiles[PosX][PosY].Skill <> sDeadlyFireworks) then
          begin
            Tiles[PosX][PosY].Owner := P;
            Tiles[PosX][PosY].Skill := fSkill;
          end;
        end;
          if aObj = 255 then
            if Tiles[PosX][PosY].Skill = fSkill then
              Tiles[PosX][PosY].Skill := sNone;
        end;
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            if not Actions.MapTileObjectSet(PosX, PosY, aObj) then
              if ObjectType(aObj) = otKill then
                Actions.MapTileObjectSet(PosX, PosY, UNIVERSAL_KILL_OBJ);
  end;

  if fSkill = sDeadlyFireworks then
  begin
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= R * R) then
        if TileOnBattlefield_2(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT7)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
        and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
        and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8)
        and (not InRange(States.MapTileObject(PosX, PosY), SHIELD_OBJECT, SHIELD_OBJECT8)) then
        begin
          Tree := (aObj = 255)
          and (InRange(States.MapTileObject(PosX, PosY), 149, 172));
          if not Tree then
          begin
            if not Actions.MapTileObjectSet(PosX, PosY, aObj) then
              if ObjectType(aObj) = otKill then
                Actions.MapTileObjectSet(PosX, PosY, UNIVERSAL_KILL_OBJ);
            if (Tiles[PosX][PosY].Skill = sNone)
            or (Tiles[PosX][PosY].Skill = sGravity) then
            begin
              Tiles[PosX][PosY].Owner := P;
              Tiles[PosX][PosY].Skill := fSkill;
            end;
          end;
          if aObj = 255 then
            if Tiles[PosX][PosY].Skill = fSkill then
              Tiles[PosX][PosY].Skill := sNone;
        end;
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            if not Actions.MapTileObjectSet(PosX, PosY, aObj) then
              if ObjectType(aObj) = otKill then
                Actions.MapTileObjectSet(PosX, PosY, UNIVERSAL_KILL_OBJ);
    end;
  end;

  if aDef then
  begin
    Players[P].DefenceTime := States.GameTime + CIRCLE_DEF_TIME;
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= ((R - 1) * (R - 1))) then
        if TileOnBattlefield_2(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT7)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
        and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
        and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8) then
          Actions.MapTileObjectSet(PosX, PosY, ShieldObjects[P]);
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, ShieldObjects[P]);
    end;
  end;

  if aObj = BARB_OBJECT2 then
    if InRange(States.MapTileObject(PosX, PosY), SHIELD_OBJECT, SHIELD_OBJECT8) then
      Actions.MapTileObjectSet(PosX, PosY, ShieldObjects[P]);

  if aObj = PikeObjects[P] then
    Players[P].ClearPikeObjTime := States.GameTime + 20;

  if not aDef then
  begin
    for PosX := X1 to X2 do
    for PosY := Y1 to Y2 do
    begin
      if (((X - PosX) * (X - PosX) + (Y - PosY) * (Y - PosY)) <= ((R - 1) * (R - 1))) then
        if TileOnBattlefield_2(PosX, PosY)
        and (PosX > 0)
        and (PosY > 0)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT3)
        and (States.MapTileObject(PosX, PosY) <> SWORD_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BARB_OBJECT)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_ROCKET)
        and (States.MapTileObject(PosX, PosY) <> BOWMAN_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT7)
        and (States.MapTileObject(PosX, PosY) <> WARRIOR_OBJECT5)
        and (States.MapTileObject(PosX, PosY) <> CIRCLE_FILL_OBJ)
        and (States.MapTileObject(PosX, PosY) <> KNIGHT_OBJECT4)
        and (States.MapTileObject(PosX, PosY) <> VAGA_OBJECT8) then
        begin
          Tree := (aObj = 255)
          and (InRange(States.MapTileObject(PosX, PosY), 149, 172));
          if not Tree then
            Actions.MapTileObjectSet(PosX, PosY, 255);
        end;
        if not aSaveCracking then
          if States.MapTileObject(PosX, PosY) = BARB_OBJECT then
            Actions.MapTileObjectSet(PosX, PosY, 255);
    end;
  end;

end;


procedure CancelSkills(P: Integer);
var
  I, K: Integer;
begin
  try
    if States.GameTime < Players[P].MindTime2 then
    begin
      Players[P].MindTime2 := 0;
      Players[P].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Players[P].CaptureMind := False;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      Players[P].CancelSkillMindSilent := States.GameTime + DELAY_OF_TURNING;
      Players[M[P]].MindStunned := False;
    end;
    
    if (InRange(M2[P], 0, 7)) then
      if States.GameTime < Players[M2[P]].MindTime2 then
      begin
        Players[M2[P]].MindTime2 := 0;
        Players[M2[P]].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[M2[P]].ReCharge)));
        Players[M2[P]].CaptureMind := False;
        Players[P].MindStunned := False;
        Actions.GroupBlockOrders(Players[M2[P]].Hero, False);
      end;

    if TilesRoadLength[P] > 0 then
      for I := 0 to TilesRoadLength[P] - 1 do
        if (SetTilesRoadTimes[P][I] > States.GameTime)
        and (States.GameTime <= Players[P].RoadSkillCancelTime) then
        begin
          SetTilesRoadTimes[P][I] := 0;
          TilesRoadObjects[P][I] := SKILL_CANCEL_OBJ;
        end;

    if TilesFieldLength[P] > 0 then
      for I := 0 to TilesFieldLength[P] - 1 do
        if (SetTilesFieldTimes[P][I] > States.GameTime)
        and (States.GameTime <= Players[P].FieldSkillCancelTime) then
        begin
          SetTilesFieldTimes[P][I] := 0;
          TilesFieldObjects[P][I] := SKILL_CANCEL_OBJ;
        end;

    if TilesWineLength[P] > 0 then
      for I := 0 to TilesWineLength[P] - 1 do
        if (SetTilesWineTimes[P][I] > States.GameTime)
        and (States.GameTime <= Players[P].WineSkillCancelTime) then
        begin
          SetTilesWineTimes[P][I] := 0;
          TilesWineObjects[P][I] := SKILL_CANCEL_OBJ;
        end;
          
    if (InRange(M2[P], 0, 7))
    and Players[M2[P]].MindStunned then
      if TilesWineLength[M2[P]] > 0 then
        for I := 0 to TilesWineLength[M2[P]] - 1 do
          if (SetTilesWineTimes[M2[P]][I] > States.GameTime)
          and (States.GameTime <= Players[M2[P]].WineSkillCancelTime) then
          begin
            SetTilesWineTimes[M2[P]][I] := 0;
            TilesWineObjects[M2[P]][I] := SKILL_CANCEL_OBJ;
          end;

    for I := 0 to 7 do
    begin

      if Players[I].ThreadsAttacker = P then
        Players[I].ThreadsAttacker := -1;

      if Players[I].ScoutSilenceGiver = P then
        Players[I].ScoutSilenceGiver := -1;

      if Players[I].HeroExileGiver = P then
        Players[I].HeroExileGiver := -1;

      if (Players[I].ThreadsTarget = P)
      and (Players[P].ThreadsTime - States.GameTime > DELAY_OF_TURNING * 2) then
      begin
        Players[P].ThreadsTime := 0;
        Players[P].MovedByThreads := False;
        Players[I].ThreadsTarget := -1;
      end;

    end;

    Players[P].TrackStartTime := 0;
    Players[P].TrackStopTime := 0;
    Players[P].SettingTrack := False;
    if Players[P].HeroExileTime > States.GameTime then
    begin
      Players[P].HeroExileBackTime := 0;
      Players[P].HeroExiled := False;
    end;
    Players[P].HeroExileTime := 0;
    Players[P].TowerTime := 0;
    Players[P].ReplicaTime := 0;
    Players[P].MirrorTime := 0;
    RuneCleanupTime[P] := 0;
    Players[P].ThreadsAttackTime := 0;
    if InRange(Players[P].ThreadsTarget, 0, 7) then
      Players[Players[P].ThreadsTarget].ThreadsTime := 0;
    Players[P].ThreadsTarget := -1;
    Players[P].ThreadsTime := 0;
    Players[P].SpurtStartTime := 0;
    Players[P].SpurtEndTime := 0;

    for K := 0 to SPURT_LENGTH - 1 do
      SpurtTimes[P][K] := 0;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to TotemCirclesLength[P][K] - 1 do
        if (TotemCircles[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].WineSkillCancelTime)
        and (TotemCircles[P][K][I].Obj <> 255) then
          TotemCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to ExpCirclesLength[P][K] - 1 do
        if (ExpCircles[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].WineSkillCancelTime)
        and (ExpCircles[P][K][I].Obj <> 255) then
          ExpCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to RogueCirclesLength[P][K] - 1 do
        if (RogueCircles[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].RoadSkillCancelTime)
        and (RogueCircles[P][K][I].Obj <> 255) then
          RogueCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to StolenRogueCirclesLength[P][K] - 1 do
        if (StolenRogueCircles[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].RoadSkillCancelTime)
        and (StolenRogueCircles[P][K][I].Obj <> 255) then
          StolenRogueCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles1Length[P][K] - 1 do
        if (FireworksCircles1[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].FieldSkillCancelTime)
        and (FireworksCircles1[P][K][I].Obj <> 255) then
          FireworksCircles1[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles2Length[P][K] - 1 do
        if (FireworksCircles2[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].FieldSkillCancelTime)
        and (FireworksCircles2[P][K][I].Obj <> 255) then
          FireworksCircles2[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles3Length[P][K] - 1 do
        if (FireworksCircles3[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].FieldSkillCancelTime)
        and (FireworksCircles3[P][K][I].Obj <> 255) then
          FireworksCircles3[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles4Length[P][K] - 1 do
        if (FireworksCircles4[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].FieldSkillCancelTime)
        and (FireworksCircles4[P][K][I].Obj <> 255) then
          FireworksCircles4[P][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles5Length[P][K] - 1 do
        if (FireworksCircles5[P][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[P].FieldSkillCancelTime)
        and (FireworksCircles5[P][K][I].Obj <> 255) then
          FireworksCircles5[P][K][I].Obj := SKILL_CANCEL_OBJ;

  except

    LogError('Exception in the script: cannot cancel skills for invalid player:', [P], SHOW_ERROR_MSG);

  end;

end;


procedure StartReChoice(P: Integer);
begin
  CancelSkills(P);
  Actions.GroupKillAll(Players[P].Hero, True);
  Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
  Actions.FogCoverAll(P);
  Actions.FogRevealRect(P, 4, 4, 30, 30);
  Players[P].ReChoice := True;
  Players[P].ReChoiceTime := States.GameTime + RECHOICE_TIME;
  Actions.CinematicStart(P);
  Actions.CinematicPanTo(P, CENTERSCREEN_X, CENTERSCREEN_Y, 0);
  Actions.CinematicEnd(P);
end;


procedure EndReChoice(P: Integer);
var
  TH: Integer;
begin

  if (InRange(P, 0, 3))
  and (not States.PlayerAllianceCheck(Players[4].ZombiePlayer, P)) then
    Actions.PlayerAllianceChange(Players[4].ZombiePlayer, P, True, True);

  if (InRange(P, 4, 7))
  and (not States.PlayerAllianceCheck(Players[0].ZombiePlayer, P)) then
    Actions.PlayerAllianceChange(Players[0].ZombiePlayer, P, True, True);

  TH := Players[P].Hero;
  Players[P].HeroTotalImmunity := True;
  Players[P].HeroTotalImmunityTime := States.GameTime + TOTAL_IMMUNITY_TIME;
  Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
  Actions.GroupKillAll(TH, True);
  Players[P].ReChoice := False;
  Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
  Actions.FogCoverAll(P);
  Actions.FogRevealRect(P, 1, 39, 70, 109);
  Actions.CinematicStart(P);
  Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
  Actions.CinematicEnd(P);
  Players[P].RoadSkillDelay := 0;
  Players[P].FieldSkillDelay := 0;
  Players[P].WineSkillDelay := 0;
  if not DEBUG_MODE then
    Players[P].ReChoiceAllowed := False;
  Players[P].VagaAppearTimeBack := 0;
  Players[P].VagaAppearTime := 0;
  Players[P].HeroStunnedTime := 0;
  Players[P].HeroSilentTime := 0;
  Players[P].HeroInFearTime := 0;
  Players[P].WerewolfTime := 0;
  Players[P].DDTime := 0;
  Players[P].ReChargeTime := 0;
  Players[P].RocketCharges := BOWMAN_CHARGES;
  Players[P].RocketChargeTime := 0;
  Players[P].SnakeCharges := SNAKE_CHARGES;
  Players[P].SnakeChargeTime := 0;

end;


procedure OnHousePlanPlaced(P, X, Y, HT: Integer);
var
  TX, TY, TD: Integer;
begin
  Actions.PlanRemove(P, X, Y);
  if Players[P].Hero < 0 then
    Exit;
  if Players[P].HeroType <= 0 then
    Exit;
  if not TileOnBattlefield(X, Y) then
    Exit;
  if (HT <> 13)
  and (HT <> 14)
  and (HT <> 9)
  and (HT <> 21)
  and (HT <> 27)
  and (HT <> 11)
  and (HT <> 3) then
    Exit;
  if HT = 13 then
  begin
    Actions.ShowMsg(P, RoadSkillInfo(P, Players[P].HeroType));
    Actions.ShowMsg(P, FieldSkillInfo(P, Players[P].HeroType));
    if (Players[P].HeroType <> 25)
    or ((Players[P].HeroType = 25)
    and (Players[P].StolenSkill = sNone)) then
      Actions.ShowMsg(P, WineSkillInfo(P, Players[P].HeroType));
    if (Players[P].HeroType = 25)
    and (Players[P].StolenSkill <> sNone) then
      Actions.ShowMsg(P, SkillInfo(Players[P].StolenSkill));
  end;
  if (HT = 21)
  and (States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)) = Players[P].SpawnX)
  and (States.UnitPositionY(States.GroupMember(Players[P].Hero, 0)) = Players[P].SpawnY)
  and (Players[P].ReChoiceAllowed)
  and (not Players[P].MindStunned)
  and (not Players[P].CaptureMind)
  and (not Players[P].HeroStunned)
  and (not Players[P].Preparing)
  and (Players[P].HeroType <> 27)
  and (Players[P].HP > 0) then
    StartReChoice(P);
  if (HT = 21)
  and (States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)) = Players[P].SpawnX)
  and (States.UnitPositionY(States.GroupMember(Players[P].Hero, 0)) = Players[P].SpawnY)
  and (not Players[P].ReChoiceAllowed) then
    Actions.ShowMsg(P, '<$65>');
  if (HT = 27)
  and (Players[P].HP < START_HP) then
  begin
    Actions.ShowMsg(-1, 'DEBUG: regen ' + IntToStr(START_HP - Players[P].HP) + ' HP for ' + States.PlayerName(P));
    Players[P].HP := START_HP;
  end;
  if HT = 14 then
  begin
    Actions.ShowMsg(-1, 'DEBUG: reset cooldowns for ' + States.PlayerName(P));
    Players[P].RoadSkillDelay := 0;
    Players[P].FieldSkillDelay := 0;
    Players[P].WineSkillDelay := 0;
    Players[P].RocketCharges := BOWMAN_CHARGES;
    Players[P].RocketChargeTime := 0;
    Players[P].SnakeCharges := SNAKE_CHARGES;
    Players[P].SnakeChargeTime := 0;
  end;
  if HT = 9 then
  begin
    Actions.ShowMsg(-1, 'DEBUG: ' + States.PlayerName(P) + ' has reset the rune');
    RuneTime := 0;
  end;
  if HT = 11 then
  begin
    if not NEW_ARENA then
      Exit;
    if not InRange(ArenaCycles, -1, ARENA_CYCLES - 2) then
      Exit;
    Actions.ShowMsg(-1, 'DEBUG: ' + States.PlayerName(P) + ' has reduced arena size');
    ArenaTime := BORDER_TIME1 + 5;
  end;
  if HT = 3 then
  begin
    if Players[P].Hero <= 0 then
      Exit;
    if Players[P].HeroReborn then
      Exit;
    TX := X;
    TY := Y;
    TD := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if not TileOnBattlefield(TX, TY) then
      Exit;
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, TX, TY, TD, 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
  end;
end;


procedure OnBeacon(P, X, Y: Integer);
var
  Random: Boolean;
  I: Integer;
begin
  if not DEBUG_MODE then
    Exit;
  if States.UnitAt(X, Y) = -1 then
    Exit;
  if States.GameTime > CHOOSE_HERO_TIMER then
    Exit;

  Random := False;

  if TileOnChoiceArea(X, Y) then
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
        if (States.PlayerIsAI(I))
        and (not Players[I].HeroChosen) then
        begin
          Players[I].HeroType := States.UnitType(States.UnitAt(X, Y));
          if Players[I].HeroType = 13 then
          begin
            Random := True;
            case States.KaMRandomI(6) of
              0: Players[I].HeroType := 16;
              1: Players[I].HeroType := 23;
              2: Players[I].HeroType := 18;
              3: Players[I].HeroType := 19;
              4: Players[I].HeroType := 17;
              5: Players[I].HeroType := 22;
            end;
          end;
          Players[I].TempHeroType := Players[I].HeroType;
          Players[I].HeroChosen := True;
          Actions.GiveUnit(8, 13, 13, 14, 4);
          if not Random then
          begin
            if InRange(I, 0, 3) then
              TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[] <$32> ' + States.UnitTypeName(Players[I].HeroType);
            if InRange(I, 4, 7) then
              TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[] <$32> ' + States.UnitTypeName(Players[I].HeroType);
          end
          else
          begin
            if InRange(I, 0, 3) then
              TeamChoice[0] := TeamChoice[0] + '|<$115> [$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]: ' + States.UnitTypeName(Players[I].HeroType);
            if InRange(I, 4, 7) then
              TeamChoice[1] := TeamChoice[1] + '|<$115> [$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]: ' + States.UnitTypeName(Players[I].HeroType);
          end;
        end;
end;


//Heroes & Skills


//SWORD FIGHTER


procedure ZombieStunAnimation(P, U: Integer);
var
  I, X2, Y2: Integer;
begin

  if U <= 0 then
    Exit;

  if States.UnitsGroup(U) <= 0 then
    Exit;

  if States.GroupDead(States.UnitsGroup(U)) then
    Exit;

  X2 := States.UnitPositionX(U);
  Y2 := States.UnitPositionY(U);

  TilesRoadLength[P] := TilesRoadLength[P] + 4;
  SetLength(TilesRoadX[P], TilesRoadLength[P]);
  SetLength(TilesRoadY[P], TilesRoadLength[P]);
  SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
  SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
  SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
  TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
  TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
  TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
  TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
  TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
  TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
  TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
  TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
  ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 5;
  ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 7;
  ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 9;
  ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 11;
    
  SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
  SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 3;
  SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 5;
  SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 7;

  Players[P].ZombieStunTime := States.GameTime + 10;

  for I := 1 to 4 do
  begin
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SWORD_OBJECT;
    if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
    begin
      Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
      Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
    end;
  end;

  for I := 1 to 4 do
    if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
    or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
    or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
    or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
      ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

end;


procedure ZombieStun(P, U: Integer);
var
  X1, X2, Y1, Y2, Desync, Dir: Integer;
begin

  if U <= 0 then
    Exit;

  if States.UnitsGroup(U) <= 0 then
    Exit;

  if States.GroupDead(States.UnitsGroup(U)) then
    Exit;

  X2 := States.UnitPositionX(U);
  Y2 := States.UnitPositionY(U);

  Dir := States.UnitDirection(U);

  Desync := 0;

  if Dir mod 2 = 1 then
    if States.KaMRandom < 0.5 then
      Dir := Dir + 1;

  if Dir = 8 then
    Dir := 0;

  case Dir of

    0,1: for Y1 := Y2 - 1 downto Y2 - 3 do
           if TileOnBattlefield(X2, Y1) then
           begin
             Desync := Desync + 1;
             TilesRoadLength[P] := TilesRoadLength[P] + 1;
             SetLength(TilesRoadX[P], TilesRoadLength[P]);
             SetLength(TilesRoadY[P], TilesRoadLength[P]);
             SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
             TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
             TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 11 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
           end;

    2,3: for X1 := X2 + 1 to X2 + 3 do
           if TileOnBattlefield(X1, Y2) then
           begin
             Desync := Desync + 1;
             TilesRoadLength[P] := TilesRoadLength[P] + 1;
             SetLength(TilesRoadX[P], TilesRoadLength[P]);
             SetLength(TilesRoadY[P], TilesRoadLength[P]);
             SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
             TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
             TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 11 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
           end;

    4,5: for Y1 := Y2 + 1 to Y2 + 3 do
           if TileOnBattlefield(X2, Y1) then
           begin
             Desync := Desync + 1;
             TilesRoadLength[P] := TilesRoadLength[P] + 1;
             SetLength(TilesRoadX[P], TilesRoadLength[P]);
             SetLength(TilesRoadY[P], TilesRoadLength[P]);
             SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
             TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
             TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 11 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
           end;

    6,7: for X1 := X2 - 1 downto X2 - 3 do
           if TileOnBattlefield(X1, Y2) then
           begin
             Desync := Desync + 1;
             TilesRoadLength[P] := TilesRoadLength[P] + 1;
             SetLength(TilesRoadX[P], TilesRoadLength[P]);
             SetLength(TilesRoadY[P], TilesRoadLength[P]);
             SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
             SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
             TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
             TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
             ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 11 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
             TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
           end;
      end;

end;


procedure SpikedEarth(P, X, Y, Dir: Integer);
var
  I, K, X1, Y1, X2, Y2, Desync, Direction, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 13;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 15;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 7;

    Players[P].RoadSkillCancelTime := States.GameTime + 10;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SWORD_OBJECT;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
      begin
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      end;
    end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    if Length(Zombies) > 0 then
      for K := 0 to Length(Zombies) - 1 do
        if not States.UnitDead(Zombies[K].ZombieID) then
          if (Zombies[K].ZombieOwner = P)
          and (InRange(Zombies[K].ZombieType, 1, 2)) then
            if not States.UnitDead(Zombies[K].ZombieID) then
              ZombieStunAnimation(P, Zombies[K].ZombieID);

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             end;

      2,3: for X1 := X2 + 2 to X2 + 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 20 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 10 + Round(DESYNC_FACTOR * Desync/SWORD_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SWORD_OBJECT1 + States.KaMRandomI(3);
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].StunTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 1;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sSpikedEarth;

    Players[P].LastRoadSkill := sSpikedEarth;

    Players[P].RoadSkillDelay := Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;
end;


procedure ZombieSummon(P, X, Y: Integer);
var
  X2, Y2, Zombie: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (States.StatArmyCount(Players[P].ZombiePlayer) < MAX_MILIZOMBIE)
  and (Players[P].ZombiePlayer <> - 1) 
  and (TileOnBattlefield(X, Y)) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= MILIZOMBIE_RADIUS)
    and (Abs(Y2 - Y) <= MILIZOMBIE_RADIUS) then
    begin
      Zombie := Actions.GiveGroup(Players[P].ZombiePlayer, 14 + 9 * Byte(Players[P].DD), X, Y, States.KaMRandomI(8), 1, 1);
      SetLength(Zombies, Length(Zombies) + 1);
      Zombies[Length(Zombies) - 1].ZombieOwner := P;
      if Zombie > 0 then
      begin
        Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Zombie, 0);
        Actions.GroupHungerSet(Zombie, RUNE_ZOMBIE_LIFE);
      end;
      Zombies[Length(Zombies) - 1].ZombieType := 1 + Byte(Players[P].DD);
      Players[P].FieldSkillDelay := Round(SWORD_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Players[P].LastUsedSkill := sZombieSummon;
    end;
  end;

end;


procedure Fear(P, X, Y: Integer);
var
  X2, Y2, U, O, K, UT: Integer;
  R: Single;
  Lure: Boolean;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= IN_FEAR_RADIUS)
    and (Abs(Y2 - Y) <= IN_FEAR_RADIUS)
    and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
      begin
        O := States.UnitOwner(U);
        UT := States.UnitType(U);
      end;

      if (InRange(O, 8, 11))
      and (Players[O].PlayersTeam <> Players[P].PlayersTeam)
      and (InRange(UT, 14, 27)) then
      begin
        R := States.KaMRandom;
        Lure := R < FEAR_LURE_CHANCE;
        if Lure then
        begin
          Players[P].LureType := States.UnitType(U);
          Players[P].LureX := X;
          Players[P].LureY := Y;
          Players[P].LureDir := States.UnitDirection(U);
          Players[P].LureTime := States.GameTime + DELAY_OF_TURNING;
          Players[P].LureHunger := States.UnitHunger(U);
          if Length(Zombies) > 0 then
            for K := 0 to Length(Zombies) - 1 do
              if U = Zombies[K].ZombieID then
                Players[P].LureZombieType := Zombies[K].ZombieType;
        end;
        Actions.UnitKill(U, Lure);
        Players[P].LastUsedSkill := sFear;
        Players[P].WineSkillDelay := Round(SWORD_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      end;

      if U > 0 then
        if InRange(O, 0, 7) then 
          if (U = States.GroupMember(Players[O].Hero, 0))
          and (not Players[O].HeroInFear)
          and (not Players[O].HeroMagicImmunity)
          and (not Players[O].HeroTotalImmunity)
          and (not Players[O].MindStunned)
          and (O <> P)
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
          begin
            Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
            Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$74> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]<$71> ' + SkillName(sFear);
            Players[O].HeroInFear := True;
            Players[O].HeroFearGiver := P;
            Players[O].HeroInFearTime := States.GameTime + IN_FEAR_TIME;
            if Players[O].Hero > 0 then
              Actions.GroupBlockOrders(Players[O].Hero, True);
            Players[P].LastUsedSkill := sFear;
            Players[P].WineSkillDelay := Round(SWORD_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
          end;
    end;
  end;

end;


//BARBARIAN


procedure CrackingEarth(P, X, Y, Dir: Integer);
var
  I, X1, Y1, X2, Y2, Desync, Direction, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 20;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 16;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 17;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 18;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 19;

    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 4;

    Players[P].RoadSkillCancelTime := States.GameTime + 8;

    for I := 1 to 4 do
    begin
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BARB_OBJECT;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
    end;

    for I := 1 to 4 do
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 9 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 9 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 73 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/BARB_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BARB_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sCrackingEarth;

    Players[P].LastRoadSkill := sCrackingEarth;

    Players[P].RoadSkillDelay := Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure WaveOfRage(P, X, Y: Integer);
var
  I, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    RageCirclesCounter[P] := RageCirclesCounter[P] + 1;
    if RageCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      RageCirclesCounter[P] := 0;
    RageCirclesLength[P][RageCirclesCounter[P]] := RageCirclesLength[P][RageCirclesCounter[P]] + RAGE_CYCLES * RAGE_RADIUS;
    SetLength(RageCircles[P][RageCirclesCounter[P]], RageCirclesLength[P][RageCirclesCounter[P]]);

    for I := RageCirclesLength[P][RageCirclesCounter[P]] downto RageCirclesLength[P][RageCirclesCounter[P]] - RAGE_CYCLES * RAGE_RADIUS + 1 do
    begin
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Obj := BARB_OBJECT2;
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].X := X2;
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Y := Y2;
      RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].AddTime := States.GameTime + Round(BARB_FIELD_SPEED * (RageCirclesLength[P][RageCirclesCounter[P]] - I));
      if I mod RAGE_RADIUS > 0 then
        RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Radius := RAGE_RADIUS + 2 - I mod RAGE_RADIUS
      else
        RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Radius := 1;
    end; 
       
    for I := 0 to RageCirclesLength[P][RageCirclesCounter[P]] - 1 do 
      if I mod RAGE_RADIUS = 1 then
        RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - I].Obj := 255;

    Players[P].LastUsedSkill := sWaveOfRage;

    Players[P].FieldSkillDelay := Round(BARB_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearRageArray[P][RageCirclesCounter[P]] := RageCircles[P][RageCirclesCounter[P]][RageCirclesLength[P][RageCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure TotemOfAncestors(P, X, Y: Integer);
var
  I, X2, Y2, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0)
  and not (InRange(States.MapTileObject(X, Y), SHIELD_OBJECT, SHIELD_OBJECT8)) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 37;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    TotemCirclesCounter[P] := TotemCirclesCounter[P] + 1;
    if TotemCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      TotemCirclesCounter[P] := 0;
    if (Abs(X2 - X) <= TOTEM_ADD_RADIUS)
    and (Abs(Y2 - Y) <= TOTEM_ADD_RADIUS) then
    begin

      TotemCirclesLength[P][TotemCirclesCounter[P]] := TotemCirclesLength[P][TotemCirclesCounter[P]] + TOTEM_CYCLES * TOTEM_RADIUS;
      SetLength(TotemCircles[P][TotemCirclesCounter[P]], TotemCirclesLength[P][TotemCirclesCounter[P]]);
      TilesWineLength[P] := TilesWineLength[P] + 9;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);

      TilesWineX[P][Length(TilesWineX[P]) - 1] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y;

      TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2;
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;

      for I := 2 to 9 do
      begin
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BARB_OBJECT5;
        if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
      end;

      TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BARB_OBJECT3;

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 38;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 110;
      Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 30;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 36;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 36;

      Players[P].WineSkillCancelTime := States.GameTime + 36;

      for I := 1 to 9 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      for I := TotemCirclesLength[P][TotemCirclesCounter[P]] downto TotemCirclesLength[P][TotemCirclesCounter[P]] - TOTEM_CYCLES * TOTEM_RADIUS + 1 do
      begin
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Obj := BARB_OBJECT4;
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].X := X;
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Y := Y;
        TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].AddTime := States.GameTime + 39 + Round((TotemCirclesLength[P][TotemCirclesCounter[P]] - I) / BARB_WINE_SPEED);
        if I mod TOTEM_RADIUS > 0 then
          TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Radius := TOTEM_RADIUS + 1 - I mod TOTEM_RADIUS
        else
          TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Radius := 1;
        end;
        
      for I := 0 to TotemCirclesLength[P][TotemCirclesCounter[P]] - 1 do 
        if I mod TOTEM_RADIUS = 1 then
          TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - I].Obj := 255;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := Direction;
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      end;

      if TileOnRuneSpawn(X, Y) then
        RuneCleanupTime[P] := States.GameTime + 37;

      Players[P].LastUsedSkill := sTotem;

      Players[P].LastWineSkill := sTotem;

      Players[P].WineSkillDelay := Round(BARB_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      TimeToClearTotemArray[P][TotemCirclesCounter[P]] := TotemCircles[P][TotemCirclesCounter[P]][TotemCirclesLength[P][TotemCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

      ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


//LANCE CARRIER


procedure FieryLance(P, X, Y, Dir: Integer);
var
  I, X1, Y1, X2, Y2, Desync, Direction, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 29;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end; 

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - Points[4]] := LANCE_OBJECT;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - Points[3]] := LANCE_OBJECT;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - Points[2]] := LANCE_OBJECT2;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - Points[1]] := LANCE_OBJECT2;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 15;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 18;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 8;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 11;

    Players[P].RoadSkillCancelTime := States.GameTime + 12;

    for I := 1 to 4 do
    begin
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
    end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 11 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 11 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 11 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 11 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/LANCE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := LANCE_OBJECT;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sFieryLance;

    Players[P].LastRoadSkill := sFieryLance;

    Players[P].RoadSkillDelay := Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Teleport(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= TELEPORT_RADIUS)
    and (Abs(Y2 - Y) <= TELEPORT_RADIUS) then
    begin
      Players[P].LastUsedSkill := sTeleport;
      if States.PlayerIsAI(P) then 
        Players[P].TempHeroType := Players[P].HeroType;
      Actions.GroupKillAll(Players[P].Hero, True);
      if not States.PlayerIsAI(P) then
      begin
        Players[P].TeleportTime := States.GameTime + DELAY_OF_TURNING;
        Players[P].TeleportX := X;
        Players[P].TeleportY := Y;
        Players[P].TeleportDir := NewDir;
        Players[P].Hero := Actions.GiveGroup(TEMP_PLAYER, Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      end
      else
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, X, Y, IfThen(Players[P].SkillCastDir >= 0, Players[P].SkillCastDir, NewDir), 1, 1);
      Players[P].FieldSkillDelay := Round(LANCE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
    end;
  end;

end;


procedure TenThousandsSpears(P, X, Y, Dir: Integer);
var
  I, J, K, X1, Y1, X2, Y2, Desync, Direction, Temp, Temp2: Integer;
  Points, Points2: array[1..24] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 60;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    for I := 1 to 24 do
    begin
      Points[I] := I;
      Points2[I] := I;
    end;

    if RANDOM_ANIMATIONS then
    begin
      if States.KaMRandom < 0.5 then
        for I := 1 to 24 div 2 do
        begin
          Temp2 := Points2[I];
          Points2[I] := Points2[24 - I + 1];
          Points2[24 - I + 1] := Temp2;
        end;
      for J := 1 to States.KaMRandomI(8) do
      begin
        Temp := Points[1];
        for K := 1 to 23 do
          Points[K] := Points[K + 1];
        Points[24] := Temp;
      end;
    end;

    TilesWineLength[P] := TilesWineLength[P] + 24;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - Points2[24]] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[23]] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[22]] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[21]] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - Points2[24]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[23]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[22]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[21]] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - Points2[20]] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[19]] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[18]] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[17]] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - Points2[20]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[19]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[18]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[17]] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - Points2[16]] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[15]] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[14]] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[13]] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - Points2[16]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[15]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[14]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[13]] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - Points2[12]] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[11]] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[10]] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[9]] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - Points2[12]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[11]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[10]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[9]] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - Points2[8]] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[7]] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[6]] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[5]] := X2 + 1;

    TilesWineY[P][Length(TilesWineY[P]) - Points2[8]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[7]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[6]] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[5]] := Y2;

    TilesWineX[P][Length(TilesWineX[P]) - Points2[4]] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[3]] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[2]] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - Points2[1]] := X2 - 1;

    TilesWineY[P][Length(TilesWineY[P]) - Points2[4]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[3]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[2]] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - Points2[1]] := Y2;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[24]] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[23]]:= LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[22]] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[21]] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[24]] := States.GameTime + 26;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[23]] := States.GameTime + 27;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[22]] := States.GameTime + 28;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[21]] := States.GameTime + 29;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[24]] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[23]] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[22]] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[21]] := States.GameTime + 4;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[20]] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[19]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[18]] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[17]] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[20]] := States.GameTime + 30;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[19]] := States.GameTime + 31;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[18]] := States.GameTime + 32;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[17]] := States.GameTime + 33;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[20]] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[19]] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[18]] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[17]] := States.GameTime + 8;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[16]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[15]] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[14]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[13]] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[16]] := States.GameTime + 26;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[15]] := States.GameTime + 27;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[14]] := States.GameTime + 28;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[13]] := States.GameTime + 29;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[16]] := States.GameTime + 9;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[15]] := States.GameTime + 10;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[14]] := States.GameTime + 11;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[13]] := States.GameTime + 12;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[12]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[11]] := LANCE_OBJECT2;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[10]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[9]] := LANCE_OBJECT2;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[12]] := States.GameTime + 30;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[11]] := States.GameTime + 31;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[10]] := States.GameTime + 32;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[9]] := States.GameTime + 33;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[12]] := States.GameTime + 13;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[11]] := States.GameTime + 14;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[10]] := States.GameTime + 15;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[9]] := States.GameTime + 16;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[8]] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[7]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[6]] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[5]] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[8]] := States.GameTime + 26;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[7]] := States.GameTime + 27;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[6]] := States.GameTime + 28;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[5]] := States.GameTime + 29;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[8]] := States.GameTime + 17;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[7]] := States.GameTime + 18;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[6]] := States.GameTime + 19;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[5]] := States.GameTime + 20;

    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[4]] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[3]] := LANCE_OBJECT;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[2]] := LANCE_OBJECT3;
    TilesWineObjects[P][Length(TilesWineObjects[P]) - Points[1]] := LANCE_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[4]] := States.GameTime + 30;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[3]] := States.GameTime + 31;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[2]] := States.GameTime + 32;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[1]] := States.GameTime + 33;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[4]] := States.GameTime + 21;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[3]] := States.GameTime + 22;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[2]] := States.GameTime + 23;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[1]] := States.GameTime + 24;

    Players[P].WineSkillCancelTime := States.GameTime + 32;

    for I := 1 to 24 do
    begin
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;
    end;

    for K := 0 to TEN_K_SPEARS_WAVES - 1 do
    begin

      case Direction of

        0,1: begin
               for Y1 := Y2 - 2 downto Y2 - 22 do
               for X1 := X2 - 1 to X2 + 1 do
               begin
                 Desync := Desync + 1;
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 38 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 33 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
               end;
             end;

        2,3: begin
               for X1 := X2 + 2 to X2 + 22 do
               for Y1 := Y2 - 1 to Y2 + 1 do
               begin
                 Desync := Desync + 1;
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 38 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 33 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
               end;
             end;

        4,5: begin
               for Y1 := Y2 + 2 to Y2 + 22 do
               for X1 := X2 - 1 to X2 + 1 do
               begin
                 Desync := Desync + 1;
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 38 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 33 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
               end;
             end;

        6,7:  begin
               for X1 := X2 - 2 downto X2 - 22 do
               for Y1 := Y2 - 1 to Y2 + 1 do
               begin
                 Desync := Desync + 1;
                 if TileOnBattlefield(X1, Y1) then
                 begin
                   TilesWineLength[P] := TilesWineLength[P] + 1;
                   SetLength(TilesWineX[P], TilesWineLength[P]);
                   SetLength(TilesWineY[P], TilesWineLength[P]);
                   SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
                   SetLength(TilesWineObjects[P], TilesWineLength[P]);
                   TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
                   TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
                   ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 38 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 33 + 16 * K + Round(DESYNC_FACTOR * Desync/LANCE_WINE_SPEED);
                   TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := LANCE_OBJECT;
                   Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
                 end;
               end;
             end;
        end;

    end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := s10kSpears;

    Players[P].LastWineSkill := s10kSpears;

    Players[P].WineSkillDelay := Round(LANCE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


//CROSSBOWMAN


procedure AccurateShot(P, X, Y, Dir: Integer);
var
  I, X1, Y1, X2, Y2, Desync, Direction, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 14;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 11;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 12;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 5;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 7;

    Players[P].RoadSkillCancelTime := States.GameTime + 12;

    for I := 1 to 4 do
    begin   
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := XBOW_OBJECT2;
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
    end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 13 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 13 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 13 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 13 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/XBOW_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sAccurateShot;

    Players[P].LastRoadSkill := sAccurateShot;

    Players[P].RoadSkillDelay := Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure SuddenDeath(P, X, Y: Integer);
var
  I, X2, Y2, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 30;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) > BOMB_RADIUS)
    or (Abs(Y2 - Y) > BOMB_RADIUS) then
      Exit;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    if (Abs(X2 - X) <= BOMB_RADIUS)
    and (Abs(Y2 - Y) <= BOMB_RADIUS) then
    begin
      TilesFieldLength[P] := TilesFieldLength[P] + 13;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
    
      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;

      for I := 1 to 4 do    
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := XBOW_OBJECT;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[4]] := States.GameTime + 17;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[3]] := States.GameTime + 21;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[2]] := States.GameTime + 25;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[1]] := States.GameTime + 29;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[4]] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[3]] := States.GameTime + 5;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[2]] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[1]] := States.GameTime + 13;
        
      TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X;
      TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 9] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y;
      TilesFieldX[P][Length(TilesFieldX[P]) - 10] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 11] := X + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 12] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 13] := X - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 13] := Y - 1;

      Players[P].FieldSkillCancelTime := States.GameTime + 29;

      for I := 5 to 13 do
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := XBOW_OBJECT3;

      for I := 10 to 13 do
      begin
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 64;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 34;
      end;

      for I := 6 to 9 do
      begin
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 62;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 32;
      end;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 5] := States.GameTime + 60;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 5] := States.GameTime + 30;

      for I := 1 to 13 do
      begin
        if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13];
        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;
      end;

      Players[P].SuddenTime := States.GameTime + 66;
      Players[P].SuddenX := X;
      Players[P].SuddenY := Y;

      Players[P].LastUsedSkill := sSuddenDeath;

      Players[P].LastFieldSkill := sSuddenDeath;

      Players[P].FieldSkillDelay := Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    end;

    if States.PlayerIsAI(P) then
    begin
      Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13] + CLEAR_ARRAY_FACTOR + 3;

  end;

end;


procedure SniperShot(P, X, Y, Dir: Integer);
var
  I, X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 21;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 5 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := XBOW_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 10;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 11;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 12;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 13;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
    
    for I := 1 to 4 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := XBOW_OBJECT2;
    
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 16;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 17;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    Players[P].WineSkillCancelTime := States.GameTime + 17;

    for I := 1 to 8 do
    begin
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;
    end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 48 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 48 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 48 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 48 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/XBOW_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := XBOW_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sSniperShot;

    Players[P].LastWineSkill := sSniperShot;

    Players[P].WineSkillDelay := Round(XBOW_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


//PIKEMAN


procedure ViseOfDeath(P, X, Y, Dir: Integer);
var
  I, X1, Y1, X2, Y2, Desync, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 29;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    ViseCirclesCounter[P] := ViseCirclesCounter[P] + 1;
    if ViseCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      ViseCirclesCounter[P] := 0;

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    ViseCirclesLength[P][ViseCirclesCounter[P]] := ViseCirclesLength[P][ViseCirclesCounter[P]] + VISE_CYCLES * VISE_RADIUS;
    SetLength(ViseCircles[P][ViseCirclesCounter[P]], ViseCirclesLength[P][ViseCirclesCounter[P]]);
    for I := ViseCirclesLength[P][ViseCirclesCounter[P]] downto ViseCirclesLength[P][ViseCirclesCounter[P]] - VISE_CYCLES * VISE_RADIUS + 1 do
    begin
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Obj := PikeObjects[P];
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].X := X2;
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Y := Y2;
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].AddTime := States.GameTime + Round(PIKE_ROAD_SPEED * I);
      ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Radius := VISE_RADIUS - I mod VISE_RADIUS;
      if I mod VISE_RADIUS = 0 then
        ViseCircles[P][ViseCirclesCounter[P]][ViseCirclesLength[P][ViseCirclesCounter[P]] - I].Radius := 0;
    end;

    Players[P].RoadSkillCancelTime := States.GameTime + 8;

    case Direction of

      0,1: for Y1 := Y2 - 3 downto Y2 - 10 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 3 to X2 + 10 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 3 to Y2 + 10 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 3 downto X2 - 10 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 12 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 8 + Round(DESYNC_FACTOR * Desync/PIKE_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := PIKE_OBJECT9;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sViseOfDeath;

    Players[P].LastRoadSkill := sViseOfDeath;

    Players[P].RoadSkillDelay := Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearViseArray[P][ViseCirclesCounter[P]] := ViseCircles[P][ViseCirclesCounter[P]][0].AddTime + CLEAR_ARRAY_FACTOR;

    if TilesRoadLength[P] > 0 then
      ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure SacrificialTeleport(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (Players[P].Hero > 0)
  and (Players[P].HP >= 2)
  and (TileOnBattlefield(X, Y))
  and not (Players[P].CaptureMind) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= SACRIFICIAL_RADIUS)
    and (Abs(Y2 - Y) <= SACRIFICIAL_RADIUS) then
    begin
      Players[P].LastUsedSkill := sSacrificialTeleport;
      Players[P].FieldSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Actions.GroupKillAll(Players[P].Hero, False);
      Players[P].HP := Players[P].HP - 1;  
      Players[P].TeleportTime := States.GameTime + DELAY_OF_TURNING;
      Players[P].TeleportX := X;
      Players[P].TeleportY := Y;
      Players[P].TeleportDir := NewDir;
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;
  end;

  if InRange(M[P], 0, 7) then
    if (Players[M[P]].Hero > 0)
    and (Players[M[P]].HP >= 2)
    and (TileOnBattlefield(X, Y))
    and (Players[P].CaptureMind) then
    begin
      NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if (Abs(X2 - X) <= SACRIFICIAL_RADIUS)
      and (Abs(Y2 - Y) <= SACRIFICIAL_RADIUS) then
      begin
        Players[P].LastUsedSkill := sSacrificialTeleport;
        Players[P].FieldSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        Actions.GroupKillAll(Players[P].Hero, False);
        Players[M[P]].HP := Players[M[P]].HP - 1;  
        Players[P].TeleportTime := States.GameTime + DELAY_OF_TURNING;
        Players[P].TeleportX := X;
        Players[P].TeleportY := Y;
        Players[P].TeleportDir := NewDir;
        Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      end;
    end;
  
end;


procedure InfernalTower(P, X, Y: Integer);
var
  I, X2, Y2, Direction: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (Players[P].Hero > 0)
  and (TileOnBattlefield(X, Y))
  and (TileOnBattlefield(X, Y + 1))
  and (TileOnBattlefield(X, Y - 1))
  and (TileOnBattlefield(X - 1, Y))
  and (TileOnBattlefield(X - 1, Y - 1)) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= TOWER_RADIUS)
    and (Abs(Y2 - Y) <= TOWER_RADIUS) then
      begin
      TilesWineLength[P] := TilesWineLength[P] + 8;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);

      TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

      for I := 5 to 8 do
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := PIKE_OBJECT10;

      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 16;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 1;
    
      for I := 1 to 4 do
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := PIKE_OBJECT11;
    
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 24;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 24;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 24;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 24;
    
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 8;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 8;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 8;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

      for I := 1 to 8 do
      begin
        if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;
      end;

      Players[P].TowerTime := States.GameTime + TOWER_DELAY;
      Players[P].TowerX := X;
      Players[P].TowerY := Y;
      Players[P].WineSkillDelay := Round(PIKE_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Players[P].LastUsedSkill := sTower;
      Players[P].LastWineSkill := sTower;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := Direction;
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      end;

    end;
  end;
end;


procedure PlaceTower(P: Integer);
var
  Recruit, Tower, aX, aY: Integer;
begin
  Tower := Actions.GiveHouse(Players[P].ZombiePlayer, 17, Players[P].TowerX, Players[P].TowerY);
  if Tower > 0 then
  begin
    for aX := Players[P].TowerX - 2 to Players[P].TowerX + 1 do
    for aY := Players[P].TowerY - 2 to Players[P].TowerY + 1 do
      if TileOnBattlefield(aX, aY) then
      begin
        Tiles[aX][aY].Owner := P;
        Tiles[aX][aY].Skill := sTower;
      end;
    Recruit := Actions.GiveUnit(Players[P].ZombiePlayer, 13, Players[P].TowerX, Players[P].TowerY + 3, States.KaMRandomI(8));
    SetLength(Zombies, Length(Zombies) + 1);
    Zombies[Length(Zombies) - 1].ZombieOwner := P;
    Zombies[Length(Zombies) - 1].ZombieID := Recruit;
    Zombies[Length(Zombies) - 1].ZombieType := 0;
    Actions.UnitHungerSet(Recruit, RECRUIT_HUNGER + States.UnitLowHunger);
    Actions.HouseAddWaresTo(Tower, 1, 5);
    Actions.HouseAddDamage(Tower, 185);
  end;
end;


//OLD VAGA_VAGA


procedure Disorientation(P, X, Y: Integer);
var
  I, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    {if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 11;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;}

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= SHOCK_RADIUS)
    and (Abs(Y2 - Y) <= SHOCK_RADIUS) then
    begin
      TilesRoadLength[P] := TilesRoadLength[P] + 9;
      SetLength(TilesRoadX[P], TilesRoadLength[P]);
      SetLength(TilesRoadY[P], TilesRoadLength[P]);
      SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
        
      TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 6] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 6] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 7] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 7] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 8] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 8] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 9] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 9] := Y - 1;

      for I := 1 to 9 do
        TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := VAGA_OBJECT6;

      for I := 6 to 9 do
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 10;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 6;
      end;

      for I := 2 to 5 do
      begin
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 8;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 4;
      end;

      ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 6;
      SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 2;

      for I := 1 to 9 do
      begin
        if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
          Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 9];
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
      end;

      Players[P].LastUsedSkill := sDisorientation;

      Players[P].LastRoadSkill := sDisorientation;

      Players[P].RoadSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 9] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


procedure FieryTrack(P, X, Y: Integer);
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if Players[P].SettingTrack then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Players[P].TrackStartTime := States.GameTime + TRACK_DELAY;
    Players[P].LastUsedSkill := sTrack;
    Players[P].FieldSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
  end;

end;


//VAGA-VAGA


procedure Gravity(P, X, Y: Integer);
var
  I, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero <> -1) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= GRAVITY_RADIUS1)
    and (Abs(Y2 - Y) <= GRAVITY_RADIUS1) then
    begin
      Players[P].GravityX := X;
      Players[P].GravityY := Y;
      GravityCirclesLength[P] := GravityCirclesLength[P] + GRAVITY_CYCLES * GRAVITY_RADIUS;
      SetLength(GravityCircles[P], GravityCirclesLength[P]);
      for I := GravityCirclesLength[P] downto GravityCirclesLength[P] - GRAVITY_CYCLES * GRAVITY_RADIUS + 1 do
      begin
        GravityCircles[P][GravityCirclesLength[P] - I].Obj := VAGA_OBJECT9;
        GravityCircles[P][GravityCirclesLength[P] - I].X := X;
        GravityCircles[P][GravityCirclesLength[P] - I].Y := Y;
        GravityCircles[P][GravityCirclesLength[P] - I].AddTime := States.GameTime + Round(VAGA_ROAD_SPEED * I);
        GravityCircles[P][GravityCirclesLength[P] - I].Radius := GRAVITY_RADIUS - I mod GRAVITY_RADIUS;
        if I mod GRAVITY_RADIUS = 0 then
          GravityCircles[P][GravityCirclesLength[P] - I].Radius := 0;
      end;

    Players[P].LastUsedSkill := sGravity;

    Players[P].RoadSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearGravityArray[P] := GravityCircles[P][0].AddTime + CLEAR_ARRAY_FACTOR;
      
    end;

  end;

end;


procedure DeadlyFireworks(P, X, Y: Integer);
var
  I, X2, Y2, R1, R2: Integer;
  R: array[0..9] of Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X2 - X) <= FIRE_RADIUS)
    and (Abs(Y2 - Y) <= FIRE_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 40;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      Players[P].FireworkTime := States.GameTime + 58;
      Players[P].FireworkX := X;
      Players[P].FireworkY := Y;

      TilesFieldLength[P] := TilesFieldLength[P] + 31;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);

      for I := 1 to 4 do
        Points[I] := I;

      if RANDOM_ANIMATIONS then
        if States.KaMRandom > 0.5 then
          for I := 1 to 4 do
            Points[I] := -1 * (I - 5);

      for I := 0 to 9 do
        R[I] := States.KaMRandomI(3) + 1;

      for I := 21 to 26 do
      begin
        TilesFieldX[P][Length(TilesFieldX[P]) - I] := X;
        TilesFieldY[P][Length(TilesFieldX[P]) - I] := Y;
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := VAGA_OBJECT12;
      end;

      for I := 27 to 31 do
      begin
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := CIRCLE_FILL_OBJ;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - I] := States.GameTime + 48;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := States.GameTime + 58;
      end;

      TilesFieldX[P][Length(TilesFieldX[P]) - 20] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 19] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 18] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 17] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 20] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 19] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 18] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 17] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 16] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 15] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 14] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 13] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 16] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 15] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 14] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 13] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 12] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 11] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 10] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 9] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 12] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 11] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 10] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 9] := Y2 - 1;
    
      TilesFieldX[P][Length(TilesFieldX[P]) - 8] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 7] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 6] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 5] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 8] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 7] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 6] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 5] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;

      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;

      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 26] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 25] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 24] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 23] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 22] := States.GameTime + 16;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 21] := States.GameTime + 8;

      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 26] := States.GameTime + 38;    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 25] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 24] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 23] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 22] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 21] := States.GameTime + 1;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 20] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 19] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 18] := States.GameTime + 40;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 17] := States.GameTime + 40;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 20] := States.GameTime + 38;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 19] := States.GameTime + 38;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 18] := States.GameTime + 38;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 17] := States.GameTime + 38;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 16] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 15] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 14] := States.GameTime + 35;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 13] := States.GameTime + 35;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 16] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 15] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 14] := States.GameTime + 32;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 13] := States.GameTime + 32;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 12] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 11] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 10] := States.GameTime + 29;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 9] := States.GameTime + 29;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 12] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 11] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 10] := States.GameTime + 26;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 9] := States.GameTime + 26;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 8] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 7] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 6] := States.GameTime + 23;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 5] := States.GameTime + 23;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 8] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 7] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 6] := States.GameTime + 20;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 5] := States.GameTime + 20;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[4]] := States.GameTime + 16;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[3]] := States.GameTime + 16;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[4]] := States.GameTime + 9;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[3]] := States.GameTime + 9;

      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[2]] := States.GameTime + 8;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[1]] := States.GameTime + 8;

      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[2]] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[1]] := States.GameTime + 1;

      Players[P].FieldSkillCancelTime := States.GameTime + 40;

      for I := 1 to 20 do
      begin
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := VAGA_OBJECT11;
        if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
          Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 26];
      end;

      for I := 1 to 20 do
        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = WARRIOR_OBJECT7) then
           ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

      FireworksCircles1Counter[P] := FireworksCircles1Counter[P] + 1;
      if FireworksCircles1Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles1Counter[P] := 0;

      FireworksCircles2Counter[P] := FireworksCircles2Counter[P] + 1;
      if FireworksCircles2Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles2Counter[P] := 0;

      FireworksCircles3Counter[P] := FireworksCircles3Counter[P] + 1;
      if FireworksCircles3Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles3Counter[P] := 0;

      FireworksCircles4Counter[P] := FireworksCircles4Counter[P] + 1;
      if FireworksCircles4Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles4Counter[P] := 0;

      FireworksCircles5Counter[P] := FireworksCircles5Counter[P] + 1;
      if FireworksCircles5Counter[P] = MAX_CIRCLES_AT_ONCE then
        FireworksCircles5Counter[P] := 0;

      FireworksCircles1Length[P][FireworksCircles1Counter[P]] := FireworksCircles1Length[P][FireworksCircles1Counter[P]] + FIREWORKS1_CYCLES * FIREWORKS1_RADIUS;
      SetLength(FireworksCircles1[P][FireworksCircles1Counter[P]], FireworksCircles1Length[P][FireworksCircles1Counter[P]]);
      for I := FireworksCircles1Length[P][FireworksCircles1Counter[P]] downto FireworksCircles1Length[P][FireworksCircles1Counter[P]] - FIREWORKS1_CYCLES * FIREWORKS1_RADIUS + 1 do
      begin
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Obj := VAGA_OBJECT10;
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].X := X;
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Y := Y;
        TilesFieldX[P][Length(TilesFieldX[P]) - 27] := X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 27] := Y;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 27] := States.GameTime + 40;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 27] := States.GameTime + 50;
        FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].AddTime := States.GameTime + 40 + Round(VAGA_FIELD_SPEED * (FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I));
        if I mod FIREWORKS1_RADIUS > 0 then
          FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Radius := FIREWORKS1_RADIUS - I mod FIREWORKS1_RADIUS
        else
          FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles1Length[P][FireworksCircles1Counter[P]] - 1 do 
        if I mod FIREWORKS1_RADIUS = 1 then
          FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - I].Obj := 255;

      R1 := R[States.KaMRandomI(10)];
      R2 := R[States.KaMRandomI(10)];
      FireworksCircles2Length[P][FireworksCircles2Counter[P]] := FireworksCircles2Length[P][FireworksCircles2Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles2[P][FireworksCircles2Counter[P]], FireworksCircles2Length[P][FireworksCircles2Counter[P]]);
      for I := FireworksCircles2Length[P][FireworksCircles2Counter[P]] downto FireworksCircles2Length[P][FireworksCircles2Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Obj := VAGA_OBJECT10;
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].X := X + FIREWORKS1_RADIUS - 1;
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Y := Y;
        if R1 < 2 then
        begin
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].X := X + FIREWORKS1_RADIUS - R2 - 1;
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS + R2 + 1;
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 28] := FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 28] := FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Y;
        FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].AddTime := States.GameTime + 48 + Round(VAGA_FIELD_SPEED * (FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles2Length[P][FireworksCircles2Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - I].Obj := 255;

      R1 := R[States.KaMRandomI(10)];
      R2 := R[States.KaMRandomI(10)];
      FireworksCircles3Length[P][FireworksCircles3Counter[P]] := FireworksCircles3Length[P][FireworksCircles3Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles3[P][FireworksCircles3Counter[P]], FireworksCircles3Length[P][FireworksCircles3Counter[P]]);
      for I := FireworksCircles3Length[P][FireworksCircles3Counter[P]] downto FireworksCircles3Length[P][FireworksCircles3Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Obj := VAGA_OBJECT10;
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].X := X - FIREWORKS1_RADIUS + 1;
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Y := Y;
        if R1 < 2 then
        begin
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].X := X - FIREWORKS1_RADIUS + R2 + 1;
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS + R2 + 1;
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 29] := FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 29] := FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Y;
        FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].AddTime := States.GameTime + 48 + Round(VAGA_FIELD_SPEED * (FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles3Length[P][FireworksCircles3Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - I].Obj := 255;

      R1 := R[States.KaMRandomI(10)];
      R2 := R[States.KaMRandomI(10)];
      FireworksCircles4Length[P][FireworksCircles4Counter[P]] := FireworksCircles4Length[P][FireworksCircles4Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles4[P][FireworksCircles4Counter[P]], FireworksCircles4Length[P][FireworksCircles4Counter[P]]);
      for I := FireworksCircles4Length[P][FireworksCircles4Counter[P]] downto FireworksCircles4Length[P][FireworksCircles4Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Obj := VAGA_OBJECT10;
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].X := X;
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Y := Y + FIREWORKS1_RADIUS - 1;
        if R1 < 2 then
        begin
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].X := X + FIREWORKS1_RADIUS - R2 - 1;
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Y := Y + FIREWORKS1_RADIUS - R2 - 1;
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 30] := FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 30] := FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Y;
        FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].AddTime := States.GameTime + 48 + Round(VAGA_FIELD_SPEED * (FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
        else
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles4Length[P][FireworksCircles4Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - I].Obj := 255;

      R1 := R[States.KaMRandomI(10)];
      R2 := R[States.KaMRandomI(10)];
      FireworksCircles5Length[P][FireworksCircles5Counter[P]] := FireworksCircles5Length[P][FireworksCircles5Counter[P]] + FIREWORKS2_CYCLES * FIREWORKS2_RADIUS;
      SetLength(FireworksCircles5[P][FireworksCircles5Counter[P]], FireworksCircles5Length[P][FireworksCircles5Counter[P]]);
      for I := FireworksCircles5Length[P][FireworksCircles5Counter[P]] downto FireworksCircles5Length[P][FireworksCircles5Counter[P]] - FIREWORKS2_CYCLES * FIREWORKS2_RADIUS + 1 do
      begin
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Obj := VAGA_OBJECT10;
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].X := X;
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS + 1;
        if R1 < 2 then
        begin
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].X := X - FIREWORKS1_RADIUS + R2 + 1;
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Y := Y - FIREWORKS1_RADIUS + R2 + 1;
        end;
        TilesFieldX[P][Length(TilesFieldX[P]) - 31] := FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].X;
        TilesFieldY[P][Length(TilesFieldY[P]) - 31] := FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Y;
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].AddTime := States.GameTime + 48 + Round(VAGA_FIELD_SPEED * (FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I));
        if I mod FIREWORKS2_RADIUS > 0 then
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Radius := FIREWORKS2_RADIUS - I mod FIREWORKS2_RADIUS
      else
        FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Radius := 0;
      end;        
      for I := 0 to FireworksCircles5Length[P][FireworksCircles5Counter[P]] - 1 do 
        if I mod FIREWORKS2_RADIUS = 1 then
          FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - I].Obj := 255;

      if States.PlayerIsAI(P) then
      begin
        Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
        Players[P].SkillCastX := X2;
        Players[P].SkillCastY := Y2;
        Actions.GroupKillAll(Players[P].Hero, True);
      end;

      Players[P].LastUsedSkill := sDeadlyFireworks;

      Players[P].LastFieldSkill := sDeadlyFireworks;

      Players[P].FieldSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      TimeToClearFireworks1Array[P][FireworksCircles1Counter[P]] := FireworksCircles1[P][FireworksCircles1Counter[P]][FireworksCircles1Length[P][FireworksCircles1Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks2Array[P][FireworksCircles2Counter[P]] := FireworksCircles2[P][FireworksCircles2Counter[P]][FireworksCircles2Length[P][FireworksCircles2Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks3Array[P][FireworksCircles3Counter[P]] := FireworksCircles3[P][FireworksCircles3Counter[P]][FireworksCircles3Length[P][FireworksCircles3Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks4Array[P][FireworksCircles4Counter[P]] := FireworksCircles4[P][FireworksCircles4Counter[P]][FireworksCircles4Length[P][FireworksCircles4Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;
      TimeToClearFireworks5Array[P][FireworksCircles5Counter[P]] := FireworksCircles5[P][FireworksCircles5Counter[P]][FireworksCircles5Length[P][FireworksCircles5Counter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

      ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 31] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


procedure Regen(P, X, Y: Integer);
var
  I, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= REGEN_RADIUS)
    and (Abs(Y2 - Y) <= REGEN_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 20;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      TilesWineLength[P] := TilesWineLength[P] + 13;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);
    
      TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
      TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

      for I := 1 to 4 do 
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := VAGA_OBJECT5;
  
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 8;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 10;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 12;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 14;
    
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 3;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 5;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 7;
        
      TilesWineX[P][Length(TilesWineX[P]) - 5] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 5] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 6] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 6] := Y - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 7] := X;
      TilesWineY[P][Length(TilesWineY[P]) - 7] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 8] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 8] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 9] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 9] := Y;
      TilesWineX[P][Length(TilesWineX[P]) - 10] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 10] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 11] := X + 1;
      TilesWineY[P][Length(TilesWineY[P]) - 11] := Y - 1;
      TilesWineX[P][Length(TilesWineX[P]) - 12] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 12] := Y + 1;
      TilesWineX[P][Length(TilesWineX[P]) - 13] := X - 1;
      TilesWineY[P][Length(TilesWineY[P]) - 13] := Y - 1;

      Players[P].WineSkillCancelTime := States.GameTime + 14;

      for I := 5 to 13 do
      begin
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := States.GameTime + 100;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - I] := States.GameTime + 20;
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := VAGA_OBJECT;
      end;

      for I := 1 to 13 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      Players[P].LastUsedSkill := sRegen;

      Players[P].LastWineSkill := sRegen;

      Players[P].WineSkillDelay := Round(VAGA_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

      ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] + CLEAR_ARRAY_FACTOR;

    end;

  end;

end;


//AXE FIGHTER


procedure StrongWill(P, X, Y: Integer);
var
  I, X2, Y2, U, O, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero <> -1) then
  begin
    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 10;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X - X2) > STRONGWILL_RADIUS)
    or (Abs(Y - Y2) > STRONGWILL_RADIUS) then
      Exit;

    U := States.UnitAt(X, Y);
    if U <= 0 then
      Exit;

    if U > 0 then
      O := States.UnitOwner(U);

    if Players[P].PlayersTeam <> Players[O].PlayersTeam then
      Exit;

    if not InRange(O, 0, 7) then
      Exit;

    if (O = P)
    or (Players[P].PlayersTeam = Players[O].PlayersTeam) then
    begin
      TilesRoadLength[P] := TilesRoadLength[P] + 9;
      SetLength(TilesRoadX[P], TilesRoadLength[P]);
      SetLength(TilesRoadY[P], TilesRoadLength[P]);
      SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
      SetLength(TilesRoadObjects[P], TilesRoadLength[P]);

      TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X;
      TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y;
      TilesRoadX[P][Length(TilesRoadX[P]) - 6] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 6] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 7] := X + 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 7] := Y - 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 8] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 8] := Y + 1;
      TilesRoadX[P][Length(TilesRoadX[P]) - 9] := X - 1;
      TilesRoadY[P][Length(TilesRoadY[P]) - 9] := Y - 1;

      Players[P].RoadSkillCancelTime := States.GameTime + 1;

      for I := 1 to 9 do
        if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        begin
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := AXE_OBJECT5;    
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := States.GameTime + 1 + AXE_SHIELD_TIME;
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := States.GameTime + 1;
          Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Owner := P;
          Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].Skill := sStrongWill;
          if Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ShieldTime < States.GameTime + 2 + AXE_SHIELD_TIME then
            Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ShieldTime := States.GameTime + 2 + AXE_SHIELD_TIME;

          if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
          or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
          or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5) then
            ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
        end;

      if (P <> O) then
      begin
        D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, X + States.KaMRandomI(2) - States.KaMRandomI(2), Y + States.KaMRandomI(2) - States.KaMRandomI(2), D, 1, 1);
        Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      end;

      Players[P].LastUsedSkill := sStrongWill;

      Players[P].LastRoadSkill := sStrongWill;

      Players[P].RoadSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    end;

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 9] + CLEAR_ARRAY_FACTOR + 3;

    Players[P].ShieldStartTime := States.GameTime + 1;
    Players[P].ShieldEndTime := States.GameTime + 1 + AXE_SHIELD_TIME;

  end;

end;


procedure SweepingBlow(P, X, Y, Dir: Integer);
var
  X1, Y1, X2, Y2, Desync, Direction, I, Temp, Pos: Integer;
  Place: Boolean;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 14;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesFieldLength[P] := TilesFieldLength[P] + 4;
    SetLength(TilesFieldX[P], TilesFieldLength[P]);
    SetLength(TilesFieldY[P], TilesFieldLength[P]);
    SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
    SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
    SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
    
    TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2 + 1;
    TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2 - 1;
    TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
    TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
    TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
    TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
    TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2 + 1;
    TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2 - 1;
    
    ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[4]] := States.GameTime + 9;
    ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[3]] := States.GameTime + 10;
    ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[2]] := States.GameTime + 11;
    ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - Points[1]] := States.GameTime + 12;
    
    SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[4]] := States.GameTime + 1;
    SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[3]] := States.GameTime + 3;
    SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[2]] := States.GameTime + 5;
    SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - Points[1]] := States.GameTime + 7;

    Players[P].FieldSkillCancelTime := States.GameTime + 12;

    for I := 1 to 4 do
      if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
      begin   
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := AXE_OBJECT3;
        Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - I]][TilesFieldY[P][Length(TilesFieldY[P]) - I]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1];
        if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;
      end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 6 do
           for X1 := X2 - 4 to X2 + 4 do
             begin
               Place := (InRange(X1, X2 - 4, X2 + 4) and (Y1 = Y2 - 6))
                        or (InRange(X1, X2 - 3, X2 + 3) and (Y1 = Y2 - 5))
                        or (InRange(X1, X2 - 2, X2 + 2) and (Y1 = Y2 - 4))
                        or (InRange(X1, X2 - 1, X2 + 1) and (Y1 = Y2 - 3))
                        or ((X1 = X2) and (Y1 = Y2 - 2));
               if (TileOnBattlefield(X1, Y1))
               and (Place) then
               begin
                 Desync := Desync + 1;
                 TilesFieldLength[P] := TilesFieldLength[P] + 1;
                 SetLength(TilesFieldX[P], TilesFieldLength[P]);
                 SetLength(TilesFieldY[P], TilesFieldLength[P]);
                 SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
                 TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X1;
                 TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y1;
                 ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := AXE_OBJECT6;
                 Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - 1]][TilesFieldY[P][Length(TilesFieldY[P]) - 1]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1];
               end;
             end;

      2,3: for X1 := X2 + 2 to X2 + 6 do
           for Y1 := Y2 - 5 to Y2 + 5 do
             begin
               Place := (InRange(Y1, Y2 - 4, Y2 + 4) and (X1 = X2 + 6))
                        or (InRange(Y1, Y2 - 3, Y2 + 3) and (X1 = X2 + 5))
                        or (InRange(Y1, Y2 - 2, Y2 + 2) and (X1 = X2 + 4))
                        or (InRange(Y1, Y2 - 1, Y2 + 1) and (X1 = X2 + 3))
                        or ((Y1 = Y2) and (X1 = X2 + 2));
               if (TileOnBattlefield(X1, Y1))
               and (Place) then
               begin
                 Desync := Desync + 1;
                 TilesFieldLength[P] := TilesFieldLength[P] + 1;
                 SetLength(TilesFieldX[P], TilesFieldLength[P]);
                 SetLength(TilesFieldY[P], TilesFieldLength[P]);
                 SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
                 TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X1;
                 TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y1;
                 ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := AXE_OBJECT6;
                 Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - 1]][TilesFieldY[P][Length(TilesFieldY[P]) - 1]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1];
               end;
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 6 do
           for X1 := X2 - 5 to X2 + 5 do
             begin
               Place := (InRange(X1, X2 - 4, X2 + 4) and (Y1 = Y2 + 6))
                        or (InRange(X1, X2 - 3, X2 + 3) and (Y1 = Y2 + 5))
                        or (InRange(X1, X2 - 2, X2 + 2) and (Y1 = Y2 + 4))
                        or (InRange(X1, X2 - 1, X2 + 1) and (Y1 = Y2 + 3))
                        or ((X1 = X2) and (Y1 = Y2 + 2));
               if (TileOnBattlefield(X1, Y1))
               and (Place) then
               begin
                 Desync := Desync + 1;
                 TilesFieldLength[P] := TilesFieldLength[P] + 1;
                 SetLength(TilesFieldX[P], TilesFieldLength[P]);
                 SetLength(TilesFieldY[P], TilesFieldLength[P]);
                 SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
                 TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X1;
                 TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y1;
                 ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := AXE_OBJECT6;
                 Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - 1]][TilesFieldY[P][Length(TilesFieldY[P]) - 1]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1];
               end;
             end;

      6,7: for X1 := X2 - 2 downto X2 - 6 do
           for Y1 := Y2 - 5 to Y2 + 5 do
             begin
               Place := (InRange(Y1, Y2 - 4, Y2 + 4) and (X1 = X2 - 6))
                        or (InRange(Y1, Y2 - 3, Y2 + 3) and (X1 = X2 - 5))
                        or (InRange(Y1, Y2 - 2, Y2 + 2) and (X1 = X2 - 4))
                        or (InRange(Y1, Y2 - 1, Y2 + 1) and (X1 = X2 - 3))
                        or ((Y1 = Y2) and (X1 = X2 - 2));
               if (TileOnBattlefield(X1, Y1))
               and (Place) then
               begin
                 Desync := Desync + 1;
                 TilesFieldLength[P] := TilesFieldLength[P] + 1;
                 SetLength(TilesFieldX[P], TilesFieldLength[P]);
                 SetLength(TilesFieldY[P], TilesFieldLength[P]);
                 SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
                 SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
                 TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X1;
                 TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y1;
                 ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 13 + Round(DESYNC_FACTOR * Desync/AXE_FIELD_SPEED);
                 TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := AXE_OBJECT6;
                 Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - 1]][TilesFieldY[P][Length(TilesFieldY[P]) - 1]].ObjectRefreshTime := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1];
               end;
             end;
        end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sSweepingBlow;

    Players[P].LastFieldSkill := sSweepingBlow;

    Players[P].FieldSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Werewolf(P, X, Y: Integer);
var
  X2, Y2, NewDir: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    NewDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    Players[P].WineSkillDelay := 0;
    Players[P].RoadSkillDelay := 0;
    Players[P].FieldSkillDelay := 0;
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    Players[P].VagaX := X2;
    Players[P].VagaY := Y2;
    Players[P].VagaDir := NewDir;
    Players[P].VagaAppearTime := States.GameTime + VAGA_DELAY_OF_TURNING;
    Players[P].TempHeroType := Players[P].HeroType;
    Players[P].HeroType := 27;
    Players[P].LastUsedSkill := sWerewolf;
  end;

end;


//BOWMAN


procedure LaunchRocket(P, X, Y: Integer);
var
  I, X1, Y1, aX, aY, Desync, DX, DY, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].RocketCharges <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    Desync := 0;

    X1 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y1 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    if (Abs(X - X1) > ROCKET_USAGE_RADIUS)
    or (Abs(Y - Y1) > ROCKET_USAGE_RADIUS) then
      Exit;

    DX := X - X1;
    if DX < 0 then
      DX := -1 * DX;

    DY := Y - Y1;
    if DY < 0 then
      DY := -1 * DY;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X1 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X1 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X1 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y1 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y1 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y1 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1 - 1;

    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BOWMAN_OBJECT;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 8;

    for I := 1 to 4 do
    begin
      if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
      begin
         SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - I] := 0;
         ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
         TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := BOWMAN_OBJECT5;
      end;
    end;

    if (X = X1)
    and (Y < Y1) then
    begin
      for aY := Y1 - 1 downto Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (X = X1)
    and (Y > Y1) then
    begin
      for aY := Y1 + 1 to Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (Y = Y1)
    and (X < X1) then
    begin
      for aX := X1 - 1 downto X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (Y = Y1)
    and (X > X1) then
    begin
      for aX := X1 + 1 to X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
    end;

    if (X > X1)
    and (Y > Y1)
    and (DX < DY) then
    begin
      for aX := X1 + 2 to X1 + DX do
      for aY := Y1 + 2 to Y1 + DX do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 + DX to Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
      
    end;

    if (X > X1)
    and (Y > Y1)
    and (DX >= DY) then
    begin
      for aX := X1 + 2 to X1 + DY do
      for aY := Y1 + 2 to Y1 + DY do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 + DY to X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;
      
    end;

    if (X > X1)
    and (Y < Y1)
    and (DX < DY) then
    begin
      for aX := X1 + 2 to X1 + DX do
      for aY := Y1 - 2 downto Y1 - DX do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 - DX downto Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X > X1)
    and (Y < Y1)
    and (DX >= DY) then
    begin
      for aX := X1 + 2 to X1 + DY do
      for aY := Y1 - 2 downto Y1 - DY do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 + DY to X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y < Y1)
    and (DX < DY) then
    begin
      for aX := X1 - 2 downto X1 - DX do
      for aY := Y1 - 2 downto Y1 - DX do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 - DX downto Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y < Y1)
    and (DX >= DY) then
    begin
      for aX := X1 - 2 downto X1 - DY do
      for aY := Y1 - 2 downto Y1 - DY do
        if (aY = Y1 + (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 - DY downto X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y > Y1)
    and (DX < DY) then
    begin
      for aX := X1 - 2 downto X1 - DX do
      for aY := Y1 + 2 to Y1 + DX do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aY := Y1 + DX to Y do
        if TileOnBattlefield(X, aY) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    if (X < X1)
    and (Y > Y1)
    and (DX >= DY) then
    begin
      for aX := X1 - 2 downto X1 - DY do
      for aY := Y1 + 2 to Y1 + DY do
        if (aY = Y1 - (aX - X1))
        and (TileOnBattlefield(aX, aY)) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := aY;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

      for aX := X1 - DY downto X do
        if TileOnBattlefield(aX, Y) then
        begin
          Desync := Desync + 1;
          TilesRoadLength[P] := TilesRoadLength[P] + 1;
          SetLength(TilesRoadX[P], TilesRoadLength[P]);
          SetLength(TilesRoadY[P], TilesRoadLength[P]);
          SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
          SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
          TilesRoadX[P][Length(TilesRoadX[P]) - 1] := aX;
          TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 15 + Round(DESYNC_FACTOR * Desync/BOWMAN_ROAD_SPEED);
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_OBJECT6;
        end;

    end;

    TilesRoadLength[P] := TilesRoadLength[P] + 1;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := SetTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] + 20;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := SetTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] + 3;
    TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := BOWMAN_ROCKET;
    Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];

    Players[P].RocketTime := SetTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] + 60;
    Players[P].RocketX := X;
    Players[P].RocketY := Y;
    Players[P].RoadSkillCancelTime := States.GameTime + 15;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X1, Y1, States.KaMRandomI(8));
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Players[P].SkillCastX := X1;
      Players[P].SkillCastY := Y1;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sRocket;

    Players[P].LastRoadSkill := sRocket;

    if Players[P].RocketCharges > 0 then
    begin
      Players[P].RocketCharges := Players[P].RocketCharges - 1 * Byte(Players[P].HeroType <> 25);
      if (Players[P].RocketCharges <= BOWMAN_CHARGES - 1)
      and (Players[P].RocketChargeTime <= States.GameTime) then
        Players[P].RocketChargeTime := States.GameTime + Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
    end;

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 2 * CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Prison(P, X, Y: Integer);
var
  aX, aY, X1, Y1, X2, Y2, X3, Y3: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    X1 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y1 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if (Abs(X - X1) > PRISON_USAGE_RADIUS)
    or (Abs(Y - Y1) > PRISON_USAGE_RADIUS) then
      Exit;

    X2 := X - PRISON_RADIUS;
    X3 := X + PRISON_RADIUS;
    Y2 := Y - PRISON_RADIUS;
    Y3 := Y + PRISON_RADIUS;

    for aX := X2 to X3 do
    for aY := Y2 to Y3 do
    begin
      if (TileOnBattlefield(aX, aY))      
      and (((X - aX) * (X - aX) + (Y - aY) * (Y - aY)) <= PRISON_RADIUS * PRISON_RADIUS)
      and (((X - aX) * (X - aX) + (Y - aY) * (Y - aY)) > (PRISON_RADIUS - 2) * (PRISON_RADIUS - 2)) then
      begin
        if Tiles[aX][aY].ShieldTime < States.GameTime + PRISON_TIME + 1 then
          Tiles[aX][aY].PrisonTime := States.GameTime + PRISON_TIME + 1;
        TilesFieldLength[P] := TilesFieldLength[P] + 1;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := aX;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := aY;
        if (States.MapTileObject(aX, aY) <> BARB_OBJECT3)
        and (States.MapTileObject(aX, aY) <> BOWMAN_ROCKET) then
        begin
          ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + PRISON_TIME + 1;
          SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 1;
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := BOWMAN_OBJECT5;
        end;
      end;
    end;

    Players[P].LastUsedSkill := sPrison;

    Players[P].FieldSkillDelay := Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure RevengeFromNowhere(P, X, Y, Dir: Integer);
var
  I, X2, Y2, X1, Y1, Direction, Desync, CircleTime: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    ExpCirclesCounter[P] := ExpCirclesCounter[P] + 1;
    if ExpCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      ExpCirclesCounter[P] := 0;

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    ExpCirclesLength[P][ExpCirclesCounter[P]] := ExpCirclesLength[P][ExpCirclesCounter[P]] + EXP_CYCLES * EXP_RADIUS;
    SetLength(ExpCircles[P][ExpCirclesCounter[P]], ExpCirclesLength[P][ExpCirclesCounter[P]]);
    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    for I := 5 to 8 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BOWMAN_OBJECT;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 14;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 16;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 1;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 3;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 4;
    
    for I := 1 to 4 do
      TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := BOWMAN_OBJECT2;
    
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 18;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 19;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 20;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 5;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 7;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 8;

    Players[P].WineSkillCancelTime := States.GameTime + 20;

    for I := 1 to 8 do
    begin
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;
    end;

    case Direction of

      0,1: for Y1 := Y2 - 2 downto Y2 - 15 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 25 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      2,3: for X1 := X2 + 2 to X2 + 15 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 25 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      4,5: for Y1 := Y2 + 2 to Y2 + 15 do
             if TileOnBattlefield(X2, Y1) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 25 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;

      6,7: for X1 := X2 - 2 downto X2 - 15 do
             if TileOnBattlefield(X1, Y2) then
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 25 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 21 + Round(DESYNC_FACTOR * Desync/BOWMAN_WINE_SPEED);
               TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := BOWMAN_OBJECT3;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               CircleTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
             end;
    end; 

    for I := ExpCirclesLength[P][ExpCirclesCounter[P]] downto ExpCirclesLength[P][ExpCirclesCounter[P]] - EXP_CYCLES * EXP_RADIUS + 1 do
    begin
      ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Obj := BOWMAN_OBJECT4;

      case Direction of 
      
      2,3,6,7: begin
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := X1;
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := Y2;
               end;

      0,1,4,5: begin
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := X2;
                 ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := Y1;
               end;
      end;

      if States.MapTileType(ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X, ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y) = 202 then
        case Direction of
          0,1: ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y + 1;
          2,3: ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X - 1;
          4,5: ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y - 1;
          6,7: ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X + 1;
        end;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X > CurrentMaxX then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := CurrentMaxX;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y > CurrentMaxY then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := CurrentMaxY;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X < CurrentMinX then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X := CurrentMinX;

      if ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y < CurrentMinY then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y := CurrentMinY;

      TilesWineX[P][Length(TilesWineX[P]) - 1] := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].X;    
      TilesWineY[P][Length(TilesWineY[P]) - 1] := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Y;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := CircleTime;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := CircleTime + 2 * (ExpCirclesLength[P][ExpCirclesCounter[P]] - I);
      TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := CIRCLE_FILL_OBJ;

      if EXP_CYCLES = 1 then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].AddTime := CircleTime + 2 * (ExpCirclesLength[P][ExpCirclesCounter[P]] - I);

      if EXP_CYCLES = 2 then
      begin
        if I <= ExpCirclesLength[P][ExpCirclesCounter[P]] div 2 then
          ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].AddTime := CircleTime + 2 * (ExpCirclesLength[P][ExpCirclesCounter[P]] - I) - 2 - 3 * (EXP_RADIUS div 2 - 1)
        else
          ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].AddTime := CircleTime + 2 * (ExpCirclesLength[P][ExpCirclesCounter[P]] - I) + 2;
      end;

      if I mod EXP_RADIUS > 0 then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Radius := EXP_RADIUS + 1 - I mod EXP_RADIUS
      else
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Radius := 1;

    end;
        
    for I := 0 to ExpCirclesLength[P][ExpCirclesCounter[P]] - 1 do 
      if I mod EXP_RADIUS = 1 then
        ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - I].Obj := 255;

    TimeToClearExpArray[P][ExpCirclesCounter[P]] := ExpCircles[P][ExpCirclesCounter[P]][ExpCirclesLength[P][ExpCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    Players[P].LastUsedSkill := sRevengeFromNowhere;

    Players[P].LastWineSkill := sRevengeFromNowhere;

    Players[P].WineSkillDelay := Round(BOWMAN_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

  end;

end;


//WARRIOR


procedure FierySnake(P, X, Y, Dir: Integer);
var
  I, X1, Y1, X2, Y2, Desync, DX1, DX2, DX3, DY1, DY2, DY3, Direction, R, Pos, Temp, TempTime: Integer;
  Place: Boolean;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if Players[P].SnakeCharges <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;
    DX1 := 0;
    DX2 := 0;
    DX3 := 0;
    DY1 := 0;
    DY2 := 0;
    DY3 := 0;

    TempTime := Players[P].LastSnakeTime;
    Players[P].LastSnakeTime := States.GameTime;
    if States.GameTime - TempTime <= 10 then
      while R = Players[P].LastSnakeRandom do
        R := States.KaMRandomI(2);

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    if not Players[P].HeroExiled then
    begin
      X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if not States.PlayerIsAI(P) then
        Direction := Players[P].SkillDirection;
    end
    else
    begin
      X2 := Players[P].HeroExileX;
      Y2 := Players[P].HeroExileY;
      if not States.PlayerIsAI(P) then
        Direction := Players[P].HeroExileDir;
    end;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
  
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 8;

    Players[P].RoadSkillCancelTime := States.GameTime + 18;

    for I := 1 to 4 do
    begin
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - I]][TilesRoadY[P][Length(TilesRoadY[P]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := WARRIOR_OBJECT + 3 * Byte(States.KaMRandom > 0.65);
    end;

    for I := 1 to 4 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 2 downto Y2 - 13 do
             for X1 := X2 - 1 to X2 + 1 do
             begin
               Desync := Desync + 1;

               if X1 = X2 - 1 then
                 DX1 := DX1 + 1;                  

               if X1 = X2 then
                 DX2 := DX2 + 1;

               if X1 = X2 + 1 then
                 DX3 := DX3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin

                 if R = 0 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 0))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 2));

                 if R = 1 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 2))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;

      2,3: begin
             for X1 := X2 + 2 to X2 + 13 do
             for Y1 := Y2 - 1 to Y2 + 1 do
             begin
               Desync := Desync + 1;

               if Y1 = Y2 - 1 then
                 DY1 := DY1 + 1;

               if Y1 = Y2 then
                 DY2 := DY2 + 1;

               if Y1 = Y2 + 1 then
                 DY3 := DY3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin

                 if R = 0 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 0))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 2));

                 if R = 1 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 2))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;

      4,5: begin
             for Y1 := Y2 + 2 to Y2 + 13 do
             for X1 := X2 - 1 to X2 + 1 do
             begin
               Desync := Desync + 1;

               if X1 = X2 - 1 then
                 DX1 := DX1 + 1;

               if X1 = X2 then
                 DX2 := DX2 + 1;

               if X1 = X2 + 1 then
                 DX3 := DX3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin

                 if R = 0 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 0))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 2));

                 if R = 1 then
                   Place := ((X1 = X2 - 1)
                   and (DX1 mod 4 = 2))
                   or ((X1 = X2)
                   and (DX2 mod 2 = 1))
                   or ((X1 = X2 + 1)
                   and (DX3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;

      6,7:  begin
             for X1 := X2 - 2 downto X2 - 13 do
             for Y1 := Y2 - 1 to Y2 + 1 do
             begin
               Desync := Desync + 1;

               if Y1 = Y2 - 1 then
                 DY1 := DY1 + 1;

               if Y1 = Y2 then
                 DY2 := DY2 + 1;

               if Y1 = Y2 + 1 then
                 DY3 := DY3 + 1;

               if TileOnBattlefield(X1, Y1) then
               begin

                 if R = 0 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 0))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 2));

                 if R = 1 then
                   Place := ((Y1 = Y2 - 1)
                   and (DY1 mod 4 = 2))
                   or ((Y1 = Y2)
                   and (DY2 mod 2 = 1))
                   or ((Y1 = Y2 + 1)
                   and (DY3 mod 4 = 0));

                 if Place then
                 begin
                   TilesRoadLength[P] := TilesRoadLength[P] + 1;
                   SetLength(TilesRoadX[P], TilesRoadLength[P]);
                   SetLength(TilesRoadY[P], TilesRoadLength[P]);
                   SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                   SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                   TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                   TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                   ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 23 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 18 + Round(DESYNC_FACTOR * Desync/WARRIOR_ROAD_SPEED);
                   TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := WARRIOR_OBJECT3 - (States.KaMRandomI(2) + 1) * 3 * Byte(States.KaMRandomI(3) = 0);
                   Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1];
                 end;
               end;
             end;
           end;
      end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].LastUsedSkill := sFierySnake;

    Players[P].LastRoadSkill := sFierySnake;

    if Players[P].SnakeCharges > 0 then
    begin
      Players[P].SnakeCharges := Players[P].SnakeCharges - 1 * Byte(Players[P].HeroType <> 25);
      if (Players[P].SnakeCharges <= SNAKE_CHARGES - 1)
      and (Players[P].SnakeChargeTime <= States.GameTime) then
        Players[P].SnakeChargeTime := States.GameTime + Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
    end;

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Exile(P, X, Y: Integer);
var
  I, X2, Y2, O, U: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    U := States.UnitAt(X, Y);
    if U <= 0 then
      Exit;
    if U > 0 then
      O := States.UnitOwner(U);
    if O > 7 then
      Exit;
    if States.MapTileObject(X, Y) = WARRIOR_OBJECT7 then
      Exit;
    if (U > 0)
    and (U = States.GroupMember(Players[O].Hero, 0))
    and (not Players[O].HeroMagicImmunity)
    and (not Players[O].HeroTotalImmunity)
    and (not Players[O].MindStunned) //Serega is cheater!
    and (not Players[O].CaptureMind)
    and ((Abs(X2 - X) <= EXILE_RADIUS)
    and (Abs(Y2 - Y) <= EXILE_RADIUS)
    and (Players[O].TempPlayersTeam <> Players[P].TempPlayersTeam))
    or ((Abs(X2 - X) <= EXILE_ALLY_RADIUS)
    and (Abs(Y2 - Y) <= EXILE_ALLY_RADIUS)
    and (not Players[O].HeroMagicImmunity)
    and (not Players[O].HeroTotalImmunity)
    and (not Players[O].MindStunned) //Serega is cheater!
    and (not Players[O].CaptureMind)
    and (Players[O].TempPlayersTeam = Players[P].TempPlayersTeam)) then
    begin
      TilesFieldLength[P] := TilesFieldLength[P] + 4;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
      TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
      TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
      TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
      TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
      TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

      for I := 1 to 4 do
        TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := WARRIOR_OBJECT4;
    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 2;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 3;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 4;
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 5;
    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

      for I := 1 to 4 do
        if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
          if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
          or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
          or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
          or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = WARRIOR_OBJECT7) then
            ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

      Players[O].HeroExiled := True;
      Players[O].HeroExileTime := States.GameTime + EXILE_DELAY;
      Players[P].LastUsedSkill := sExile;
      Players[O].HeroExileGiver := P;
      Players[P].FieldSkillDelay := Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

    end;
  end;
end;


procedure Shield(P, X, Y: Integer);
var
  I, J, K, X2, Y2, aX, aY, C, Temp, Temp2: Integer;
  Points, Points2: array[1..8] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    if not Players[P].HeroExiled then
    begin
      X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    end
    else
    begin
      X2 := Players[P].HeroExileX;
      Y2 := Players[P].HeroExileY;
    end;
    if (Abs(X2 - X) <= SHIELD_RADIUS)
    and (Abs(Y2 - Y) <= SHIELD_RADIUS) then
    begin

      if States.PlayerIsAI(P) then
      begin
        Players[P].CastingSkill := True;
        Players[P].SkillTime := States.GameTime + 20;
        Actions.GroupOrderHalt(Players[P].Hero);
      end;

      for I := 1 to 8 do
      begin
        Points[I] := I;
        Points2[I] := I;
      end;

      if RANDOM_ANIMATIONS then
      begin
        if States.KaMRandom < 0.5 then
          for I := 1 to 8 div 2 do
          begin
            Temp2 := Points2[I];
            Points2[I] := Points2[8 - I + 1];
            Points2[8 - I + 1] := Temp2;
          end;
        for J := 1 to States.KaMRandomI(8) do
        begin
          Temp := Points[1];
          for K := 1 to 7 do
            Points[K] := Points[K + 1];
          Points[8] := Temp;
        end;
      end;

      TilesWineLength[P] := TilesWineLength[P] + 33;
      SetLength(TilesWineX[P], TilesWineLength[P]);
      SetLength(TilesWineY[P], TilesWineLength[P]);
      SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
      SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
      SetLength(TilesWineObjects[P], TilesWineLength[P]);
    
      TilesWineX[P][Length(TilesWineX[P]) - Points2[8]] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[7]] := X2;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[6]] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[5]] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[4]] := X2 + 1;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[3]] := X2;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[2]] := X2 - 1;
      TilesWineX[P][Length(TilesWineX[P]) - Points2[1]] := X2 - 1; 
    
      TilesWineY[P][Length(TilesWineY[P]) - Points2[8]] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - Points2[7]] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - Points2[6]] := Y2 - 1;
      TilesWineY[P][Length(TilesWineY[P]) - Points2[5]] := Y2;    
      TilesWineY[P][Length(TilesWineY[P]) - Points2[4]] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - Points2[3]] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - Points2[2]] := Y2 + 1;
      TilesWineY[P][Length(TilesWineY[P]) - Points2[1]] := Y2;

      for I := 1 to 8 do
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := IfThen(States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - Points2[I]], TilesWineY[P][Length(TilesWineY[P]) - Points2[I]]) = WARRIOR_OBJECT7, SKILL_CANCEL_OBJ, WARRIOR_OBJECT6);

      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[8]] := States.GameTime + 13;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[7]] := States.GameTime + 14;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[6]] := States.GameTime + 15;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[5]] := States.GameTime + 16;

      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[8]] := States.GameTime + 1;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[7]] := States.GameTime + 2;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[6]] := States.GameTime + 3;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[5]] := States.GameTime + 4;
      
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[4]] := States.GameTime + 17;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[3]] := States.GameTime + 18;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[2]] := States.GameTime + 19;
      ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - Points[1]] := States.GameTime + 20;
    
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[4]] := States.GameTime + 5;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[3]] := States.GameTime + 6;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[2]] := States.GameTime + 7;
      SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - Points[1]] := States.GameTime + 8;

      Players[P].WineSkillCancelTime := States.GameTime + 20;

      for aX := X - SHIELD_AREA_RADIUS + 1 to X + SHIELD_AREA_RADIUS - 1 do
      for aY := Y - SHIELD_AREA_RADIUS + 1 to Y + SHIELD_AREA_RADIUS - 1 do
      begin
        C := C + 1;
        TilesWineX[P][Length(TilesWineX[P]) - (C + 8)] := aX;
        TilesWineY[P][Length(TilesWineY[P]) - (C + 8)] := aY;
      end;

      for I := 9 to 33 do
      begin
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := States.GameTime + 22 + SHIELD_TIME;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - I] := States.GameTime + 22;
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := WARRIOR_OBJECT7;
        if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
        begin
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Owner := P;
          Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].Skill := sShield;
          if Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ShieldTime < States.GameTime + 22 + SHIELD_TIME then
            Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ShieldTime := States.GameTime + 22 + SHIELD_TIME;
        end;
      end;

      for I := 1 to 33 do
        if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5) then
          ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

      Players[P].LastUsedSkill := sShield;

      Players[P].LastWineSkill := sShield;

      Players[P].WineSkillDelay := Round(WARRIOR_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] + CLEAR_ARRAY_FACTOR;

      Players[P].ShieldStartTime := States.GameTime + 22;
      Players[P].ShieldEndTime := States.GameTime + 22 + SHIELD_TIME;

    end;
  end;
end;


//KNIGHT


procedure ThreadsOfDeath(P, X, Y: Integer);
var
  I, X2, Y2, U, O, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    U := States.UnitAt(X, Y);
    if U > 0 then
      O := States.UnitOwner(U);
    if ((Abs(X2 - X) <= THREADS_RADIUS)
    and (Abs(Y2 - Y) <= THREADS_RADIUS)
    and (Players[O].TempPlayersTeam <> Players[P].TempPlayersTeam))
    or ((Abs(X2 - X) <= THREADS_ALLY_RADIUS)
    and (Abs(Y2 - Y) <= THREADS_ALLY_RADIUS)
    and (Players[O].TempPlayersTeam = Players[P].TempPlayersTeam)) then
    begin
      if U <= 0 then
        Exit;
      if ((InRange(O, 0, 7))
      and (O <> P)
      and (not Players[O].HeroMagicImmunity)
      and (not Players[O].HeroTotalImmunity)
      and (U = States.GroupMember(Players[O].Hero, 0)))
      or ((InRange(O, 8, 11))
      and (InRange(States.UnitType(U), 14, 27)))
      and (States.MapTileObject(X2, Y2) <> WARRIOR_OBJECT7) then
      begin
        TilesRoadLength[P] := TilesRoadLength[P] + 4;
        SetLength(TilesRoadX[P], TilesRoadLength[P]);
        SetLength(TilesRoadY[P], TilesRoadLength[P]);
        SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
  
        TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2;
        TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2;
        TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
        TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
        TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2;
        TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := KNIGHT_OBJECT;
    
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 4] := States.GameTime + 10;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 3] := States.GameTime + 11;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 2] := States.GameTime + 12;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 13;
    
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 4] := States.GameTime + 1;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 3] := States.GameTime + 2;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 2] := States.GameTime + 3;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattleField(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
          begin
            if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
            or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
            or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
            or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
              ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;
            if (ObjectType(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I])) = otKill)
            or (ObjectType(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I])) = otStun)
            or (ObjectType(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I])) = otRegen)
            or (ObjectType(States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I])) = otSave) then
            begin
              SetTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := 0;
              ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := 0;
            end;
          end;

        Players[P].ThreadsAttackTime := States.GameTime + THREADS_DELAY;

        if InRange(O, 0, 7) then
        begin
          Players[O].ThreadsStartTime := States.GameTime;
          Players[O].ThreadsTime := States.GameTime + THREADS_DELAY;
          Players[O].ThreadsAttacker := P;
          Players[P].ThreadsTarget := O;
          Players[O].MovedByThreads := True;
          Players[O].ThreadsUnitDir := States.UnitDirection(States.GroupMember(Players[O].Hero, 0));

          case D of

            0: begin
                 Players[O].ThreadsDX := 0;
                 Players[O].ThreadsDY := -1;
               end;

            1: begin
                 Players[O].ThreadsDX := 1;
                 Players[O].ThreadsDY := -1;
               end;

            2: begin
                 Players[O].ThreadsDX := 1;
                 Players[O].ThreadsDY := 0;
               end;

            3: begin
                 Players[O].ThreadsDX := 1;
                 Players[O].ThreadsDY := 1;
               end;

            4: begin
                 Players[O].ThreadsDX := 0;
                 Players[O].ThreadsDY := 1;
               end;

            5: begin
                 Players[O].ThreadsDX := -1;
                 Players[O].ThreadsDY := 1;
               end;

            6: begin
                 Players[O].ThreadsDX := -1;
                 Players[O].ThreadsDY := 0;
               end;

            7: begin
                 Players[O].ThreadsDX := -1;
                 Players[O].ThreadsDY := -1;
               end;
          end;

        end;

        if InRange(O, 8, 11) then
          if Length(Zombies) > 0 then
            for I := 0 to Length(Zombies) - 1 do
              if not States.UnitDead(Zombies[I].ZombieID) then
                if U = Zombies[I].ZombieID then
                  Zombies[I].ZombieThreadsTime := Players[P].ThreadsAttackTime;

        Players[P].LastUsedSkill := sThreadsOfDeath;
        Players[P].RoadSkillDelay := Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

      end;
    end;
  end;
end;


procedure DeafeningClatter(P, X, Y: Integer);
var
  I, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
      Actions.GroupOrderHalt(Players[P].Hero);

    KnightCirclesCounter[P] := KnightCirclesCounter[P] + 1;
    if KnightCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
      KnightCirclesCounter[P] := 0;

    KnightCirclesLength[P][KnightCirclesCounter[P]] := KnightCirclesLength[P][KnightCirclesCounter[P]] + DEAFENING_CYCLES * DEAFENING_RADIUS;
    SetLength(KnightCircles[P][KnightCirclesCounter[P]], KnightCirclesLength[P][KnightCirclesCounter[P]]);
    for I := KnightCirclesLength[P][KnightCirclesCounter[P]] downto KnightCirclesLength[P][KnightCirclesCounter[P]] - DEAFENING_CYCLES * DEAFENING_RADIUS + 1 do
    begin
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Obj := KNIGHT_OBJECT3;
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].X := X2;
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Y := Y2;
      KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].AddTime := States.GameTime + Round(KNIGHT_FIELD_SPEED * (KnightCirclesLength[P][KnightCirclesCounter[P]] - I));
      if I mod DEAFENING_RADIUS > 0 then
        KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Radius := DEAFENING_RADIUS + 2 - I mod DEAFENING_RADIUS
      else
        KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Radius := 1;
    end;        
    for I := 0 to KnightCirclesLength[P][KnightCirclesCounter[P]] - 1 do 
      if I mod DEAFENING_RADIUS = 1 then
        KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - I].Obj := 255;

    Players[P].LastUsedSkill := sDeafeningClatter;

    Players[P].FieldSkillDelay := Round(KNIGHT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    TimeToClearKnightArray[P][KnightCirclesCounter[P]] := KnightCircles[P][KnightCirclesCounter[P]][KnightCirclesLength[P][KnightCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure RagingSpurt(P, X, Y: Integer);
var
  I, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not States.PlayerIsAI(P) then
    begin
      Players[P].KnightX := X2;
      Players[P].KnightY := Y2;
      Players[P].KnightAppearTime := States.GameTime + DELAY_OF_TURNING;
      Players[P].KnightDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    end;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 50;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    Players[P].HeroStunnedTime := States.GameTime + SPURT_TIME + 5;
    Actions.GroupOrderHalt(Players[P].Hero);
    Actions.GroupBlockOrders(Players[P].Hero, True);
    Players[P].HeroStunned := True;
    Players[P].SpurtStartTime := States.GameTime + 27;
    Players[P].SpurtEndTime := Players[P].SpurtStartTime + 2 + Round(DESYNC_FACTOR * SPURT_LENGTH/KNIGHT_WINE_SPEED);
    Players[P].Preparing := True;
    Players[P].PreparingTime := States.GameTime + SPURT_TIME + 5;
    Players[P].WineSkillCancelTime := States.GameTime + 26;

    TilesWineLength[P] := TilesWineLength[P] + 8;
    SetLength(TilesWineX[P], TilesWineLength[P]);
    SetLength(TilesWineY[P], TilesWineLength[P]);
    SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
    SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
    SetLength(TilesWineObjects[P], TilesWineLength[P]);

    TilesWineX[P][Length(TilesWineX[P]) - 8] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1; 
    
    TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2;
    TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2;
    TilesWineX[P][Length(TilesWineX[P]) - 6] := X2;
    TilesWineX[P][Length(TilesWineX[P]) - 5] := X2; 
    
    TilesWineX[P][Length(TilesWineX[P]) - 4] := X2 + 1;
    TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
    TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 + 1;
    
    TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 - 1;
    TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2 + 1;
    TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 13;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 15;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 17;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 19;

    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 2;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 4;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 6;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 8;    
  
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 21;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 23;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 25;
    ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 27;
    
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 10;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 12;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 14;
    SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 16;

    for I := 1 to 8 do
      if TileOnBattlefield(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) then
      begin
        TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := KNIGHT_OBJECT2;
        Tiles[TilesWineX[P][Length(TilesWineX[P]) - I]][TilesWineY[P][Length(TilesWineY[P]) - I]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
      end;

    for I := 1 to 8 do
      if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
      or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME;

    Players[P].LastUsedSkill := sRagingSpurt;

    if not States.PlayerIsAI(P) then
    begin
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

    Players[P].WineSkillDelay := Round(KNIGHT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + 2 * CLEAR_ARRAY_FACTOR;

  end;

end;


procedure StartSpurt(P: Integer);
var
  Desync, Direction, X1, Y1, X2, Y2: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if Players[P].Hero > 0 then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    Direction := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if InRange(States.GameTime, Players[P].ThreadsStartTime, Players[P].ThreadsTime) then
    begin
      Players[P].ThreadsX := States.UnitPositionX(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) * Byte(States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) >= CurrentMinY) + Players[Players[P].ThreadsAttacker].LastX * Byte(States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) < CurrentMinY);
      Players[P].ThreadsY := States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) * Byte(States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) >= CurrentMinY) + Players[Players[P].ThreadsAttacker].LastY * Byte(States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) < CurrentMinY);
      X2 := Players[P].ThreadsX + Players[P].ThreadsDX;
      Y2 := Players[P].ThreadsY + Players[P].ThreadsDY;
      Direction := Players[P].ThreadsUnitDir;
      Players[P].ThreadsTime := 0;
    end;
    Desync := 0;
    Players[P].CurrentSpurtLength := 0;

    case Direction of

      0,1: begin
             for Y1 := Y2 - 1 downto Y2 - SPURT_LENGTH do
               if TileOnBattlefield(X2, Y1) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for Y1 := Y2 - 1 downto Y2 - Players[P].CurrentSpurtLength do
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               if (Players[P].HeroType = 25)
               and (Players[P].SettingTrack) then
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := VAGA_OBJECT8;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 3 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := Players[P].TrackStopTime + 3;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1 + 1;
               end
               else
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               end;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X2;
               SpurtY[P][Desync - 1] := Y1;
               SpurtDir[P][Desync - 1] := 0;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

      2,3: begin
             for X1 := X2 + 1 to X2 + SPURT_LENGTH do
               if TileOnBattlefield(X1, Y2) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for X1 := X2 + 1 to X2 + Players[P].CurrentSpurtLength do
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               if (Players[P].HeroType = 25)
               and (Players[P].SettingTrack) then
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := VAGA_OBJECT8;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 3 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := Players[P].TrackStopTime + 3;
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1 - 1;
               end
               else
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               end;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X1;
               SpurtY[P][Desync - 1] := Y2;
               SpurtDir[P][Desync - 1] := 2;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

      4,5: begin
             for Y1 := Y2 + 1 to Y2 + SPURT_LENGTH do
               if TileOnBattlefield(X2, Y1) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for Y1 := Y2 + 1 to Y2 + Players[P].CurrentSpurtLength do
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineX[P][Length(TilesWineX[P]) - 1] := X2;
               if (Players[P].HeroType = 25)
               and (Players[P].SettingTrack) then
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := VAGA_OBJECT8;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 3 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := Players[P].TrackStopTime + 3;
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1 - 1;
               end
               else
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 TilesWineY[P][Length(TilesWineY[P]) - 1] := Y1;
               end;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X2;
               SpurtY[P][Desync - 1] := Y1;
               SpurtDir[P][Desync - 1] := 4;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

      6,7: begin
             for X1 := X2 - 1 downto X2 - SPURT_LENGTH do
               if TileOnBattlefield(X1, Y2) then
                 Players[P].CurrentSpurtLength := Players[P].CurrentSpurtLength + 1;

             for X1 := X2 - 1 downto X2 - Players[P].CurrentSpurtLength do 
             begin
               Desync := Desync + 1;
               TilesWineLength[P] := TilesWineLength[P] + 1;
               SetLength(TilesWineX[P], TilesWineLength[P]);
               SetLength(TilesWineY[P], TilesWineLength[P]);
               SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
               SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
               SetLength(TilesWineObjects[P], TilesWineLength[P]);
               TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2;
               if (Players[P].HeroType = 25)
               and (Players[P].SettingTrack) then
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := VAGA_OBJECT8;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 3 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := Players[P].TrackStopTime + 3;
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1 + 1;
               end
               else
               begin
                 TilesWineObjects[P][Length(TilesWineObjects[P]) - 1] := KNIGHT_OBJECT4;
                 SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 1 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
                 TilesWineX[P][Length(TilesWineX[P]) - 1] := X1;
               end;
               SpurtTimes[P][Desync - 1] := States.GameTime + 2 + Round(DESYNC_FACTOR * Desync/KNIGHT_WINE_SPEED);
               SpurtX[P][Desync - 1] := X1;
               SpurtY[P][Desync - 1] := Y2;
               SpurtDir[P][Desync - 1] := 6;
               Tiles[TilesWineX[P][Length(TilesWineX[P]) - 1]][TilesWineY[P][Length(TilesWineY[P]) - 1]].ObjectRefreshTime := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1];
               if (TileOnRuneSpawn(SpurtX[P][Desync - 1], SpurtY[P][Desync - 1]))
               and (not RuneTaken)
               and (RuneObject = RUNE_DOUBLE_OBJ) then
                 GetRuneEffect(P, RuneObject);
             end;

           end;

        end;

    Players[P].LastUsedSkill := sRagingSpurt;

    Players[P].LastWineSkill := sRagingSpurt;

    ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] + 2 * CLEAR_ARRAY_FACTOR;

  end;

end;


procedure CheckSpurt(P, Step: Integer);
var
  U: Integer;
begin
  U := States.UnitAt(SpurtX[P][Step], SpurtY[P][Step]);
  if (U > 0)
  and (not TileOnRuneSpawn(SpurtX[P][Step], SpurtY[P][Step])) then
  begin
    SpurtX[P][Step] := Players[P].TempX;
    SpurtY[P][Step] := Players[P].TempY;
  end;

  if (States.GameTime = SpurtTimes[P][Step] + 1)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0)
  and (TileOnBattlefield(SpurtX[P][Step], SpurtY[P][Step])) then
  begin
    Actions.GroupKillAll(Players[P].Hero, not DEATH_ANIMATION);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, SpurtX[P][Step], SpurtY[P][Step], SpurtDir[P][Step], 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    if (TileOnRuneSpawn(SpurtX[P][Step], SpurtY[P][Step]))
    and (not RuneTaken)
    and (RuneObject <> RUNE_DOUBLE_OBJ) then
      GetRuneEffect(P, RuneObject);
  end;

  if (States.GameTime = SpurtTimes[P][Players[P].CurrentSpurtLength - 1] + 2)
  and ((States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)) <> SpurtX[P][Players[P].CurrentSpurtLength - 1])
  or (States.UnitPositionY(States.GroupMember(Players[P].Hero, 0)) <> SpurtY[P][Players[P].CurrentSpurtLength - 1]))
  and (TileOnBattlefield(SpurtX[P][Players[P].CurrentSpurtLength - 1], SpurtY[P][Players[P].CurrentSpurtLength - 1]))
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0) then
  begin
    Actions.GroupKillAll(Players[P].Hero, not DEATH_ANIMATION);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, SpurtX[P][Players[P].CurrentSpurtLength - 1], SpurtY[P][Players[P].CurrentSpurtLength - 1], SpurtDir[P][Players[P].CurrentSpurtLength - 1], 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
  end;

end;


//SCOUT


procedure Boomerang(P, X, Y, D: Integer);
var
  I, X1, Y1, X2, Y2, DX1, DY1, DX2, DY2, Desync, Direction, Pos, Temp: Integer;
  Wall: Boolean;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin

    Desync := 0;

    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 18;
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    TilesRoadLength[P] := TilesRoadLength[P] + 4;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
    
    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;

    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 7;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 8;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 9;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 10;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 1;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 3;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 4;

    Players[P].RoadSkillCancelTime := States.GameTime + 10;

    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := SCOUT_OBJECT5;

    if not States.PlayerIsAI(P) then
      Direction := Players[P].SkillDirection;

    case States.KaMRandomI(100) of

      0..49:  begin
                DX1 := X2 - 1;
                DY1 := Y2 - 1;
                DX2 := X2 + 1;
                DY2 := Y2 + 1;
              end;

      50..99: begin
                DX1 := X2 + 1;
                DY1 := Y2 + 1;
                DX2 := X2 - 1;
                DY2 := Y2 - 1;
              end;

    end;

    case Direction of

      0,1: begin

             for Y1 := Y2 - 2 downto Y2 - BOOMERANG_LENGTH do
             begin
               Desync := Desync + 1;
               if not Wall then
                 Wall := (States.MapTileType(DX1, Y1) = 206)
                 or (States.MapTileType(DX1, Y1) = 245);
               if TileOnBattlefield(DX1, Y1) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2, Y2 - BOOMERANG_LENGTH - 1))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - BOOMERANG_LENGTH - 1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             if not Wall then
               Wall := (States.MapTileType(X2, Y2 - BOOMERANG_LENGTH - 1) = 206)
               or (States.MapTileType(X2, Y2 - BOOMERANG_LENGTH - 1) = 245);

             for Y1 := Y2 - BOOMERANG_LENGTH to Y2 - 2 do
             begin
               Desync := Desync + 1;
               if (TileOnBattlefield(DX2, Y1))
               and (not Wall) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX2;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2, Y2 - 1))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

      2,3: begin

             for X1 := X2 + 2 to X2 + BOOMERANG_LENGTH do
             begin
               Desync := Desync + 1;
               if not Wall then
                 Wall := (States.MapTileType(X1, DY1) = 206)
                 or (States.MapTileType(X1, DY1) = 245);
               if TileOnBattlefield(X1, DY1) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2 + BOOMERANG_LENGTH + 1, Y2))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + BOOMERANG_LENGTH + 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             if not Wall then
               Wall := (States.MapTileType(X2 + BOOMERANG_LENGTH + 1, Y2) = 206)
               or (States.MapTileType(X2 + BOOMERANG_LENGTH + 1, Y2) = 245);

             for X1 := X2 + BOOMERANG_LENGTH downto X2 + 2 do
             begin
               Desync := Desync + 1;
               if (TileOnBattlefield(X1, DY2))
               and (not Wall) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY2;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2 + 1, Y2))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

      4,5: begin

             for Y1 := Y2 + 2 to Y2 + BOOMERANG_LENGTH do
             begin
               Desync := Desync + 1;
               if not Wall then
                 Wall := (States.MapTileType(DX1, Y1) = 206)
                 or (States.MapTileType(DX1, Y1) = 245);
               if TileOnBattlefield(DX1, Y1) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2, Y2 + BOOMERANG_LENGTH + 1))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 + BOOMERANG_LENGTH + 1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             if not Wall then
               Wall := (States.MapTileType(X2, Y2 + BOOMERANG_LENGTH + 1) = 206)
               or (States.MapTileType(X2, Y2 + BOOMERANG_LENGTH + 1) = 245);

             for Y1 := Y2 + BOOMERANG_LENGTH downto Y2 + 2 do
             begin
               Desync := Desync + 1;
               if (TileOnBattlefield(DX2, Y1))
               and (not Wall) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := DX2;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2, Y2 + 1))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 + 1;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

      6,7: begin

             for X1 := X2 - 2 downto X2 - BOOMERANG_LENGTH do
             begin
               Desync := Desync + 1;
               if not Wall then
                 Wall := (States.MapTileType(X1, DY1) = 206)
                 or (States.MapTileType(X1, DY1) = 245);
               if TileOnBattlefield(X1, DY1) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY1;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2 - BOOMERANG_LENGTH - 1, Y2))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 - BOOMERANG_LENGTH - 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

             if not Wall then
               Wall := (States.MapTileType(X2 - BOOMERANG_LENGTH - 1, Y2) = 206)
               or (States.MapTileType(X2 - BOOMERANG_LENGTH - 1, Y2) = 245);

             for X1 := X2 - BOOMERANG_LENGTH to X2 - 2 do
             begin
               Desync := Desync + 1;
               if (TileOnBattlefield(X1, DY2))
               and (not Wall) then
               begin
                 TilesRoadLength[P] := TilesRoadLength[P] + 1;
                 SetLength(TilesRoadX[P], TilesRoadLength[P]);
                 SetLength(TilesRoadY[P], TilesRoadLength[P]);
                 SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
                 SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
                 TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X1;
                 TilesRoadY[P][Length(TilesRoadY[P]) - 1] := DY2;
                 ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
                 TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
                 Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
               end;
             end;

             Desync := Desync + 1;

             if (TileOnBattlefield(X2 - 1, Y2))
             and (not Wall) then
             begin
               TilesRoadLength[P] := TilesRoadLength[P] + 1;
               SetLength(TilesRoadX[P], TilesRoadLength[P]);
               SetLength(TilesRoadY[P], TilesRoadLength[P]);
               SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
               SetLength(TilesRoadObjects[P], TilesRoadLength[P]);
               TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 - 1;
               TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] := States.GameTime + 16 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 1] := States.GameTime + 14 + Round(DESYNC_FACTOR * Desync/SCOUT_ROAD_SPEED);
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 1] := SCOUT_OBJECT6;
               Tiles[TilesRoadX[P][Length(TilesRoadX[P]) - 1]][TilesRoadY[P][Length(TilesRoadY[P]) - 1]].ObjectRefreshTime := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + 70;
             end;

           end;

    end;

    Players[P].LastUsedSkill := sBoomerang;

    Players[P].LastRoadSkill := sBoomerang;

    Players[P].RoadSkillDelay := Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

    ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;

  end;

end;


procedure Silence(P, X, Y: Integer);
var
  I, X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= SILENCE_SCOUT_RADIUS)
    and (Abs(Y2 - Y) <= SILENCE_SCOUT_RADIUS)
    and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
        O := States.UnitOwner(U);
      if (U > 0)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroSilent)
      and (not Players[O].HeroMagicImmunity)
      and (not Players[O].HeroTotalImmunity)
      and (not Players[O].MindStunned)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := SCOUT_OBJECT7;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 8;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 9;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 10;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 11;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = WARRIOR_OBJECT7) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        Players[O].ScoutSilenceStartTime := States.GameTime + SILENCE_SCOUT_DELAY;
        Players[O].ScoutSilenceGiver := P;
        Players[P].LastUsedSkill := sSilence;
        Players[P].FieldSkillDelay := Round(SCOUT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        ClearFieldTilesArrayTime[P] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR;
      end;
    end;
  end;

end;


procedure Mind(P, X, Y: Integer);
var
  I, X2, Y2, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= MIND_RADIUS)
    and (Abs(Y2 - Y) <= MIND_RADIUS)
    and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
        O := States.UnitOwner(U);
      if (U <> - 1)
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroInFear)
      and (not Players[O].HeroMagicImmunity)
      and (not Players[O].HeroTotalImmunity)
      and (not Players[O].MindStunned)
      and (not Players[P].CaptureMind)
      and (not Players[P].MindStunned)
      and (not Players[O].CaptureMind)
      and (O <> P)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
      begin
        TilesWineLength[P] := TilesWineLength[P] + 32;
        SetLength(TilesWineX[P], TilesWineLength[P]);
        SetLength(TilesWineY[P], TilesWineLength[P]);
        SetLength(ClearTilesWineTimes[P], TilesWineLength[P]);
        SetLength(SetTilesWineTimes[P], TilesWineLength[P]);
        SetLength(TilesWineObjects[P], TilesWineLength[P]);

        TilesWineX[P][Length(TilesWineX[P]) - 32] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 31] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 30] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 29] := X + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 32] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 31] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 30] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 29] := Y + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 28] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 27] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 26] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 25] := X - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 28] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 27] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 26] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 25] := Y - 1;
           
        TilesWineX[P][Length(TilesWineX[P]) - 24] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 23] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 22] := X + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 21] := X + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 24] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 23] := Y - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 22] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 21] := Y + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 20] := X;
        TilesWineX[P][Length(TilesWineX[P]) - 19] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 18] := X - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 17] := X - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 20] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 19] := Y + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 18] := Y;
        TilesWineY[P][Length(TilesWineY[P]) - 17] := Y - 1;

        TilesWineX[P][Length(TilesWineX[P]) - 16] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 15] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 14] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 13] := X2 + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 16] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 15] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 14] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 13] := Y2 + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 12] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 11] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 10] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 9] := X2 - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 12] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 11] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 10] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 9] := Y2 - 1;
           
        TilesWineX[P][Length(TilesWineX[P]) - 8] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 7] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 6] := X2 + 1;
        TilesWineX[P][Length(TilesWineX[P]) - 5] := X2 + 1;

        TilesWineY[P][Length(TilesWineY[P]) - 8] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 7] := Y2 - 1;
        TilesWineY[P][Length(TilesWineY[P]) - 6] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 5] := Y2 + 1;

        TilesWineX[P][Length(TilesWineX[P]) - 4] := X2;
        TilesWineX[P][Length(TilesWineX[P]) - 3] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 2] := X2 - 1;
        TilesWineX[P][Length(TilesWineX[P]) - 1] := X2 - 1;

        TilesWineY[P][Length(TilesWineY[P]) - 4] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 3] := Y2 + 1;
        TilesWineY[P][Length(TilesWineY[P]) - 2] := Y2;
        TilesWineY[P][Length(TilesWineY[P]) - 1] := Y2 - 1;

        for I := 1 to 32 do
          TilesWineObjects[P][Length(TilesWineObjects[P]) - I] := SCOUT_OBJECT4;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 32] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 31] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 30] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 29] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 32] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 31] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 30] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 29] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 28] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 27] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 26] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 25] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 28] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 27] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 26] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 25] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 24] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 23] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 22] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 21] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 24] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 23] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 22] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 21] := States.GameTime + 12;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 20] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 19] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 18] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 17] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 20] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 19] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 18] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 17] := States.GameTime + 12;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 16] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 15] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 14] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 13] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 16] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 15] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 14] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 13] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 12] := States.GameTime + 18;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 11] := States.GameTime + 21;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 10] := States.GameTime + 24;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] := States.GameTime + 27;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 12] := States.GameTime + 15;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 11] := States.GameTime + 18;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 10] := States.GameTime + 21;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 9] := States.GameTime + 24;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 8] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 7] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 6] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 5] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 8] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 7] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 6] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 5] := States.GameTime + 12;

        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 4] := States.GameTime + 6;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 3] := States.GameTime + 9;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 2] := States.GameTime + 12;
        ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 1] := States.GameTime + 15;
    
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 4] := States.GameTime + 3;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 3] := States.GameTime + 6;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 2] := States.GameTime + 9;
        SetTilesWineTimes[P][Length(SetTilesWineTimes[P]) - 1] := States.GameTime + 12;

        for I := 1 to 32 do
          if (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BARB_OBJECT3)
          or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_ROCKET)
          or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = BOWMAN_OBJECT5)
          or (States.MapTileObject(TilesWineX[P][Length(TilesWineX[P]) - I], TilesWineY[P][Length(TilesWineY[P]) - I]) = WARRIOR_OBJECT7) then
            ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - I] + CLEANUP_TIME + 2;

        M[P] := O;
        M2[O] := P;
        Q[P] := P;

        Players[P].MindX := X;
        Players[P].MindY := Y;
        Players[P].MindDir := States.UnitDirection(States.GroupMember(Players[O].Hero, 0));
        Players[M[P]].MindX := X2;
        Players[M[P]].MindY := Y2;
        Players[M[P]].MindDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
        Actions.GroupKillAll(Players[O].Hero, True);
        Players[O].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(O), AI_TEMP_PLAYER, TEMP_PLAYER), Players[O].HeroType, Players[O].TempX, Players[O].TempY, 4, 1, 1);
        
        Players[P].CaptureMind := True;
        Players[O].MindStunned := True;

        Players[P].MindTime := States.GameTime + DELAY_OF_TURNING;
        Players[P].WineSkillDelay := 20;
        Players[P].LastUsedSkill := sMind;

        ClearWineTilesArrayTime[P] := ClearTilesWineTimes[P][Length(ClearTilesWineTimes[P]) - 9] + CLEAR_ARRAY_FACTOR;

      end;
    end;
  end;
end;


//REBEL


procedure Replica(P, X, Y: Integer);
var
  I, U, O, X2, Y2, Pos, Temp, UT: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    if (Abs(X2 - X) <= REPLICA_RADIUS)
    and (Abs(Y2 - Y) <= REPLICA_RADIUS)
    and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
    begin
      U := States.UnitAt(X, Y);
      if U <= 0 then
        Exit;
      O := States.UnitOwner(U);
      UT := States.Unittype(U);
      if ((InRange(O, 0, 7))
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroMagicImmunity)
      and (not Players[O].HeroTotalImmunity))
      or ((InRange(O, 8, 11))
      and (InRange(UT, 14, 27))
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam)) then
      begin
        TilesRoadLength[P] := TilesRoadLength[P] + 4;
        SetLength(TilesRoadX[P], TilesRoadLength[P]);
        SetLength(TilesRoadY[P], TilesRoadLength[P]);
        SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
        SetLength(TilesRoadObjects[P], TilesRoadLength[P]);

        TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
        TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
        TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
        TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
        TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
        TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
   
        for I := 1 to 4 do
          TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := REBEL_OBJECT;
    
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 8;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 10;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 12;
        ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 14;
    
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 1;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 3;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 5;
        SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 7;

        Players[P].RoadSkillCancelTime := States.GameTime + 14;
        for I := 1 to 4 do
          if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
            if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
            or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
            or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
            or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
              ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

        Players[P].ReplicaType := States.UnitType(U);
        Players[P].ReplicaTime := States.GameTime + REPLICA_DELAY;
        Players[P].ReplicaTarget := O; 

        if (InRange(Players[P].ReplicaTarget, 8, 11))
        and (States.KaMRandom < REPLICA_KILL_CHANCE) then
          if Length(Zombies) > 0 then
            for I := 0 to Length(Zombies) - 1 do
              if not States.UnitDead(Zombies[I].ZombieID) then
                if (Zombies[I].ZombieID = U)
                and (InRange(UT, 14, 27)) then
                  Zombies[I].ZombieKillTime := Players[P].ReplicaTime;

        Players[P].RoadSkillDelay := Round(REBEL_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        Players[P].LastUsedSkill := sReplica;
        Players[P].LastRoadSkill := sReplica;
        ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] + CLEAR_ARRAY_FACTOR;
      end;
    end;
  end;

end;


procedure Rift(P, X, Y: Integer);
var
  X2, Y2, X1, Y1, Z, U: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;
  if (Players[P].ZombiePlayer <> - 1) 
  and (TileOnBattlefield(X, Y)) then
  begin
    X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if (Abs(X2 - X) <= RIFT_USAGE_RADIUS)
    and (Abs(Y2 - Y) <= RIFT_USAGE_RADIUS) then
    begin
      Players[P].RiftX := X;
      Players[P].RiftY := Y;
      Players[P].RiftTime := States.GameTime + RIFT_DELAY;
      Players[P].RiftDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

      for X1 := X2 - RIFT_ZOMBIE_RADIUS to X2 + RIFT_ZOMBIE_RADIUS do
        for Y1 := Y2 - RIFT_ZOMBIE_RADIUS to Y2 + RIFT_ZOMBIE_RADIUS do
          if TileOnBattlefield(X1, Y1) then
          begin
            U := States.UnitAt(X1, Y1);
            if U > 0 then
              if (States.UnitOwner(U) = Players[P].ZombiePlayer)
              and (InRange(States.UnitType(U), 14, 27)) then
              begin
                SetLength(Zombies, Length(Zombies) + 1);
                Zombies[Length(Zombies) - 1].ZombieOwner := P;
                Zombies[Length(Zombies) - 1].ZombieType := 3;
                Zombies[Length(Zombies) - 1].ZombieHunger := States.UnitHunger(U);
                Zombies[Length(Zombies) - 1].ZombieTeleportTime := Players[P].RiftTime;
                Zombies[Length(Zombies) - 1].ZombieKillTime := 0;
                Zombies[Length(Zombies) - 1].ZombieThreadsTime := 0;
                Zombies[Length(Zombies) - 1].ZombieThreadsX := -1;
                Zombies[Length(Zombies) - 1].ZombieThreadsY := -1;
                Zombies[Length(Zombies) - 1].ZombieThreadsDir := -1;
                Z := Actions.GiveGroup(Players[P].ZombiePlayer, States.UnitType(U), TEMP_AI_X, TEMP_AI_Y, States.KaMRandomI(8), 1, 1);
                Actions.GroupHungerSet(Z, States.UnitHunger(U));
                Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
                Actions.UnitKill(U, True);
              end;
          end;

      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      Players[P].FieldSkillDelay := Round(REBEL_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
      Players[P].LastUsedSkill := sRift;
    end;

  end;

end;


procedure Mirror(P, X, Y: Integer);
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  Players[P].MirrorTime := States.GameTime + MIRROR_TIME;
  Players[P].WineSkillDelay := Round(REBEL_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
  Players[P].LastUsedSkill := sMirror;

end;


//ROGUE


procedure MentalBurst(P, X, Y, Dir: Integer; aStolen: Boolean);
var
  I, X2, Y2, Direction, Desync, Pos, Temp: Integer;
  Points: array[1..4] of Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    for I := 1 to 4 do
      Points[I] := I;

    if RANDOM_ANIMATIONS then
      for I := 1 to 4 do
      begin 
        Pos := 1 + States.KaMRandomI(4); 
        Temp := Points[Pos]; 
        Points[Pos] := Points[I]; 
        Points[I] := Temp;
      end;

    if not Players[P].HeroExiled then
    begin
      X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if not States.PlayerIsAI(P) then
        Direction := Players[P].SkillDirection;
    end
    else
    begin
      X2 := Players[P].HeroExileX;
      Y2 := Players[P].HeroExileY;
      if not States.PlayerIsAI(P) then
        Direction := Players[P].HeroExileDir;
    end;

    if (InRange(Direction, 0, 1))
    and (not TileOnBattlefield(X2, Y2 - MENTAL_DISTANCE)) then
      Exit;

    if (InRange(Direction, 2, 3))
    and (not TileOnBattlefield(X2 + MENTAL_DISTANCE, Y2)) then
      Exit;

    if (InRange(Direction, 4, 5))
    and (not TileOnBattlefield(X2, Y2 + MENTAL_DISTANCE)) then
      Exit;

    if (InRange(Direction, 6, 7))
    and (not TileOnBattlefield(X2 - MENTAL_DISTANCE, Y2)) then
      Exit;

    if not aStolen then
    begin
      RogueCirclesCounter[P] := RogueCirclesCounter[P] + 1;
      if RogueCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
        RogueCirclesCounter[P] := 0;
      RogueCirclesLength[P][RogueCirclesCounter[P]] := RogueCirclesLength[P][RogueCirclesCounter[P]] + MENTAL_CYCLES * MENTAL_RADIUS;
      SetLength(RogueCircles[P][RogueCirclesCounter[P]], RogueCirclesLength[P][RogueCirclesCounter[P]]);
    end;
    if aStolen then
    begin
      StolenRogueCirclesCounter[P] := StolenRogueCirclesCounter[P] + 1;
      if StolenRogueCirclesCounter[P] = MAX_CIRCLES_AT_ONCE then
        StolenRogueCirclesCounter[P] := 0;
      StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] := StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] + MENTAL_CYCLES * MENTAL_RADIUS;
      SetLength(StolenRogueCircles[P][StolenRogueCirclesCounter[P]], StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]]);
    end;
    TilesRoadLength[P] := TilesRoadLength[P] + 5;
    SetLength(TilesRoadX[P], TilesRoadLength[P]);
    SetLength(TilesRoadY[P], TilesRoadLength[P]);
    SetLength(ClearTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(SetTilesRoadTimes[P], TilesRoadLength[P]);
    SetLength(TilesRoadObjects[P], TilesRoadLength[P]);

    TilesRoadX[P][Length(TilesRoadX[P]) - 4] := X2 + 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 3] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 2] := X2 - 1;
    TilesRoadX[P][Length(TilesRoadX[P]) - 1] := X2 + 1;
    
    TilesRoadY[P][Length(TilesRoadY[P]) - 4] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 3] := Y2 - 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 2] := Y2 + 1;
    TilesRoadY[P][Length(TilesRoadY[P]) - 1] := Y2 - 1;
   
    for I := 1 to 4 do
      TilesRoadObjects[P][Length(TilesRoadObjects[P]) - I] := ROGUE_OBJECT2;
    
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[4]] := States.GameTime + 10;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[3]] := States.GameTime + 12;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[2]] := States.GameTime + 14;
    ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - Points[1]] := States.GameTime + 16;
    
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[4]] := States.GameTime + 2;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[3]] := States.GameTime + 4;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[2]] := States.GameTime + 6;
    SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - Points[1]] := States.GameTime + 8;

    Players[P].RoadSkillCancelTime := States.GameTime + 16;

    for I := 1 to 5 do
      if TileOnBattlefield(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) then
        if (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BARB_OBJECT3)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_ROCKET)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = BOWMAN_OBJECT5)
        or (States.MapTileObject(TilesRoadX[P][Length(TilesRoadX[P]) - I], TilesRoadY[P][Length(TilesRoadY[P]) - I]) = WARRIOR_OBJECT7) then
          ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - I] + CLEANUP_TIME;

    if not aStolen then
    begin
      for I := RogueCirclesLength[P][RogueCirclesCounter[P]] downto RogueCirclesLength[P][RogueCirclesCounter[P]] - MENTAL_CYCLES * MENTAL_RADIUS + 1 do
      begin
        RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Obj := ROGUE_OBJECT;

        case Direction of 
      
        0,1: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2 - MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 - MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

        2,3: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2 + MENTAL_DISTANCE;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 + MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

        4,5: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2 + MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 + MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

        6,7: begin
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].X := X2 - MENTAL_DISTANCE;
               RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 - MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearRogueArray[P][RogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].RoadSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

      end;

      RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].AddTime := States.GameTime + 20 + Round(ROGUE_ROAD_SPEED * (RogueCirclesLength[P][RogueCirclesCounter[P]] - I));
      if I mod MENTAL_RADIUS > 0 then
        RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Radius := MENTAL_RADIUS + 1 - I mod MENTAL_RADIUS
      else
        RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Radius := 1;
      end;
        
      for I := 0 to RogueCirclesLength[P][RogueCirclesCounter[P]] - 1 do 
        if I mod MENTAL_RADIUS = 1 then
          RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - I].Obj := 255;

     TimeToClearRogueArray[P][RogueCirclesCounter[P]] := RogueCircles[P][RogueCirclesCounter[P]][RogueCirclesLength[P][RogueCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    end;

    if aStolen then
    begin
      for I := StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] downto StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - MENTAL_CYCLES * MENTAL_RADIUS + 1 do
      begin
        StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Obj := ROGUE_OBJECT;

        case Direction of 
      
        0,1: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2 - MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 - MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

        2,3: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2 + MENTAL_DISTANCE;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 + MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

        4,5: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2 + MENTAL_DISTANCE;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2 + MENTAL_DISTANCE;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

        6,7: begin
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].X := X2 - MENTAL_DISTANCE;
               StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Y := Y2;
               TilesRoadX[P][Length(TilesRoadX[P]) - 5] := X2 - MENTAL_DISTANCE;    
               TilesRoadY[P][Length(TilesRoadY[P]) - 5] := Y2;
               SetTilesRoadTimes[P][Length(SetTilesRoadTimes[P]) - 5] := States.GameTime + 19;
               ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] := States.GameTime + 25;
               TilesRoadObjects[P][Length(TilesRoadObjects[P]) - 5] := CIRCLE_FILL_OBJ;
               TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := States.GameTime + Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               Players[P].LastUsedSkill := sMentalBurst;
               Players[P].LastRoadSkill := sMentalBurst;
               Players[P].WineSkillDelay := Round(ROGUE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               ClearRoadTilesArrayTime[P] := ClearTilesRoadTimes[P][Length(ClearTilesRoadTimes[P]) - 5] + CLEAR_ARRAY_FACTOR;
             end;

      end;

      StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].AddTime := States.GameTime + 20 + Round(ROGUE_ROAD_SPEED * (StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I));
      if I mod MENTAL_RADIUS > 0 then
        StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Radius := MENTAL_RADIUS + 1 - I mod MENTAL_RADIUS
      else
        StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Radius := 1;
      end;
        
      for I := 0 to StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - 1 do 
        if I mod MENTAL_RADIUS = 1 then
          StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - I].Obj := 255;

      TimeToClearStolenRogueArray[P][StolenRogueCirclesCounter[P]] := StolenRogueCircles[P][StolenRogueCirclesCounter[P]][StolenRogueCirclesLength[P][StolenRogueCirclesCounter[P]] - 1].AddTime + CLEAR_ARRAY_FACTOR;

    end;

    if (States.PlayerIsAI(P))
    and (Players[P].HP > 0) then
    begin
      Actions.GroupOrderWalk(Players[P].Hero, X2, Y2, Dir);
      Players[P].SkillCastRespawnTime := States.GameTime + SKILL_RESPAWN_TIME;
      Players[P].SkillCastDir := Dir;
      Players[P].SkillCastX := X2;
      Players[P].SkillCastY := Y2;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
    end;

  end;

end;


procedure StealSkill(P, X, Y: Integer);
var
  I, X2, Y2, U, O, UT: Integer;
  R: Single;
  Lure: Boolean;
begin 
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    if not Players[P].HeroExiled then
    begin
      X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    end
    else
    begin
      X2 := Players[P].HeroExileX;
      Y2 := Players[P].HeroExileY;
    end;
    if (Abs(X2 - X) <= STEAL_RADIUS)
    and (Abs(Y2 - Y) <= STEAL_RADIUS)
    and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
    begin
      U := States.UnitAt(X, Y);
      if U <= 0 then
        Exit;
      O := States.UnitOwner(U);
      UT := States.UnitType(U);
      if ((InRange(O, 0, 7))
      and (U = States.GroupMember(Players[O].Hero, 0))
      and (not Players[O].HeroMagicImmunity)
      and (not Players[O].HeroTotalImmunity)
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam))
      or ((InRange(O, 8, 11))
      and (InRange(UT, 14, 27))
      and (Players[P].PlayersTeam <> Players[O].PlayersTeam)) then
      begin
        TilesFieldLength[P] := TilesFieldLength[P] + 4;
        SetLength(TilesFieldX[P], TilesFieldLength[P]);
        SetLength(TilesFieldY[P], TilesFieldLength[P]);
        SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
        SetLength(TilesFieldObjects[P], TilesFieldLength[P]);
  
        TilesFieldX[P][Length(TilesFieldX[P]) - 4] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 3] := X2;
        TilesFieldX[P][Length(TilesFieldX[P]) - 2] := X2 - 1;
        TilesFieldX[P][Length(TilesFieldX[P]) - 1] := X2 + 1;
    
        TilesFieldY[P][Length(TilesFieldY[P]) - 4] := Y2 + 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 3] := Y2 - 1;
        TilesFieldY[P][Length(TilesFieldY[P]) - 2] := Y2;
        TilesFieldY[P][Length(TilesFieldY[P]) - 1] := Y2;

        for I := 1 to 4 do
          TilesFieldObjects[P][Length(TilesFieldObjects[P]) - I] := ROGUE_OBJECT3;
    
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 4] := States.GameTime + 11;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 3] := States.GameTime + 12;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 2] := States.GameTime + 13;
        ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := States.GameTime + 14;
    
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 4] := States.GameTime + 1;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 3] := States.GameTime + 2;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 2] := States.GameTime + 3;
        SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 4;

        for I := 1 to 4 do
          if TileOnBattlefield(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) then
            if (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BARB_OBJECT3)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_ROCKET)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = BOWMAN_OBJECT5)
             or (States.MapTileObject(TilesFieldX[P][Length(TilesFieldX[P]) - I], TilesFieldY[P][Length(TilesFieldY[P]) - I]) = WARRIOR_OBJECT7) then
               ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] := ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - I] + CLEANUP_TIME;

        if InRange(O, 0, 7) then
          Players[P].StolenSkill := Players[O].LastUsedSkill;

        if InRange(O, 8, 11)
        and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
        and (InRange(UT, 14, 27)) then
        begin
          R := States.KaMRandom;
          Lure := R < STEALSKILL_LURE_CHANCE;         
          if Lure then
          begin
            Players[P].LureType := States.UnitType(U);
            Players[P].LureX := X;
            Players[P].LureY := Y;
            Players[P].LureDir := States.UnitDirection(U);
            Players[P].LureTime := States.GameTime + DELAY_OF_TURNING;
            Players[P].LureHunger := States.UnitHunger(U);
            if Length(Zombies) > 0 then
              for I := 0 to Length(Zombies) - 1 do
                if U = Zombies[I].ZombieID then
                  Players[P].LureZombieType := Zombies[I].ZombieType;
            Actions.UnitKill(U, Lure);
          end;
        end;

        case Players[P].StolenSkill of

          sFieryLance: Players[P].StolenSkillName := '<$12>';
          sTeleport: Players[P].StolenSkillName := '<$20>';
          s10kSpears: Players[P].StolenSkillName := '<$28>';

          sCrackingEarth: Players[P].StolenSkillName := '<$14>';
          sWaveOfRage: Players[P].StolenSkillName := '<$22>';
          sTotem: Players[P].StolenSkillName := '<$30>';

          sSpikedEarth: Players[P].StolenSkillName := '<$9>';
          sZombieSummon: Players[P].StolenSkillName := '<$17>';
          sFear: Players[P].StolenSkillName := '<$25>';

          sAccurateShot: Players[P].StolenSkillName := '<$11>';
          sSuddenDeath: Players[P].StolenSkillName := '<$19>';
          sSniperShot: Players[P].StolenSkillName := '<$27>';

          sGravity: Players[P].StolenSkillName := '<$8>';
          sDeadlyFireworks: Players[P].StolenSkillName := '<$16>';
          sWerewolf: Players[P].StolenSkillName := '<$24>';

          sStrongWill: Players[P].StolenSkillName := '<$148>';
          sSweepingBlow: Players[P].StolenSkillName := '<$149>';

          sDisorientation: Players[P].StolenSkillName := '<$15>';
          sTrack: Players[P].StolenSkillName := '<$23>';
          sRegen: Players[P].StolenSkillName := '<$31>';

          sViseOfDeath: Players[P].StolenSkillName := '<$13>';
          sSacrificialTeleport: Players[P].StolenSkillName := '<$21>';
          sTower: Players[P].StolenSkillName := '<$29>';

          sRocket: Players[P].StolenSkillName := '<$10>';
          sPrison: Players[P].StolenSkillName := '<$18>';
          sRevengeFromNowhere: Players[P].StolenSkillName := '<$26>';

          sFierySnake: Players[P].StolenSkillName := '<$46>';
          sExile: Players[P].StolenSkillName := '<$112>';
          sShield: Players[P].StolenSkillName := '<$48>';

          sThreadsOfDeath: Players[P].StolenSkillName := '<$50>';
          sDeafeningClatter: Players[P].StolenSkillName := '<$51>';
          sRagingSpurt: Players[P].StolenSkillName := '<$52>';

          sMentalBurst: Players[P].StolenSkillName := '<$55>';
          sSteal: Players[P].StolenSkillName := '<$56>';
          sUniversal: Players[P].StolenSkillName := '<$57>';

          sBoomerang: Players[P].StolenSkillName := '<$80>';
          sSilence: Players[P].StolenSkillName := '<$81>';
          sMind: Players[P].StolenSkillName := '<$102>';

          sReplica: Players[P].StolenSkillName := '<$135>';
          sRift: Players[P].StolenSkillName := '<$136>';
          sMirror: Players[P].StolenSkillName := '<$137>';

          sNone: Players[P].StolenSkillName := '<$58>';

        end;

        Players[P].LastUsedSkill := sSteal;
        Players[P].FieldSkillDelay := Round(ROGUE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));

        if InRange(O, 0, 7) then
        begin
          Players[P].WineSkillDelay := ROGUE_WINE_DELAY;
          Players[P].RocketCharges := BOWMAN_CHARGES;
          Players[P].RocketChargeTime := 0;
          Players[P].SnakeCharges := SNAKE_CHARGES;
          Players[P].SnakeChargeTime := 0;
          if Players[P].StolenSkill <> sNone then
            Players[P].StolenSkillTime := STOLEN_SKILL_TIME;
        end;

        ClearFieldTilesArrayTime[P] := Max(ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] + CLEAR_ARRAY_FACTOR, ClearFieldTilesArrayTime[P]);

      end;
    end;
  end;
end;


procedure UseStolenSkill(P, X, Y, Dir: Integer);
var
  X2, Y2, Direction, Desync, TempRoadSkillDelay, TempFieldSkillDelay, U, O: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if (TileOnBattlefield(X, Y))
  and (Players[P].Hero > 0) then
  begin
    Desync := 0;

    TempRoadSkillDelay := 0;
    TempFieldSkillDelay := 0;

    if States.PlayerIsAI(P) then
    begin
      Players[P].CastingSkill := True;
      Players[P].SkillTime := States.GameTime + 17;
      Actions.GroupOrderHalt(Players[P].Hero);
      Direction := Dir;
    end;

    if not Players[P].HeroExiled then
    begin
      X2 := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Y2 := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if not States.PlayerIsAI(P) then
        Direction := Players[P].SkillDirection;
    end
    else
    begin
      X2 := Players[P].HeroExileX;
      Y2 := Players[P].HeroExileY;
      if not States.PlayerIsAI(P) then
        Direction := Players[P].HeroExileDir;
    end;

    U := States.UnitAt(X, Y);
    if U > 0 then
      O := States.UnitOwner(U);

    case Players[P].StolenSkill of

      sFieryLance: begin
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     FieryLance(P, X, Y, -1);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].WineSkillDelay := Round(LANCE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sTeleport: if (Abs(X - X2) <= TELEPORT_RADIUS)
                 and (Abs(Y - Y2) <= TELEPORT_RADIUS) then
                 begin
                   TempFieldSkillDelay := Players[P].FieldSkillDelay;
                   Teleport(P, X, Y);
                   Players[P].FieldSkillDelay := TempFieldSkillDelay;
                   Players[P].WineSkillDelay := Round(LANCE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                 end;

      s10kSpears: TenThousandsSpears(P, X, Y, -1);

      sCrackingEarth: begin
                        TempRoadSkillDelay := Players[P].RoadSkillDelay;
                        CrackingEarth(P, X, Y, -1);
                        Players[P].RoadSkillDelay := TempRoadSkillDelay;
                        Players[P].WineSkillDelay := Round(BARB_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                      end;

      sWaveOfRage: begin
                     TempFieldSkillDelay := Players[P].FieldSkillDelay;
                     WaveOfRage(P, X, Y);
                     Players[P].FieldSkillDelay := TempFieldSkillDelay;
                     Players[P].WineSkillDelay := Round(BARB_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sTotem: if (Abs(X - X2) <= TOTEM_ADD_RADIUS)
              and (Abs(Y - Y2) <= TOTEM_ADD_RADIUS) then
                TotemOfAncestors(P, X, Y);

      sSpikedEarth: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      SpikedEarth(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(SWORD_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sZombieSummon: if (Abs(X - X2) <= MILIZOMBIE_RADIUS)
                     and (Abs(Y - Y2) <= MILIZOMBIE_RADIUS) then
                     begin
                       TempFieldSkillDelay := Players[P].FieldSkillDelay;
                       ZombieSummon(P, X, Y);
                       Players[P].FieldSkillDelay := TempFieldSkillDelay;
                       Players[P].WineSkillDelay := Round(SWORD_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sFear: if (U > 0) then
               if (Abs(X - X2) <= IN_FEAR_RADIUS)
               and (Abs(Y - Y2) <= IN_FEAR_RADIUS)
               and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
               and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
                 if ((InRange(O, 0, 7))
                 and (not Players[O].HeroMagicImmunity)
                 and (not Players[O].HeroTotalImmunity))
                 or ((InRange(O, 8, 11))
                 and (Players[O].PlayersTeam <> Players[P].PlayersTeam)) then
                   Fear(P, X, Y);

      sAccurateShot: begin
                       TempRoadSkillDelay := Players[P].RoadSkillDelay;
                       AccurateShot(P, X, Y, -1);
                       Players[P].RoadSkillDelay := TempRoadSkillDelay;
                       Players[P].WineSkillDelay := Round(XBOW_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sSuddenDeath: if (Abs(X - X2) <= BOMB_RADIUS)
                    and (Abs(Y - Y2) <= BOMB_RADIUS) then
                    begin
                      TempFieldSkillDelay := Players[P].FieldSkillDelay;
                      SuddenDeath(P, X, Y);
                      Players[P].FieldSkillDelay := TempFieldSkillDelay;
                      Players[P].WineSkillDelay := Round(XBOW_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSniperShot: SniperShot(P, X, Y, -1);

      sGravity: if (Abs(X - X2) <= GRAVITY_RADIUS)
                and (Abs(Y - Y2) <= GRAVITY_RADIUS) then
                begin
                  TempRoadSkillDelay := Players[P].RoadSkillDelay;
                  Gravity(P, X, Y);
                  Players[P].RoadSkillDelay := TempRoadSkillDelay;
                  Players[P].WineSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                end;

      sStrongWill: if (O = P)
                   or (Players[P].PlayersTeam = Players[O].PlayersTeam) then
                   begin
                     if (Abs(X - X2) > STRONGWILL_RADIUS)
                     or (Abs(Y - Y2) > STRONGWILL_RADIUS) then
                       Exit;
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     StrongWill(P, X, Y);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].WineSkillDelay := Round(AXE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sSweepingBlow: begin
                       TempFieldSkillDelay := Players[P].FieldSkillDelay;
                       SweepingBlow(P, X, Y, -1);
                       Players[P].FieldSkillDelay := TempFieldSkillDelay;
                       Players[P].WineSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                     end;

      sDeadlyFireworks: if (Abs(X - X2) <= FIRE_RADIUS)
                        and (Abs(Y - Y2) <= FIRE_RADIUS) then
                        begin
                          TempFieldSkillDelay := Players[P].FieldSkillDelay;
                          DeadlyFireworks(P, X, Y);
                          Players[P].FieldSkillDelay := TempFieldSkillDelay;
                          Players[P].WineSkillDelay := Round(AXE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                        end;

      sWerewolf: Werewolf(P, X, Y);

      sDisorientation: if (Abs(X - X2) <= SHOCK_RADIUS)
                       and (Abs(Y - Y2) <= SHOCK_RADIUS) then
                       begin
                         TempRoadSkillDelay := Players[P].RoadSkillDelay;
                         Disorientation(P, X, Y);
                         Players[P].RoadSkillDelay := TempRoadSkillDelay;
                         Players[P].WineSkillDelay := Round(VAGA_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                       end;

      sTrack: if not Players[P].SettingTrack then
              begin
                TempFieldSkillDelay := Players[P].FieldSkillDelay;
                FieryTrack(P, X, Y);
                Players[P].FieldSkillDelay := TempFieldSkillDelay;
                Players[P].WineSkillDelay := Round(VAGA_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
              end;

      sRegen: if (Abs(X - X2) <= REGEN_RADIUS)
              and (Abs(Y - Y2) <= REGEN_RADIUS) then
                Regen(P, X, Y);

      sViseOfDeath: begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      ViseOfDeath(P, X, Y, -1);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(PIKE_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sSacrificialTeleport: if (Abs(X - X2) <= SACRIFICIAL_RADIUS)
                            and (Abs(Y - Y2) <= SACRIFICIAL_RADIUS)
                            and (Players[P].HP > 1) then
                            begin
                              TempFieldSkillDelay := Players[P].FieldSkillDelay;
                              SacrificialTeleport(P, X, Y);
                              Players[P].FieldSkillDelay := TempFieldSkillDelay;
                              Players[P].WineSkillDelay := Round(PIKE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                            end;

      sTower: if (Abs(X - X2) <= TOWER_RADIUS)
              and (Abs(Y - Y2) <= TOWER_RADIUS) then
                InfernalTower(P, X, Y);

      sRocket: if (Abs(X - X2) <= ROCKET_USAGE_RADIUS)
               and (Abs(Y - Y2) <= ROCKET_USAGE_RADIUS)
               and (Players[P].RocketCharges > 0) then
               begin
                 TempRoadSkillDelay := Players[P].RoadSkillDelay;
                 LaunchRocket(P, X, Y);
                 Players[P].RoadSkillDelay := TempRoadSkillDelay;
                 if Players[P].RocketCharges > 0 then
                 begin
                   Players[P].RocketCharges := Players[P].RocketCharges - 1;
                   if (Players[P].RocketCharges <= BOWMAN_CHARGES - 1)
                   and (Players[P].RocketChargeTime <= States.GameTime) then
                     Players[P].RocketChargeTime := States.GameTime + Round(BOWMAN_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                 end;
               end;

      sPrison: if (Abs(X - X2) <= PRISON_USAGE_RADIUS)
               and (Abs(Y - Y2) <= PRISON_USAGE_RADIUS) then
               begin
                 TempFieldSkillDelay := Players[P].FieldSkillDelay;
                 Prison(P, X, Y);
                 Players[P].FieldSkillDelay := TempFieldSkillDelay;
                 Players[P].WineSkillDelay := Round(BOWMAN_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
               end;

      sRevengeFromNowhere: RevengeFromNowhere(P, X, Y, -1);

      sFierySnake: if Players[P].SnakeCharges > 0 then
                   begin
                     TempRoadSkillDelay := Players[P].RoadSkillDelay;
                     FierySnake(P, X, Y, -1);
                     Players[P].RoadSkillDelay := TempRoadSkillDelay;
                     Players[P].SnakeCharges := Players[P].SnakeCharges - 1;
                     if (Players[P].SnakeCharges <= SNAKE_CHARGES - 1)
                     and (Players[P].SnakeChargeTime <= States.GameTime) then
                       Players[P].SnakeChargeTime := States.GameTime + Round(WARRIOR_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                   end;

      sExile: begin
                if U <= 0 then
                  Exit;
                if ((InRange(O, 0, 7))
                and (Players[P].TempPlayersTeam <> Players[O].TempPlayersTeam)
                and (Abs(X - X2) <= EXILE_RADIUS)
                and (Abs(Y - Y2) <= EXILE_RADIUS)
                and (not Players[O].HeroMagicImmunity)
                and (not Players[O].HeroTotalImmunity)
                and (not Players[O].MindStunned) //Serega is cheater!
                and (not Players[O].CaptureMind)
                and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7))
                or ((InRange(O, 0, 7))
                and (Players[P].TempPlayersTeam = Players[O].TempPlayersTeam)
                and (Abs(X - X2) <= EXILE_ALLY_RADIUS)
                and (Abs(Y - Y2) <= EXILE_ALLY_RADIUS)
                and (not Players[O].HeroMagicImmunity)
                and (not Players[O].HeroTotalImmunity)
                and (not Players[O].MindStunned) //Serega is cheater!
                and (not Players[O].CaptureMind)
                and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7)) then
                begin
                  TempFieldSkillDelay := Players[P].FieldSkillDelay;
                  Exile(P, X, Y);
                  Players[P].FieldSkillDelay := TempFieldSkillDelay;
                  Players[P].WineSkillDelay := Round(WARRIOR_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                end;
              end;

      sShield: Shield(P, X, Y);

      sThreadsOfDeath: begin
                         if U <= 0 then
                           Exit;
                         if ((InRange(O, 0, 11))
                         and (Abs(X - X2) <= THREADS_RADIUS)
                         and (Abs(Y - Y2) <= THREADS_RADIUS)
                         and (Players[P].TempPlayersTeam <> Players[O].TempPlayersTeam)
                         and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7))
                         or ((InRange(O, 0, 11))
                         and (Abs(X - X2) <= THREADS_ALLY_RADIUS)
                         and (Abs(Y - Y2) <= THREADS_ALLY_RADIUS)
                         and (Players[P].TempPlayersTeam = Players[O].TempPlayersTeam)
                         and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7)) then
                         begin
                           TempRoadSkillDelay := Players[P].RoadSkillDelay;
                           ThreadsOfDeath(P, X, Y);
                           Players[P].RoadSkillDelay := TempRoadSkillDelay;
                           Players[P].WineSkillDelay := Round(KNIGHT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                         end;
                       end;

      sDeafeningClatter: begin
                           TempFieldSkillDelay := Players[P].FieldSkillDelay;
                           DeafeningClatter(P, X, Y);
                           Players[P].FieldSkillDelay := TempFieldSkillDelay;
                           Players[P].WineSkillDelay := Round(KNIGHT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                         end;

      sRagingSpurt: RagingSpurt(P, X, Y);

      sMentalBurst: MentalBurst(P, X, Y, -1, True);

      sSteal: if U > 0 then
                if (Players[P].PlayersTeam <> Players[O].PlayersTeam)
                and (Abs(X - X2) <= STEAL_RADIUS)
                and (Abs(Y - Y2) <= STEAL_RADIUS)
                and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
                  if ((InRange(O, 0, 7))
                  and (not Players[O].HeroMagicImmunity)
                  and (not Players[O].HeroTotalImmunity))
                  or (InRange(O, 8, 11)) then
                  begin
                    TempFieldSkillDelay := Players[P].FieldSkillDelay;
                    StealSkill(P, X, Y);
                    Players[P].FieldSkillDelay := TempFieldSkillDelay;
                    Players[P].WineSkillDelay := Round(ROGUE_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                  end;

      sBoomerang: begin
                    TempRoadSkillDelay := Players[P].RoadSkillDelay;
                    Boomerang(P, X, Y, -1);
                    Players[P].RoadSkillDelay := TempRoadSkillDelay;
                    Players[P].WineSkillDelay := Round(SCOUT_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                  end;

      sSilence: if (U > 0)
                and (InRange(O, 0, 7))
                and (Abs(X - X2) <= SILENCE_SCOUT_RADIUS)
                and (Abs(Y - Y2) <= SILENCE_SCOUT_RADIUS)
                and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
                and (not Players[O].HeroMagicImmunity)
                and (not Players[O].HeroTotalImmunity)
                and (not Players[O].HeroSilent)
                and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
                begin
                  TempFieldSkillDelay := Players[P].FieldSkillDelay;
                  Silence(P, X, Y);
                  Players[P].FieldSkillDelay := TempFieldSkillDelay;
                  Players[P].WineSkillDelay := Round(SCOUT_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                end;

      sMind: if (U > 0) then
               if (Abs(X - X2) <= MIND_RADIUS)
               and (Abs(Y - Y2) <= MIND_RADIUS)
               and (not Players[O].HeroMagicImmunity)
               and (not Players[O].HeroTotalImmunity)
               and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
               and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
                 Mind(P, X, Y);

      sReplica: if (U > 0) then
                  if (Abs(X - X2) <= REPLICA_RADIUS)
                  and (Abs(Y - Y2) <= REPLICA_RADIUS)
                  and (States.MapTileObject(X, Y) <> WARRIOR_OBJECT7) then
                    if ((InRange(O, 0, 7)) 
                    and (not Players[O].HeroMagicImmunity)
                    and (not Players[O].HeroTotalImmunity))
                    or ((InRange(O, 8, 11))
                    and (Players[O].PlayersTeam <> Players[P].PlayersTeam)) then
                    begin
                      TempRoadSkillDelay := Players[P].RoadSkillDelay;
                      Replica(P, X, Y);
                      Players[P].RoadSkillDelay := TempRoadSkillDelay;
                      Players[P].WineSkillDelay := Round(REBEL_ROAD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
                    end;

      sRift: if (Abs(X - X2) <= RIFT_USAGE_RADIUS)
             and (Abs(Y - Y2) <= RIFT_USAGE_RADIUS) then
             begin
               TempFieldSkillDelay := Players[P].FieldSkillDelay;
               Rift(P, X, Y);
               Players[P].FieldSkillDelay := TempFieldSkillDelay;
               Players[P].WineSkillDelay := Round(REBEL_FIELD_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
             end;

      sMirror: Mirror(P, X, Y);

      sUniversal: Exit;

      sNone: Players[P].StolenSkillName := '<$58>';

    end; 
  end;
end;


procedure OnPlanRoadPlaced(P, X, Y: Integer);
var
  C: Integer;
  aRandom: Boolean;
begin

  Actions.PlanRemove(P, X, Y);

  aRandom := False;

//Choose Hero

  if ((not Players[P].HeroChosen)
  and (Players[P].Hero = -1)
  and (States.UnitAt(X, Y) > 0)
  and (TileOnChoiceArea(X, Y))
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 13, 27)))
  or ((Players[P].ReChoice)
  and (TileOnChoiceArea(X, Y))
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 13, 27))) then
  begin
    Players[P].HeroType := States.UnitType(States.UnitAt(X, Y));
    if Players[P].HeroType = 13 then
    begin
      Players[P].HeroType := States.KaMRandomI(12) + 15;
      aRandom := True;
    end;
    Players[P].TempHeroType := Players[P].HeroType;
    Players[P].HeroChosen := True;
    Actions.GiveUnit(8, 13, 13, 14, 4);
    Actions.ShowMsg(P, HeroDescription(P, Players[P].HeroType));

    if not aRandom then
    begin
      if InRange(P, 0, 3) then
        TeamChoice[0] := TeamChoice[0] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
      if InRange(P, 4, 7) then
        TeamChoice[1] := TeamChoice[1] + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$32> ' + States.UnitTypeName(Players[P].HeroType);
    end;

    if aRandom then
    begin
      if InRange(P, 0, 3) then
        TeamChoice[0] := TeamChoice[0] + '|<$115> [$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]: ' + States.UnitTypeName(Players[P].HeroType);
      if InRange(P, 4, 7) then
        TeamChoice[1] := TeamChoice[1] + '|<$115> [$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]: ' + States.UnitTypeName(Players[P].HeroType);
    end;

  end;

  if (Players[P].ReChoice)
  and (InRange(States.UnitType(States.UnitAt(X, Y)), 13, 27)) then
    EndReChoice(P);

  if Players[P].HP <= 0 then
    if not Players[P].CaptureMind then
      Exit;

  if Players[P].Hero <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].HeroReborn then
    Exit;

  if (States.UnitOwner(States.GroupMember(Players[P].Hero, 0)) <> P)
  and (not Players[P].HeroExiled) then
    Exit;

  if (Players[P].HeroExileBackTime > States.GameTime)
  and (Players[P].HeroExileGiver <> P) then
    Exit;

//Use skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].RoadSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
  begin
    Players[P].SkillDirection := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if Players[P].SkillDirection mod 2 = 1 then
    begin
      case States.KaMRandomI(100) of
        0..49:  Players[P].SkillDirection := Players[P].SkillDirection + 1;
        50..99: Players[P].SkillDirection := Players[P].SkillDirection - 1;
      end;
      if Players[P].SkillDirection = 8 then
        Players[P].SkillDirection := 0;
    end;

    case Players[P].HeroType of
      15: StrongWill(P, X, Y);
      16: SpikedEarth(P, X, Y, -1);
      17: LaunchRocket(P, X, Y);
      18: AccurateShot(P, X, Y, -1);
      19: FieryLance(P, X, Y, -1);
      20: ViseOfDeath(P, X, Y, -1);
      21: Boomerang(P, X, Y, -1);
      22: ThreadsOfDeath(P, X, Y);
      23: CrackingEarth(P, X, Y, -1);
      24: Replica(P, X, Y);
      25: MentalBurst(P, X, Y, -1, False);
      26: FierySnake(P, X, Y, -1);
      27: Gravity(P, X, Y);
    end;

  for C := 0 to TilesRoadLength[P] - 1 do
    if States.MapTileObject(TilesRoadX[P][C], TilesRoadY[P][C]) = WARRIOR_OBJECT7 then
      SetTilesRoadTimes[P][C] := 0;

  end;

end;


procedure OnPlanFieldPlaced(P, X, Y: Integer);
var
  C: Integer;
begin

  Actions.PlanRemove(P, X, Y);

  if Players[P].HP <= 0 then
    if not Players[P].CaptureMind then
      Exit;

  if Players[P].Hero <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].HeroReborn then
    Exit;

  if (States.UnitOwner(States.GroupMember(Players[P].Hero, 0)) <> P)
  and (not Players[P].HeroExiled) then
    Exit;

  if (Players[P].HeroExileBackTime > States.GameTime)
  and (Players[P].HeroExileGiver <> P) then
    Exit;

//Use skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].FieldSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
  begin
    Players[P].SkillDirection := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if Players[P].SkillDirection mod 2 = 1 then
    begin
      case States.KaMRandomI(100) of
        0..49:  Players[P].SkillDirection := Players[P].SkillDirection + 1;
        50..99: Players[P].SkillDirection := Players[P].SkillDirection - 1;
      end;
      if Players[P].SkillDirection = 8 then
        Players[P].SkillDirection := 0;
    end;

    case Players[P].HeroType of
      15: SweepingBlow(P, X, Y, -1);
      16: ZombieSummon(P, X, Y);
      17: Prison(P, X, Y);
      18: SuddenDeath(P, X, Y);
      19: Teleport(P, X, Y);
      20: SacrificialTeleport(P, X, Y);
      21: Silence(P, X, Y);
      22: DeafeningClatter(P, X, Y);
      23: WaveOfRage(P, X, Y);
      24: Rift(P, X, Y);
      25: StealSkill(P, X, Y);
      26: Exile(P, X, Y);
      27: DeadlyFireworks(P, X, Y);
    end;

  for C := 0 to TilesFieldLength[P] - 1 do
    if States.MapTileObject(TilesFieldX[P][C], TilesFieldY[P][C]) = WARRIOR_OBJECT7 then
      SetTilesFieldTimes[P][C] := 0;

  end;

end;

  
procedure OnPlanWinefieldPlaced(P, X, Y: Integer);
var
  C: Integer;
begin

  Actions.PlanRemove(P, X, Y);

  if Players[P].HP <= 0 then
    if not Players[P].CaptureMind then
      Exit;

  if Players[P].Hero <= 0 then
    Exit;

  if not TileOnBattlefield(X, Y) then
    Exit;

  if Players[P].HeroReborn then
    Exit;

  if (States.UnitOwner(States.GroupMember(Players[P].Hero, 0)) <> P)
  and (not Players[P].HeroExiled) then
    Exit;

  if (Players[P].HeroExileBackTime > States.GameTime)
  and (Players[P].HeroExileGiver <> P) then
    Exit;

//Use skills

  if (Players[P].Hero > 0)
  and (Players[P].HeroChosen)
  and (Players[P].WineSkillDelay = 0)
  and not (Players[P].HeroStunned)
  and not (Players[P].HeroInFear)
  and not (Players[P].HeroSilent) then
  begin
    Players[P].SkillDirection := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
    if Players[P].SkillDirection mod 2 = 1 then
    begin
      case States.KaMRandomI(100) of
        0..49:  Players[P].SkillDirection := Players[P].SkillDirection + 1;
        50..99: Players[P].SkillDirection := Players[P].SkillDirection - 1;
      end;
      if Players[P].SkillDirection = 8 then
        Players[P].SkillDirection := 0;
    end;

    case Players[P].HeroType of
      15: Werewolf(P, X, Y);
      16: Fear(P, X, Y);
      17: RevengeFromNowhere(P, X, Y, -1);
      18: SniperShot(P, X, Y, -1);
      19: TenThousandsSpears(P, X, Y, -1);
      20: InfernalTower(P, X, Y);
      21: Mind(P, X, Y);
      22: RagingSpurt(P, X, Y);
      23: TotemOfAncestors(P, X, Y);
      24: Mirror(P, X, Y);
      25: UseStolenSkill(P, X, Y, -1);
      26: Shield(P, X, Y);
      27: Regen(P, X, Y);
    end;

  for C := 0 to TilesWineLength[P] - 1 do
    if States.MapTileObject(TilesWineX[P][C], TilesWineY[P][C]) = WARRIOR_OBJECT7 then
      SetTilesWineTimes[P][C] := 0;

  end;

end;


//AI


function TileIsDangerous(P, X, Y: Integer): Boolean;
var
  aObj: Integer;
begin
  Result := False;
  if TileOnBattlefield(X, Y) then
  begin
    aObj := States.MapTileobject(X, Y);
    Result := (ObjectType(aObj) = otKill)
              or (ObjectType(aObj) = otStun)
              or (States.MapTileType(X, Y) = INFERNAL_TILE);

    Result := Result and (not aObj = PikeObjects[P]);

  end;
end;


function TileHasEnemyTower(P, X, Y: Integer): Boolean;
var
  aHouse, O, HT: Integer;
begin
  Result := False;
  if TileOnBattlefield(X, Y) then
  begin
    aHouse := States.HouseAt(X, Y);
    if aHouse > 0 then
    begin
      HT := States.HouseType(aHouse);
      O := States.HouseOwner(aHouse);
    end;
    Result := (HT = 17)
              and (Players[P].PlayersTeam <> Players[O].PlayersTeam);
  end;
end;


function AlivePlayersLeft: Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := 0 to 3 do
    if (States.PlayerEnabled(I))
    and (Players[I].HP > 0) then
      Result := Result + 1;
end;


function AlivePlayersRight: Integer;
var
  I: Integer;
begin
  Result := 0;
  for I := 4 to 7 do
    if (States.PlayerEnabled(I))
    and (Players[I].HP > 0) then
      Result := Result + 1;
end;


function AlivePlayersCount: Integer;
begin
  Result := AlivePlayersLeft + AlivePlayersRight;
end;


function GroupIsMoving(G: Integer): Boolean;
var
  O: Integer;
begin
  if G <= 0 then
    Exit;
  if States.GroupMember(G, 0) <= 0 then
    Exit;

  O := States.GroupOwner(G);

  if States.GameTime mod MOVEMENT_FACTOR = 0 then
  begin
    NewX[O] := States.UnitPositionX(States.GroupMember(G, 0));
    NewY[O] := States.UnitPositionY(States.GroupMember(G, 0));
  end;

  if States.GameTime mod MOVEMENT_FACTOR = 0 then
  begin
    OldX[O] := States.UnitPositionX(States.GroupMember(G, 0));
    OldY[O] := States.UnitPositionY(States.GroupMember(G, 0));
  end;

  Result := (OldX[O] div MOVEMENT_DISTANCE <> NewX[O] div MOVEMENT_DISTANCE)
            or (OldY[O] div MOVEMENT_DISTANCE <> NewY[O] div MOVEMENT_DISTANCE);

end;


procedure RespawnUnit(P: Integer);
begin
  if (States.PlayerEnabled(P))
  and (Players[P].HP > 0)
  and (States.PlayerIsAI(P)) then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SkillCastX, Players[P].SkillCastY, Players[P].SkillCastDir, 1, 1);
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    if (Players[P].HeroStunned)
    or (Players[P].HeroInFear) then
      Actions.GroupBlockOrders(Players[P].Hero, True);
   end;
end;


procedure AIIgnore(P: Integer);
var
  aX, aY: Integer;
begin

  if Players[P].Hero <= 0 then
    Exit;

  if (InRange(P, 0, 7))
  and (Players[P].Hero > 0) then
  begin

    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if Players[P].HeroExiled then
    begin
      aX := Players[P].HeroExileX;
      aY := Players[P].HeroExileY;
    end;

    if TileOnBattlefield(aX, aY) then
    begin

      if (States.MapTileObject(aX, aY) = WARRIOR_OBJECT7)
      or (Players[P].HeroTotalImmunity) then
      begin

        if (InRange(P, 0, 3))
        and (not States.PlayerAllianceCheck(Players[4].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[4].ZombiePlayer, P, True, True);

        if (InRange(P, 4, 7))
        and (not States.PlayerAllianceCheck(Players[0].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[0].ZombiePlayer, P, True, True);

      end;

      if (States.MapTileObject(aX, aY) <> WARRIOR_OBJECT7)
      and (not Players[P].HeroTotalImmunity) then
      begin

        if (InRange(P, 0, 3))
        and (States.PlayerAllianceCheck(Players[4].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[4].ZombiePlayer, P, False, False);

        if (InRange(P, 4, 7))
        and (States.PlayerAllianceCheck(Players[0].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[0].ZombiePlayer, P, False, False);

      end;

      if Tiles[aX][aY].ShieldTime >= States.GameTime then
      begin

        if (InRange(P, 0, 3))
        and (not States.PlayerAllianceCheck(Players[4].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[4].ZombiePlayer, P, True, True);

        if (InRange(P, 4, 7))
        and (not States.PlayerAllianceCheck(Players[0].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[0].ZombiePlayer, P, True, True);

      end;

      if (Tiles[aX][aY].ShieldTime < States.GameTime)
      and (not Players[P].HeroTotalImmunity) then
      begin

        if (InRange(P, 0, 3))
        and (States.PlayerAllianceCheck(Players[4].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[4].ZombiePlayer, P, False, False);

        if (InRange(P, 4, 7))
        and (States.PlayerAllianceCheck(Players[0].ZombiePlayer, P)) then
          Actions.PlayerAllianceChange(Players[0].ZombiePlayer, P, False, False);

      end;

    end;

  end;

end;


procedure CheckAlliancesAfterShield(P: Integer);
var
  I: Integer;
begin
  if (States.GameTime = Players[P].ShieldStartTime)
  or (States.GameTime = Players[P].ShieldEndTime) then
    for I := 0 to 7 do
      AIIgnore(I);
end;


procedure AvoidDanger(P: Integer);
var
  aX, aY, D: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if not States.PlayerIsAI(P) then
    Exit;

  if not AI_ENABLED then
    Exit;

  if (InRange(P, 0, 7))
  and (Players[P].Hero > 0) then
  begin

    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));

    if (not Players[P].CastingSkill)
    and (TileOnBattlefield(aX, aY)) then
    begin
      case D of

        0: if (TileIsDangerous(P, aX, aY - 2))
           or (TileIsDangerous(P, aX, aY - 1)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        1: if (TileIsDangerous(P, aX + 1, aY - 2))
           or (TileIsDangerous(P, aX + 1, aY - 1))
           or (TileIsDangerous(P, aX + 2, aY - 2))
           or (TileIsDangerous(P, aX + 2, aY - 1)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        2: if (TileIsDangerous(P, aX + 1, aY))
           or (TileIsDangerous(P, aX + 2, aY)) then
           begin
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        3: if (TileIsDangerous(P, aX + 1, aY + 2))
           or (TileIsDangerous(P, aX + 1, aY + 1))
           or (TileIsDangerous(P, aX + 2, aY + 2))
           or (TileIsDangerous(P, aX + 2, aY + 1)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        4: if (TileIsDangerous(P, aX, aY + 2))
           or (TileIsDangerous(P, aX, aY + 1)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        5: if (TileIsDangerous(P, aX - 1, aY + 2))
           or (TileIsDangerous(P, aX - 1, aY + 1))
           or (TileIsDangerous(P, aX - 2, aY + 2))
           or (TileIsDangerous(P, aX - 2, aY + 1)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5), aY - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        6: if (TileIsDangerous(P, aX - 2, aY))
           or (TileIsDangerous(P, aX - 1, aY)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
           end;

        7: if (TileIsDangerous(P, aX - 1, aY - 2))
           or (TileIsDangerous(P, aX - 1, aY - 1))
           or (TileIsDangerous(P, aX - 2, aY - 2))
           or (TileIsDangerous(P, aX - 2, aY - 1)) then
           begin
             Players[P].AITarget := -1;
             Actions.GroupOrderHalt(Players[P].Hero);
             Actions.GroupOrderWalk(Players[P].Hero, aX - States.KaMRandomI(5), aY + States.KaMRandomI(5), States.KaMRandomI(8));
           end;

      end;

    end;

  end;

end;


procedure AvoidTowers(P: Integer);
var
  aX, aY, X1, Y1: Integer;
begin
  if Players[P].Hero <= 0 then
    Exit;

  if not States.PlayerIsAI(P) then
    Exit;

  if not AI_ENABLED then
    Exit;

  if (InRange(P, 0, 7))
  and (Players[P].Hero > 0) then
  begin

    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

    if not Players[P].CastingSkill then
      for X1 := aX - 6 to aX + 6 do
      for Y1 := aY - 6 to aY + 6 do
        if TileHasEnemyTower(P, X1, Y1) then
        begin
          Players[P].AITarget := -1;
          Actions.GroupOrderHalt(Players[P].Hero);
          Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(5) - States.KaMRandomI(5), aY + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8));
        end;

  end;

end;


function HeroTypeToPhysicalStrength(P: Integer): Integer;
begin
  Result := 0;
  case Players[P].HeroType of
    15: Result := 4;
    16: Result := 9;
    17: Result := 3;
    18: Result := 7;
    19: Result := 2;
    20: Result := 4;
    21: Result := 8;
    22: Result := 11;
    23: Result := 10;
    24: Result := 5;
    25: Result := 1;
    26: Result := 10;
    27: Result := 6
    else Result := 0;
  end;
end;


function HeroTypeToReChargePriority(P: Integer): Integer;
begin
  Result := 0;
  case Players[P].HeroType of
    15: Result := 10;
    16: Result := 6;
    17: Result := 7;
    18: Result := 1;
    19: Result := 9;
    20: Result := 1;
    21: Result := 1;
    22: Result := 1;
    23: Result := 8;
    24: Result := 1;
    25: Result := 1;
    26: Result := 1;
    27: Result := 10
    else Result := 0;
  end;
end;


function HeroTypeToDDPriority(P: Integer): Integer;
begin
  Result := 0;
  case Players[P].HeroType of
    15: Result := 9;
    16: Result := 1;
    17: Result := 8;
    18: Result := 1;
    19: Result := 1;
    20: Result := 1;
    21: Result := 1;
    22: Result := 1;
    23: Result := 10;
    24: Result := 1;
    25: Result := 1;
    26: Result := 1;
    27: Result := 1
    else Result := 0;
  end;
end;


function FindClosestEnemy(P, X, Y, Radius: Integer; CheckZombies: Boolean): Integer;
var
  I, J, DX, DY, U, ThisDistSqr, BestDistSqr: Integer;
  Groups: array of Integer;
begin
  Result := -1;
  for I := 0 to 7 + 4 * Byte(CheckZombies) do
    if (States.PlayerEnabled(I))
    and (I <> P)
    and (Players[P].Hero > 0)
    and (Players[P].HP > 0)
    and (Players[P].PlayersTeam <> Players[I].PlayersTeam) then
    begin
      Groups := States.PlayerGetAllGroups(I);
      if Length(Groups) > 0 then
        for J := 0 to Length(Groups) - 1 do
          if not States.GroupDead(Groups[J]) then
          begin
            U := States.GroupMember(Groups[J], 0);
            DX := States.UnitPositionX(U) - X;
            DY := States.UnitPositionY(U) - Y;
            ThisDistSqr := (DX * DX) + (DY * DY);
            if ((ThisDistSqr <= Radius * Radius)
            and ((Result = -1) or (ThisDistSqr < BestDistSqr))) then
            begin
              BestDistSqr := ThisDistSqr;
              Result := U;
            end;
          end;
     end;
end;


function FindEnemy(P, X, Y, Radius: Integer; CheckZombies: Boolean): Integer;
var
  I, J, DX, DY, U, DistSqr: Integer;
  Groups, Enemies: array of Integer;
begin
  Result := -1;
  for I := 0 to 7 + 4 * Byte(CheckZombies) do
    if (States.PlayerEnabled(I))
    and (I <> P)
    and (Players[P].Hero > 0)
    and (Players[P].HP > 0)
    and (Players[P].PlayersTeam <> Players[I].PlayersTeam) then
    begin
      Groups := States.PlayerGetAllGroups(I);
      if Length(Groups) > 0 then
        for J := 0 to Length(Groups) - 1 do
          if not States.GroupDead(Groups[J]) then
          begin
            U := States.GroupMember(Groups[J], 0);
            DX := States.UnitPositionX(U) - X;
            DY := States.UnitPositionY(U) - Y;
            DistSqr := (DX * DX) + (DY * DY);
            if (DistSqr <= Radius * Radius) then
            begin
              SetLength(Enemies, Length(Enemies) + 1);
              if Length(Enemies) > 0 then
              begin
                Enemies[Length(Enemies) - 1] := U;
                Result := IfThen(TileOnBattlefield(States.UnitPositionX(U), States.UnitPositionY(U)), Enemies[States.KaMRandomI(Length(Enemies))], -1);
              end;
            end;
          end;
     end;
end;


function CheckUnitsCount(P, X, Y, Radius: Integer; CheckZombies, Allied: Boolean): Integer;
var
  I, J, DX, DY, U, DistSqr: Integer;
  Groups: array of Integer;
begin
  Result := 0;
  for I := 0 to 7 + 4 * Byte(CheckZombies) do
    if (States.PlayerEnabled(I))
    and (I <> P)
    and (Players[P].Hero > 0)
    and (Players[P].HP > 0) then
    begin
      Groups := States.PlayerGetAllGroups(I);
      if Length(Groups) > 0 then
        for J := 0 to Length(Groups) - 1 do
          if not States.GroupDead(Groups[J]) then
          begin
            U := States.GroupMember(Groups[J], 0);
            DX := States.UnitPositionX(U) - X;
            DY := States.UnitPositionY(U) - Y;
            DistSqr := (DX * DX) + (DY * DY);
            if DistSqr <= (Radius * Radius) then
            begin
              if Players[P].PlayersTeam = Players[I].PlayersTeam then
                Result := Result + 1 * Byte(Allied);
              if Players[P].PlayersTeam <> Players[I].PlayersTeam then
                Result := Result + 1 * Byte(not Allied);
            end;
          end;
     end;
end;


function ClosestToRuneLeft: Integer;
var
  I, J, DX, DY, U, ThisDistSqr, BestDistSqr: Integer;
  Groups: array of Integer;
begin
  Result := -1;
  for I := 0 to 3 do
    if (States.PlayerEnabled(I))
    and (Players[I].Hero > 0)
    and (Players[I].HP > 0) then
    begin
      Groups := States.PlayerGetAllGroups(I);
      if Length(Groups) > 0 then
        for J := 0 to Length(Groups) - 1 do
          if not States.GroupDead(Groups[J]) then
          begin
            U := States.GroupMember(Groups[J], 0);
            DX := States.UnitPositionX(U) - RUNE_X;
            DY := States.UnitPositionY(U) - RUNE_Y;
            ThisDistSqr := (DX * DX) + (DY * DY);
            if ((ThisDistSqr <= RUNE_CHECK_RADIUS * RUNE_CHECK_RADIUS)
            and ((Result = -1) or (ThisDistSqr < BestDistSqr)))
            or (AlivePlayersLeft = 1) then
            begin
              BestDistSqr := ThisDistSqr;
              Result := States.GroupOwner(Groups[J]);
            end;
          end;
     end;
end;


function ClosestToRuneRight: Integer;
var
  I, J, DX, DY, U, ThisDistSqr, BestDistSqr: Integer;
  Groups: array of Integer;
begin
  Result := -1;
  for I := 4 to 7 do
    if (States.PlayerEnabled(I))
    and (Players[I].Hero > 0)
    and (Players[I].HP > 0) then
    begin
      Groups := States.PlayerGetAllGroups(I);
      if Length(Groups) > 0 then
        for J := 0 to Length(Groups) - 1 do
          if not States.GroupDead(Groups[J]) then
          begin
            U := States.GroupMember(Groups[J], 0);
            DX := States.UnitPositionX(U) - RUNE_X;
            DY := States.UnitPositionY(U) - RUNE_Y;
            ThisDistSqr := (DX * DX) + (DY * DY);
            if ((ThisDistSqr <= RUNE_CHECK_RADIUS * RUNE_CHECK_RADIUS)
            and ((Result = -1) or (ThisDistSqr < BestDistSqr)))
            or (AlivePlayersRight = 1) then
            begin
              BestDistSqr := ThisDistSqr;
              Result := States.GroupOwner(Groups[J]);
            end;
          end;
     end;
end;


function StrongestHeroLeft: Integer;
var
  I, HighS, ThisS: Integer;
begin
  Result := -1;
  HighS := 0;
  for I := 0 to 3 do
  begin
    ThisS := HeroTypeToPhysicalStrength(I);
    if (ThisS > HighS)
    and (Players[I].HP > 0)
    and (I = ClosestToRuneLeft) then
    begin
      HighS := ThisS;
      Result := I;
    end;
  end;
end;


function StrongestHeroRight: Integer;
var
  I, HighS, ThisS: Integer;
begin
  Result := -1;
  HighS := 0;
  for I := 4 to 7 do
  begin
    ThisS := HeroTypeToPhysicalStrength(I);
    if (ThisS > HighS)
    and (Players[I].HP > 0)
    and (I = ClosestToRuneRight) then
    begin
      HighS := ThisS;
      Result := I;
    end;
  end;
end;


function HasLowestHPLeft: Integer;
var
  I, LowHP, ThisHP: Integer;
begin
  Result := -1;
  LowHP := MAX_HP + 1;
  for I := 0 to 3 do
  begin
    ThisHP := Players[I].HP;
    if (ThisHP < LowHP)
    and (ThisHP <> 0)
    and (I = ClosestToRuneLeft)
    and (Players[I].HP < MAX_HP) then
    begin
      LowHP := ThisHP;
      Result := I;
    end;
  end;
end;


function HasLowestHPRight: Integer;
var
  I, LowHP, ThisHP: Integer;
begin
  Result := -1;
  LowHP := MAX_HP + 1;
  for I := 4 to 7 do
  begin
    ThisHP := Players[I].HP;
    if (ThisHP < LowHP)
    and (ThisHP <> 0)
    and (I = ClosestToRuneRight)
    and (Players[I].HP < MAX_HP) then
    begin
      LowHP := ThisHP;
      Result := I;
    end;
  end;
end;


function NeedsReChargeLeft: Integer;
var
  I, HighS, ThisS: Integer;
begin
  Result := -1;
  HighS := 0;
  for I := 0 to 3 do
  begin
    ThisS := HeroTypeToReChargePriority(I);
    if (ThisS > HighS)
    and (Players[I].HP > 0)
    and (I = ClosestToRuneLeft) then
    begin
      HighS := ThisS;
      Result := I;
    end;
  end;
end;


function NeedsReChargeRight: Integer;
var
  I, HighS, ThisS: Integer;
begin
  Result := -1;
  HighS := 0;
  for I := 4 to 7 do
  begin
    ThisS := HeroTypeToReChargePriority(I);
    if (ThisS > HighS)
    and (Players[I].HP > 0)
    and (I = ClosestToRuneRight) then
    begin
      HighS := ThisS;
      Result := I;
    end;
  end;
end;


function NeedsDDLeft: Integer;
var
  I, HighS, ThisS: Integer;
begin
  Result := -1;
  HighS := 0;
  for I := 0 to 3 do
  begin
    ThisS := HeroTypeToDDPriority(I);
    if (ThisS > HighS)
    and (Players[I].HP > 0)
    and (I = ClosestToRuneLeft) then
    begin
      HighS := ThisS;
      Result := I;
    end;
  end;
end;


function NeedsDDRight: Integer;
var
  I, HighS, ThisS: Integer;
begin
  Result := -1;
  HighS := 0;
  for I := 4 to 7 do
  begin
    ThisS := HeroTypeToDDPriority(I);
    if (ThisS > HighS)
    and (Players[I].HP > 0)
    and (I = ClosestToRuneRight) then
    begin
      HighS := ThisS;
      Result := I;
    end;
  end;
end;


procedure AITakeRune(P: Integer);
begin
  if (Players[P].Hero <= 0)
  or (Players[P].CastingSkill)
  or (Players[P].HeroReborn)
  or (States.MapTileObject(RUNE_X, RUNE_Y) = 255) then
    Exit;

  if not AI_ENABLED then
    Exit;

  if (InRange(P, 0, 3))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_ILLUSION_OBJ)
  and (P <> StrongestHeroLeft) then
    Exit;

  if (InRange(P, 4, 7))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_ILLUSION_OBJ)
  and (P <> StrongestHeroRight) then
    Exit;

  if (InRange(P, 0, 3))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_REGEN_OBJ)
  and (P <> HasLowestHPLeft) then
    Exit;

  if (InRange(P, 4, 7))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_REGEN_OBJ)
  and (P <> HasLowestHPRight) then
    Exit;

  if (InRange(P, 0, 3))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_RECHARGE_OBJ)
  and (P <> NeedsReChargeLeft) then
    Exit;

  if (InRange(P, 4, 7))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_RECHARGE_OBJ)
  and (P <> NeedsReChargeRight) then
    Exit;

  if (InRange(P, 0, 3))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_DOUBLE_OBJ)
  and (P <> NeedsDDLeft) then
    Exit;

  if (InRange(P, 4, 7))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_DOUBLE_OBJ)
  and (P <> NeedsDDRight) then
    Exit;

  if (InRange(P, 0, 3))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_MAGIC_IMMUNITY_OBJ)
  and ((P <> ClosestToRuneLeft) or (Players[P].HeroMagicImmunity)) then
    Exit;

  if (InRange(P, 4, 7))
  and (States.MapTileObject(RUNE_X, RUNE_Y) = RUNE_MAGIC_IMMUNITY_OBJ)
  and ((P <> ClosestToRuneRight) or (Players[P].HeroMagicImmunity)) then
    Exit;

  Actions.GroupOrderWalk(Players[P].Hero, RUNE_X, RUNE_Y, States.KaMRandomI(8));

end;


function ClosestDistance(P: Integer): Integer;
{var
  SelfSkillDistance, EnemySkillDistance: Integer;}
begin
  Result := 0;
  {SelfSkillDistance := 0;
  EnemySkillDistance := 0;
  case Players[P].HeroType of
    15: SelfSkillDistance := FIREWORKS1_RADIUS - 1;
    16: SelfSkillDistance := IN_FEAR_RADIUS - 1;
    17: SelfSkillDistance := PRISON_USAGE_RADIUS - 1;
    18: SelfSkillDistance := BOMB_RADIUS - 1;
    19: SelfSkillDistance := 8;
    20: SelfSkillDistance := VISE_RADIUS;
    21: SelfSkillDistance := MIND_RADIUS - 1;
    22: SelfSkillDistance := DEAFENING_RADIUS - 1;
    23: SelfSkillDistance := RAGE_RADIUS - 1;
    24: SelfSkillDistance := REPLICA_RADIUS - 1;
    25: SelfSkillDistance := STEAL_RADIUS - 2;
    26: SelfSkillDistance := EXILE_RADIUS - 1;
    27: SelfSkillDistance := SHOCK_RADIUS - 1
    else SelfSkillDistance := 0;
  end;
  if Players[P].AITarget > 0 then
    if InRange(States.UnitOwner(Players[P].AITarget), 0, 7) then
      case States.UnitType(Players[P].AITarget) of
        15: EnemySkillDistance := FIREWORKS1_RADIUS - 1;
        16: EnemySkillDistance := IN_FEAR_RADIUS - 1;
        17: EnemySkillDistance := PRISON_USAGE_RADIUS - 1;
        18: EnemySkillDistance := BOMB_RADIUS - 1;
        19: EnemySkillDistance := 8;
        20: EnemySkillDistance := VISE_RADIUS;
        21: EnemySkillDistance := MIND_RADIUS - 1;
        22: EnemySkillDistance := DEAFENING_RADIUS - 1;
        23: EnemySkillDistance := RAGE_RADIUS - 1;
        24: EnemySkillDistance := REPLICA_RADIUS - 1;
        25: EnemySkillDistance := STEAL_RADIUS - 2;
        26: EnemySkillDistance := EXILE_RADIUS - 1;
        27: EnemySkillDistance := SHOCK_RADIUS - 1
        else EnemySkillDistance := 0;
      end;
  Result := Max(SelfSkillDistance, EnemySkillDistance);}
end;


function Imprisoned(P: Integer): Boolean;
var
  aX, aY: Integer;
begin

  if not AI_ENABLED then
    Exit;

  if (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    Result := ((States.MapTileObject(aX - 1, aY - 1) = BOWMAN_OBJECT5)
              or (States.MapTileObject(aX + 1, aY - 1) = BOWMAN_OBJECT5)
              or (States.MapTileObject(aX + 1, aY + 1) = BOWMAN_OBJECT5)
              or (States.MapTileObject(aX - 1, aY + 1) = BOWMAN_OBJECT5))
              and (not States.ConnectedByWalking(aX, aY, CurrentMaxX, CurrentMaxY));
  end;

end;


procedure AIWalk(P: Integer);
var
  uX, uY, aX, aY: Integer;
begin

  if not AI_ENABLED then
    Exit;

  if States.GameTime mod 20 = P then
    if (Players[P].Hero > 0)
    and (not Players[P].CastingSkill)
    and (not Players[P].HeroReborn)
    and (not Players[P].AIKnightCombo)
    and (not Imprisoned(P)) then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if Players[P].AITarget <= 0 then
        Players[P].AITarget := FindEnemy(P, aX, aY, 48, False);
      if Players[P].AITarget > 0 then
      begin
        uX := States.UnitPositionX(Players[P].AITarget);
        uY := States.UnitPositionY(Players[P].AITarget);
        if TileOnBattlefield(uX, uY) then
        begin
          if (((uX - aX) * (uX - aX) + (uY - aY) * (uY - aY)) >= ClosestDistance(P) * ClosestDistance(P)) then
            Actions.GroupOrderWalk(Players[P].Hero, uX + States.KaMRandomI(4) - States.KaMRandomI(4), uY + States.KaMRandomI(4) - States.KaMRandomI(4), States.KaMRandomI(8))
          else
            Actions.GroupOrderHalt(Players[P].Hero);
        end;
      end;
    end;

end;


procedure AIEscapePrison(P: Integer);
var
  aX, aY: Integer;
begin

  if not AI_ENABLED then
    Exit;

  if States.GameTime mod 2 = 0 then
    if (Players[P].Hero > 0)
    and (not Players[P].CastingSkill)
    and (not Players[P].HeroStunned)
    and (States.PlayerIsAI(P))
    and (Imprisoned(P)) then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(2) - States.KaMRandomI(2), aY + States.KaMRandomI(2) - States.KaMRandomI(2), States.KaMRandomI(8));
    end;

end;


procedure AIWalkAfterSkill(P: Integer);
var
  aX, aY, uX, uY: Integer;
begin

  if not AI_ENABLED then
    Exit;

  if (Players[P].Hero > 0)
  and (not Players[P].HeroReborn) then
    if States.GameTime = Players[P].SkillTime then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if Players[P].AITarget <= 0 then
        Players[P].AITarget := FindEnemy(P, aX, aY, 48, False);
      if Players[P].AITarget > 0 then
      begin
        uX := States.UnitPositionX(Players[P].AITarget);
        uY := States.UnitPositionY(Players[P].AITarget);
        if TileOnBattlefield(uX, uY) then
          if (((uX - aX) * (uX - aX) + (uY - aY) * (uY - aY)) >= ClosestDistance(P) * ClosestDistance(P)) then
        begin
          if (((uX - aX) * (uX - aX) + (uY - aY) * (uY - aY)) >= ClosestDistance(P) * ClosestDistance(P)) then
            Actions.GroupOrderWalk(Players[P].Hero, uX + States.KaMRandomI(4) - States.KaMRandomI(4), uY + States.KaMRandomI(4) - States.KaMRandomI(4), States.KaMRandomI(8))
          else
            Actions.GroupOrderHalt(Players[P].Hero);
        end;
      end;
    end;

end;


procedure AIWalkIdle(P: Integer);
var
  aX, aY, uX, uY: Integer;
begin

  if not AI_ENABLED then
    Exit;

  if (Players[P].Hero > 0)
  and (States.GameTime mod 4 = P) then
    if (States.GroupIdle(Players[P].Hero))
    and (not Players[P].CastingSkill)
    and (Players[P].HeroType <> 15)
    and (not Players[P].HeroReborn)
    and (not Players[P].AIKnightCombo)
    and (not Imprisoned(P))
    and (States.PlayerIsAI(P)) then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if Players[P].AITarget <= 0 then
        Players[P].AITarget := FindEnemy(P, aX, aY, 48, False);
      if Players[P].AITarget > 0 then
      begin
        uX := States.UnitPositionX(Players[P].AITarget);
        uY := States.UnitPositionY(Players[P].AITarget);
        if TileOnBattlefield(uX, uY) then
          if (((uX - aX) * (uX - aX) + (uY - aY) * (uY - aY)) >= ClosestDistance(P) * ClosestDistance(P)) then
        begin
          if (((uX - aX) * (uX - aX) + (uY - aY) * (uY - aY)) >= ClosestDistance(P) * ClosestDistance(P)) then
            Actions.GroupOrderWalk(Players[P].Hero, uX + States.KaMRandomI(4) - States.KaMRandomI(4), uY + States.KaMRandomI(4) - States.KaMRandomI(4), States.KaMRandomI(8))
          else
            begin
              Actions.GroupOrderHalt(Players[P].Hero);
              Players[P].AITarget := -1;
            end;
        end;
      end;
    end;

end;


procedure AITakeHealingBush(P: Integer);
var
  X, Y, aX, aY: Integer;
begin
  if (Players[P].Hero <= 0)
  or (Players[P].CastingSkill)
  or (Players[P].HP = MAX_HP)
  or (Players[P].RegenDelay - States.GameTime > 0) then
    Exit;

  if States.GroupMember(Players[P].Hero, 0) <= 0 then
    Exit;

  if not AI_ENABLED then
    Exit;

  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

  for X := aX - HEAL_CHECK_RADIUS to aX + HEAL_CHECK_RADIUS do
  for Y := aY - HEAL_CHECK_RADIUS to aY + HEAL_CHECK_RADIUS do
    if TileOnBattlefield(X, Y) then
      if States.MapTileObject(X, Y) = VAGA_OBJECT then
        Actions.GroupOrderWalk(Players[P].Hero, X, Y, States.KaMRandomI(8));
end;


procedure ZombieStormLeft;
var
  GR: array of Integer;
  I, K, X1, X2, Y1, Y2, D1, D2, H, Z, DX, DY: Integer;
begin
  GR := States.PlayerGetAllGroups(11);
  if Length(PlayersLeft) > 0 then
    for I := 0 to Length(PlayersLeft) - 1 do
    begin
      H := Players[PlayersLeft[I]].Hero;
      if H > 0 then
      begin
        X1 := States.UnitPositionX(States.GroupMember(Players[PlayersLeft[I]].Hero, 0));
        Y1 := States.UnitPositionY(States.GroupMember(Players[PlayersLeft[I]].Hero, 0));
        D1 := States.UnitDirection(States.GroupMember(Players[PlayersLeft[I]].Hero, 0));
      end;
      if Length(GR) > 0 then
        for K := 0 to Length(GR) - 1 do
        begin
          Z := GR[K];
          if Z > 0 then
          begin
            X2 := States.UnitPositionX(States.GroupMember(Z, 0));
            Y2 := States.UnitPositionY(States.GroupMember(Z, 0));
            D2 := States.UnitDirection(States.GroupMember(Z, 0));
            if States.GroupIdle(Z) then
              Actions.GroupOrderWalk(Z, 25, 75, States.KaMRandomI(8));
            if States.GameTime mod IDLE_CHECK_TIME = 0 then
              Actions.GroupOrderWalk(Z, X2, Y2, States.KaMRandomI(8));
          end;
          DX := (X1 - X2) * (X1 - X2);
          DY := (Y1 - Y2) * (Y1 - Y2);
          if (DX + DY <= (STORM_CHECK_RADIUS * STORM_CHECK_RADIUS))
          and ((D1 = D2)
          or (Abs(D1 - D2) = 4))
          and (Z > 0)
          and (States.MapTileObject(X1, Y1) <> WARRIOR_OBJECT7)
          and (not Players[I].HeroTotalImmunity) then
            if (States.GroupType(Z) = 0)
            and (States.KaMRandom < STORM_CHANCE) then
              Actions.GroupOrderStorm(Z);
        end;
     end;
end;


procedure ZombieStormRight;
var
  GL: array of Integer;
  I, K, X1, X2, Y1, Y2, D1, D2, H, Z, DX, DY: Integer;
begin
  GL := States.PlayerGetAllGroups(10);
  if Length(PlayersRight) > 0 then
    for I := 0 to Length(PlayersRight) - 1 do
    begin
      H := Players[PlayersRight[I]].Hero;
      if H > 0 then
      begin
        X1 := States.UnitPositionX(States.GroupMember(Players[PlayersRight[I]].Hero, 0));
        Y1 := States.UnitPositionY(States.GroupMember(Players[PlayersRight[I]].Hero, 0));
        D1 := States.UnitDirection(States.GroupMember(Players[PlayersRight[I]].Hero, 0));
      end;
      if Length(GL) > 0 then
        for K := 0 to Length(GL) - 1 do
        begin
          Z := GL[K];
          if Z > 0 then
          begin
            X2 := States.UnitPositionX(States.GroupMember(Z, 0));
            Y2 := States.UnitPositionY(States.GroupMember(Z, 0));
            D2 := States.UnitDirection(States.GroupMember(Z, 0));
            if States.GroupIdle(Z) then
              Actions.GroupOrderWalk(Z, 45, 75, States.KaMRandomI(8));
            if States.GameTime mod IDLE_CHECK_TIME = 0 then
              Actions.GroupOrderWalk(Z, X2, Y2, States.KaMRandomI(8));
          end;
          DX := (X1 - X2) * (X1 - X2);
          DY := (Y1 - Y2) * (Y1 - Y2);
          if (DX + DY <= (STORM_CHECK_RADIUS * STORM_CHECK_RADIUS))
          and ((D1 = D2)
          or (Abs(D1 - D2) = 4))
          and (Z > 0)
          and (States.MapTileObject(X1, Y1) <> WARRIOR_OBJECT7)
          and (not Players[I].HeroTotalImmunity) then
            if (States.GroupType(Z) = 0)
            and (States.KaMRandom < STORM_CHANCE) then
              Actions.GroupOrderStorm(Z);
        end;
     end;
end;


function AICanUseSkills(P, UT: Integer): Boolean;
begin
  Result := False;
  if not InRange(UT, 15, 27) then
    Exit;
  if Players[P].Hero <= 0 then
    Exit;
  if States.GroupOwner(Players[P].Hero) <> P then
    Exit;
  if not AI_ENABLED then
    Exit;
  if States.PlayerEnabled(P) then
    if States.PlayerIsAI(P) then
      if (Players[P].Hero > 0)
      and (not Players[P].HeroReborn) then
        Result := ((Players[P].HeroType = UT)
                  and (Players[P].HP > 0)
                  and (TileOnBattlefield(States.UnitPositionX(States.GroupMember(Players[P].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[P].Hero, 0))))
                  and (not Players[P].HeroInFear)
                  and (not Players[P].HeroStunned)
                  and (not Players[P].HeroSilent));
end;


function CanUseSkillAgainstUnit(P, U: Integer): Boolean;
begin
  Result := True;
  if InRange(States.UnitOwner(U), 0, 7) then
    Result := (not Players[States.UnitOwner(U)].HeroMagicImmunity)
              and (not Players[States.UnitOwner(U)].HeroTotalImmunity)
              and (States.MapTileObject(States.UnitPositionX(U), States.UnitPositionY(U)) <> WARRIOR_OBJECT7);  
end;


procedure AIAxe(P: Integer);
var
  X, Y, aX, aY, U, O: Integer;
begin

  if not DEBUG_MODE then
    Exit;

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - 1) to (aX + 1) do
      for Y := (aY - 1) to (aY + 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          O := States.UnitOwner(U);
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1) then 
          begin
            Gravity(P, aX, aY);
            Exit;
          end;
        end;
      end;
    end;
end;


procedure AISword(P: Integer);
var
  X, Y, aX, aY, U: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    U := FindEnemy(P, aX, aY, 5, False);
    if U > 0 then
      if InRange(States.UnitOwner(U), 0, 7) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        if (X = aX)
        and (Y < (aY - 1)) then
          SpikedEarth(P, X, Y, 0);
        if (X = aX)
        and (Y > (aY + 1)) then
          SpikedEarth(P, X, Y, 4);
        if (Y = aY)
        and (X < (aX - 1)) then
          SpikedEarth(P, X, Y, 6);
        if (Y = aY)
        and (X > (aX + 1)) then
          SpikedEarth(P, X, Y, 2);
      end;
  end;

  if (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    ZombieSummon(P, aX + States.KaMRandomI(MILIZOMBIE_RADIUS) - States.KaMRandomI(MILIZOMBIE_RADIUS), aY + States.KaMRandomI(MILIZOMBIE_RADIUS) - States.KaMRandomI(MILIZOMBIE_RADIUS));
  end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, IN_FEAR_RADIUS, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, 5, False);
    if U > 0 then
    begin
      X := States.UnitPositionX(U);
      Y := States.UnitPositionY(U);
      Fear(P, X, Y);
    end;
  end;

  AIWalk(P);

  if (States.GameTime mod AI_RUNE_CHECK_TIME = 0)
  and (not RuneTaken) then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIBarb(P: Integer);
var
  aX, aY, U, X, Y, A, E, sX, sY: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, 7, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, 7, False);
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        if (X = aX)
        and (Y < (aY - 1)) then
          CrackingEarth(P, X, Y, 0);
        if (X = aX)
        and (Y > (aY + 1)) then
          CrackingEarth(P, X, Y, 4);
        if (Y = aY)
        and (X < (aX - 1)) then
          CrackingEarth(P, X, Y, 6);
        if (Y = aY)
        and (X > (aX + 1)) then
          CrackingEarth(P, X, Y, 2);
      end;
  end;

  if (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    A := CheckUnitsCount(P, aX, aY, RAGE_RADIUS, True, True);
    E := CheckUnitsCount(P, aX, aY, RAGE_RADIUS, True, False);
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, RAGE_RADIUS, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, RAGE_RADIUS, False);
    if (E > A)
    and (U > 0) then
      if (E > 1)
      or ((E = 1) and (U <> FindClosestEnemy(P, aX, aY, 2, True)) and (CanUseSkillAgainstUnit(P, U))) then
        WaveOfRage(P, aX, aY);
  end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, TOTEM_ADD_RADIUS, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, TOTEM_ADD_RADIUS, False);
    if U > 0 then
    begin
      X := States.UnitPositionX(U);
      Y := States.UnitPositionY(U);
      A := CheckUnitsCount(P, X, Y, TOTEM_RADIUS, True, True) + CheckUnitsCount(P, aX, aY, 1, True, True);
      E := CheckUnitsCount(P, X, Y, TOTEM_RADIUS, True, False) + CheckUnitsCount(P, aX, aY, 1, True, False);
      if (E > A)
      and (CanUseSkillAgainstUnit(P, U)) then
      begin
        sX := X;
        sY := Y;

        if (GroupIsMoving(States.UnitsGroup(U)))
        or (not States.GroupIdle(States.UnitsGroup(U))) then
        begin
          case States.UnitDirection(U) of
            0: begin
                 sX := X;
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            1: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            2: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y;
               end;

            3: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            4: begin
                 sX := X;
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            5: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            6: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y;
               end;

            7: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

          end;
        end;

        if (not InRange(sX, aX - TOTEM_RADIUS, aX + TOTEM_RADIUS))
        and (not InRange(sY, aY - TOTEM_RADIUS, aY + TOTEM_RADIUS))
        and (CanUseWineFieldSkill(sX, sY)) then
          TotemOfAncestors(P, sX, sY);

      end;
    end;
  end;

  AIWalk(P);

  if (States.GameTime mod AI_RUNE_CHECK_TIME = 0)
  and (not RuneTaken) then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AICrossbow(P: Integer);
var
  aX, aY, U, X, Y, sX, sY, A, E: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, 10, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, 10, False);
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        if (X = aX)
        and (Y < (aY - 1)) then
          AccurateShot(P, X, Y, 0);
        if (X = aX)
        and (Y > (aY + 1)) then
          AccurateShot(P, X, Y, 4);
        if (Y = aY)
        and (X < (aX - 1)) then
          AccurateShot(P, X, Y, 6);
        if (Y = aY)
        and (X > (aX + 1)) then
          AccurateShot(P, X, Y, 2);
      end;
  end;

  if (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, BOMB_RADIUS, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, BOMB_RADIUS, False);
    if U > 0 then
    begin
      X := States.UnitPositionX(U);
      Y := States.UnitPositionY(U);
      A := CheckUnitsCount(P, X, Y, 2, True, True);
      E := CheckUnitsCount(P, X, Y, 2, True, False);
      if (E > A)
      and (CanUseSkillAgainstUnit(P, U)) then
      begin
        sX := X;
        sY := Y;

        if (GroupIsMoving(States.UnitsGroup(U)))
        or (not States.GroupIdle(States.UnitsGroup(U))) then
        begin
          case States.UnitDirection(U) of
            0: begin
                 sX := X;
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            1: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            2: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y;
               end;

            3: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            4: begin
                 sX := X;
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            5: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            6: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y;
               end;

            7: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

          end;
        end;

        if (CanUseWineFieldSkill(sX, sY))
        and (not InRange(sX, aX - 3, aX + 3))
        and (not InRange(sY, aY - 3, aY + 3)) then
          SuddenDeath(P, sX, sY);

      end;
    end;
  end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (States.GameTime > CHOOSE_HERO_TIMER + 100)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, 48, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, 48, False);
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        if (X = aX)
        and (Y < (aY - 1)) then
          SniperShot(P, X, Y, 0);
        if (X = aX)
        and (Y > (aY + 1)) then
          SniperShot(P, X, Y, 4);
        if (Y = aY)
        and (X < (aX - 1)) then
          SniperShot(P, X, Y, 6);
        if (Y = aY)
        and (X > (aX + 1)) then
          SniperShot(P, X, Y, 2);
      end;
  end;

  AIWalk(P);

  if (States.GameTime mod AI_RUNE_CHECK_TIME = 0)
  and (not RuneTaken) then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIPikeman(P: Integer);
var
  X, Y, aX, aY, U, O, D, A, E: Integer;
begin

  if not DEBUG_MODE then
    Exit;

  if (States.KaMRandomI(10) > 5)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      A := 0;
      E := 0;
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      for X := (aX - VISE_RADIUS + 1) to (aX + VISE_RADIUS - 1) do
      for Y := (aY - VISE_RADIUS + 1) to (aY + VISE_RADIUS - 1) do
      begin
        U := States.UnitAt(X, Y);
        if (U > 0) then
        begin
          O := States.UnitOwner(U);
          if Players[P].PlayersTeam <> Players[O].PlayersTeam then
            E := E + 1;
          if Players[P].PlayersTeam = Players[O].PlayersTeam then
            A := A + 1;
          if (P <> O)
          and (CanUseSkillAgainstUnit(P, U))
          and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
          and (States.KaMRandom > 0.1)
          and (E > A) then 
          begin
            ViseOfDeath(P, aX, aY, D);
            Exit;
          end;
        end;
      end;
    end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (States.KaMRandom > 0.25) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    for X := aX - TOWER_RADIUS to aX + TOWER_RADIUS do
    for Y := aY - TOWER_RADIUS to aY + TOWER_RADIUS do
    begin
      U := States.UnitAt(X, Y);
      if U > 0 then
      begin
        O := States.UnitOwner(U);
        if (P <> O)
        and (Players[P].PlayersTeam <> Players[O].PlayersTeam) then
          if InRange(O, 0, 7) then
            InfernalTower(P, X + States.KaMRandomI(3) - States.KaMRandomI(3), Y + States.KaMRandomI(3) - States.KaMRandomI(3));
      end;
    end;
  end;


  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AILance(P: Integer);
var
  aX, aY, U, X, Y, uX, uY, aX1, aY1, R, D: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, 8, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, 8, False);
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        if (X = aX)
        and (Y < (aY - 1)) then
          FieryLance(P, X, Y, 0);
        if (X = aX)
        and (Y > (aY + 1)) then
          FieryLance(P, X, Y, 4);
        if (Y = aY)
        and (X < (aX - 1)) then
          FieryLance(P, X, Y, 6);
        if (Y = aY)
        and (X > (aX + 1)) then
          FieryLance(P, X, Y, 2);
      end;
  end;

  if (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].CastingSkill) then
    if (Players[P].RoadSkillDelay = 0)
    or (Players[P].WineSkillDelay = 0) then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      if Length(Zombies) > 0 then
        U := FindEnemy(P, aX, aY, TELEPORT_RADIUS, Boolean(States.KaMRandomI(2)))
      else
        U := FindEnemy(P, aX, aY, TELEPORT_RADIUS, False);
      if U > 0 then
        if CanUseSkillAgainstUnit(P, U) then
        begin
          X := States.UnitPositionX(U);
          Y := States.UnitPositionY(U);
          R := States.KaMRandomI(8);
          case R of

            0: begin
                 aX1 := X;
                 aY1 := Y + 2;
                 D := 0;
               end;

            1: begin
                 aX1 := X;
                 aY1 := Y - 2;
                 D := 4;
               end;

            2: begin
                 aX1 := X + 2;
                 aY1 := Y;
                 D := 6;
               end;

            3: begin
                 aX1 := X - 2;
                 aY1 := Y;
                 D := 2;
               end;

            4: begin
                 aX1 := X + 1;
                 aY1 := Y + 1;
                 D := 0;
               end;

            5: begin
                 aX1 := X - 1;
                 aY1 := Y - 1;
                 D := 4;
               end;

            6: begin
                 aX1 := X + 1;
                 aY1 := Y - 1;
                 D := 6;
               end;

            7: begin
                 aX1 := X - 1;
                 aY1 := Y + 1;
                 D := 2;
               end;

          end;

          if TileOnBattlefield(aX1, aY1) then
            if (not TileIsDangerous(P, aX1, aY1))
            and (Tiles[aX1][aY1].Skill = sNone) then
            begin
              Players[P].SkillCastDir := D;
              if Players[P].RoadSkillDelay = 0 then
              begin
                Teleport(P, aX1, aY1);
                FieryLance(P, aX1, aY1, D);
              end;
              if Players[P].WineSkillDelay = 0 then
              begin
                Teleport(P, aX1, aY1);
                TenThousandsSpears(P, aX1, aY1, D);
              end;
           end;
         end;
    end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, 20, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, 20, False);
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        if (InRange(uX, aX - 1, aX + 1))
        and (Y < aY) then
          TenThousandsSpears(P, X, Y, 0);
        if (InRange(uX, aX - 1, aX + 1))
        and (Y > aY) then
          TenThousandsSpears(P, X, Y, 4);
        if (InRange(uY, aY - 1, aY + 1))
        and (X < aX) then
          TenThousandsSpears(P, X, Y, 6);
        if (InRange(uY, aY - 1, aY + 1))
        and (X > aX) then
          TenThousandsSpears(P, X, Y, 2);
      end;
  end;

  AIWalk(P);

  if (States.GameTime mod AI_RUNE_CHECK_TIME = 0)
  and (not RuneTaken) then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIWarrior(P: Integer);
var
  aX, aY, O, U, X, Y, uX, uY, aX1, aX2, aY1, aY2: Integer;
begin

  if not DEBUG_MODE then
    Exit;

  if (States.KaMRandomI(10) > 7)
  and (States.KaMRandom < 0.25)
  and (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and not (Players[P].CastingSkill) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

      case States.UnitDirection(States.GroupMember(Players[P].Hero, 0)) of

        0, 1: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY - 10;
                aY2 := aY - 1;
              end;

        4, 5: begin
                aX1 := aX - 1;
                aX2 := aX + 1;
                aY1 := aY + 1;
                aY2 := aY + 10;
              end;

        2, 3: begin
                aX1 := aX + 1;
                aX2 := aX + 10;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

        6, 7: begin
                aX1 := aX - 10;
                aX2 := aX - 1;
                aY1 := aY - 1;
                aY2 := aY + 1;
              end;

      end;

      for X := aX1 to aX2 do
      for Y := aY1 to aY2 do
        if TileOnBattlefield(X, Y) then
        begin
          U := States.UnitAt(X, Y);
          if U > 0 then
          begin
            O := States.UnitOwner(U);
            if (P <> O)
            and (CanUseSkillAgainstUnit(P, U))
            and (Players[P].PlayersTeam <> Players[O].PlayersTeam)
            and (States.KaMRandom > 0.1) then 
            begin
              uX := States.UnitPositionX(U);
              uY := States.UnitPositionY(U);
              if ((InRange(uX, aX - 1, aX + 1)) and (uY < aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 0, 1))) then
              begin
                FierySnake(P, aX, aY, 0);
                Exit;
              end;
              if ((InRange(uX, aX - 1, aX + 1)) and (uY > aY) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 4, 5))) then
              begin
                FierySnake(P, aX, aY, 4);
                Exit;
              end;
              if ((uX < aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 6, 7))) then
              begin
                FierySnake(P, aX, aY, 6);
                Exit;
              end;
              if ((uX > aX) and (InRange(uY, aY - 1, aY + 1)) and (InRange(States.UnitDirection(States.GroupMember(Players[P].Hero, 0)), 2, 3))) then
              begin
                FierySnake(P, aX, aY, 2);
                Exit;
              end;
            end;
        end;
      end;
    end;

  AIWalk(P);

  if States.GameTime mod AI_RUNE_CHECK_TIME = 0 then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIBowman(P: Integer);
var
  X, Y, aX, aY, U, U1, U2, U3, U4, sX, sY, A, E: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill)
  and (Players[P].RocketCharges > 1) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, ROCKET_USAGE_RADIUS, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, ROCKET_USAGE_RADIUS, False);
    if U > 0 then
    begin
      X := States.UnitPositionX(U);
      Y := States.UnitPositionY(U);
      A := CheckUnitsCount(P, X, Y, 2, True, True);
      E := CheckUnitsCount(P, X, Y, 2, True, False);
      if (E > A)
      and (CanUseSkillAgainstUnit(P, U)) then
      begin
        sX := X;
        sY := Y;

        if (GroupIsMoving(States.UnitsGroup(U)))
        or (not States.GroupIdle(States.UnitsGroup(U))) then
        begin
          case States.UnitDirection(U) of
            0: begin
                 sX := X;
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            1: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            2: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y;
               end;

            3: begin
                 sX := X + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            4: begin
                 sX := X;
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            5: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y + 1 + States.KaMRandomI(3) + Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

            6: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y;
               end;

            7: begin
                 sX := X - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
                 sY := Y - 1 - States.KaMRandomI(3) - Byte(States.GroupType(States.UnitsGroup(U)) = 3);
               end;

          end;
        end;

        if (not InRange(sX, aX - 3, aX + 3))
        and (not InRange(sY, aY - 3, aY + 3)) then
          LaunchRocket(P, sX, sY);

      end;
    end;
  end;

  if (Players[P].FieldSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    if Length(Zombies) > 0 then
      U := FindEnemy(P, aX, aY, PRISON_USAGE_RADIUS, Boolean(States.KaMRandomI(2)))
    else
      U := FindEnemy(P, aX, aY, PRISON_USAGE_RADIUS, False);
    if U > 0 then
    begin
      X := States.UnitPositionX(U);
      Y := States.UnitPositionY(U);
      if (CanUseWineFieldSkill(X, Y))
      and (not InRange(sX, aX - 3, aX + 3))
      and (not InRange(sY, aY - 3, aY + 3)) then
      begin
        Prison(P, X, Y);
        if (Players[P].RoadSkillDelay = 0)
        and (CanUseSkillAgainstUnit(P, U)) then
          LaunchRocket(P, X, Y);
      end;
    end;
  end;

  if (Players[P].WineSkillDelay = 0)
  and (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (not Players[P].CastingSkill) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    U := FindEnemy(P, aX, aY, 17, Boolean(States.KaMRandom > 0.5));
    U1 := FindEnemy(P, aX + 15, aY, EXP_RADIUS, Boolean(States.KaMRandom > 0.5));
    U2 := FindEnemy(P, aX - 15, aY, EXP_RADIUS, Boolean(States.KaMRandom > 0.5));
    U3 := FindEnemy(P, aX, aY + 15, EXP_RADIUS, Boolean(States.KaMRandom > 0.5));
    U4 := FindEnemy(P, aX, aY - 15, EXP_RADIUS, Boolean(States.KaMRandom > 0.5));
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        X := States.UnitPositionX(U);
        Y := States.UnitPositionY(U);
        A := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, True);
        E := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, False);
        if (X = aX)
        and (Y < (aY - 1))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 0);
        if (X = aX)
        and (Y > (aY + 1))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 4);
        if (Y = aY)
        and (X < (aX - 1))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 6);
        if (Y = aY)
        and (X > (aX + 1))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 2);
      end;
    if U1 > 0 then
      if CanUseSkillAgainstUnit(P, U1) then
      begin
        X := States.UnitPositionX(U1);
        Y := States.UnitPositionY(U1);
        A := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, True);
        E := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, False);
        if (InRange(aY, Y - 3, Y + 3))
        and (InRange(aX, X + 13, X + 17))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 6);
      end;
    if U2 > 0 then
      if CanUseSkillAgainstUnit(P, U2) then
      begin
        X := States.UnitPositionX(U2);
        Y := States.UnitPositionY(U2);
        A := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, True);
        E := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, False);
        if (InRange(aY, Y - 3, Y + 3))
        and (InRange(aX, X - 17, X - 13))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 2);
      end;
    if U3 > 0 then
      if CanUseSkillAgainstUnit(P, U3) then
      begin
        X := States.UnitPositionX(U3);
        Y := States.UnitPositionY(U3);
        A := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, True);
        E := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, False);
        if (InRange(aX, X - 3, X + 3))
        and (InRange(aY, Y + 13, Y + 17))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 4);
      end;
    if U4 > 0 then
      if CanUseSkillAgainstUnit(P, U4) then
      begin
        X := States.UnitPositionX(U4);
        Y := States.UnitPositionY(U4);
        A := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, True);
        E := CheckUnitsCount(P, X, Y, EXP_RADIUS, True, False);
        if (InRange(aX, X - 3, X + 3))
        and (InRange(aY, Y - 17, Y - 13))
        and (E > A) then
          RevengeFromNowhere(P, X, Y, 0);
      end;
  end;

  AIWalk(P);

  if (States.GameTime mod AI_RUNE_CHECK_TIME = 0)
  and (not RuneTaken) then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

end;


procedure AIKnight(P: Integer);
var
  aX, aY, uX, uY, U, A, E, D: Integer;
begin

  if (Players[P].RoadSkillDelay = 0)
  and (Players[P].WineSkillDelay = 0)
  and (Players[P].FieldSkillDelay = 0)
  and (not Players[P].HeroReborn)
  and (Players[P].Hero > 0) then
    if States.GroupMember(Players[P].Hero, 0) > 0 then
    begin
      D := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      A := CheckUnitsCount(P, aX, aY, DEAFENING_RADIUS, False, True);
      E := CheckUnitsCount(P, aX, aY, DEAFENING_RADIUS, False, False);
      U := FindEnemy(P, aX, aY, DEAFENING_RADIUS - 1, False);
      if (E > A)
      and (U > 0)
      and (D mod 2 = 0) then
        if (E > 1)
        or ((E = 1) and (U <> FindClosestEnemy(P, aX, aY, 2, False)) and (CanUseSkillAgainstUnit(P, U))) then
        begin
          Actions.GroupOrderWalk(Players[P].Hero, aX, aY, D);
          Actions.GroupOrderHalt(Players[P].Hero);
          DeafeningClatter(P, aX, aY);
          Players[P].AIThreadsTime := States.GameTime + 10;
          Players[P].AIKnightCombo := True;
          Players[P].AIKnightComboTime := States.GameTime + 20;
        end;
    end;

  if (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (Players[P].RoadSkillDelay = 0)
  and (States.GameTime = Players[P].AIThreadsTime) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    U := FindEnemy(P, aX, aY, DEAFENING_RADIUS - 1, False);
    if U > 0 then
      if CanUseSkillAgainstUnit(P, U) then
      begin
        uX := States.UnitPositionX(U);
        uY := States.UnitPositionY(U);
        ThreadsOfDeath(P, uX, uY);
        Players[P].AISpurtTime := States.GameTime + 10;
      end;
  end;

  if (Players[P].Hero > 0)
  and (not Players[P].HeroReborn)
  and (Players[P].WineSkillDelay = 0)
  and (States.GameTime = Players[P].AISpurtTime) then
  begin
    aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
    aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
    RagingSpurt(P, aX, aY);
    Players[P].AIKnightCombo := False;
  end;

  AIWalk(P);

  if (States.GameTime mod AI_RUNE_CHECK_TIME = 0)
  and (not RuneTaken) then
    AITakeRune(P);

  if States.GameTime mod HEAL_CHECK_TIME = 0 then
    AITakeHealingBush(P);

  Exit;

end;


procedure OnHouseDestroyed(H, D: Integer);
var
  Units: array of Integer;
  I, Owner, aHome: Integer;
begin
  Owner := States.HouseOwner(H);
  Units := States.PlayerGetAllUnits(Owner);
  if Length(Units) > 0 then
    for I := 0 to Length(Units) - 1 do
      if (States.UnitType(Units[I]) = 13) then
      begin
        aHome := States.UnitHome(Units[I]);
        if (H = States.UnitHome(Units[I]))
        or (aHome = -1) then
          Actions.UnitKill(Units[I], True);
      end;
end;


procedure OnHouseAfterDestroyed(T, O, X, Y: Integer);
var
  X1, Y1: Integer;
begin
  Actions.MapTileObjectSet(X, Y, 255);

  for X1 := X - 1 to X do
  for Y1 := Y - 1 to Y do
    if (InRange(X1, MIN_X, MAX_X))
    and (InRange(Y1, MIN_Y, MAX_Y))
    and (States.MapTileType(X1, Y1) <> 202) then
    begin
      Actions.GiveRoad(10, X1, Y1);
      Actions.RemoveRoad(X1, Y1);
    end;

  for X1 := X - 2 to X + 1 do
  for Y1 := Y - 2 to Y + 1 do
    if (InRange(X1, MIN_X, MAX_X))
    and (InRange(Y1, MIN_Y, MAX_Y)) then
    begin
      Actions.MapTileSet(X1, Y1, Tiles[X1][Y1].TileType, Tiles[X1][Y1].TileDirection);
      if Tiles[X1][Y1].Skill = sTower then
        Tiles[X1][Y1].Skill := sNone;
    end;

  CheckTileCleanup(False);

  RegenRelief;

end;


procedure CancelSkillMindSilent(P: Integer);
begin
  if States.GameTime = Players[P].CancelSkillMindSilent then
  begin
    Actions.GroupKillAll(Players[P].Hero, True);
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[M[P]].MindX, Players[M[P]].MindY, Players[M[P]].MindDir, 1, 1);
  end;
end;


procedure CheckTiles(P: Integer);
var
  I, K, T, aX, aY, aObj, aTile, aTime, Z, Module: Integer;
begin
  try
    aObj := -1;
    aTile := -1;

    if Players[P].Hero <= 0 then
      Exit;
    if States.GroupMember(Players[P].Hero, 0) <= 0 then
      Exit;

    Module := 0;
    if Players[P].Hero > 0 then
      if not States.GroupDead(Players[P].Hero) then
      begin
        aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
        aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      end;

    if not InRange(aX, MIN_X, MAX_X) then
      Exit;
    if not InRange(aY, MIN_Y, MAX_Y) then
      Exit;

    Module := 1;
    if (TileOnBattlefield(aX, aY))
    or ((aX = RUNE_X)
    and (aY = RUNE_Y))
    or (Tiles[aX][aY].Owner = TEMP_PLAYER)
    or ((not TileOnBattlefield(aX, aY))
    and (States.MapTileType(aX, aY) = INFERNAL_TILE)) then
    begin
      aObj := States.MapTileObject(aX, aY);
      aTile := States.MapTileType(aX, aY);
      aTime := Tiles[aX][aY].ShieldTime;
    end;

    if aObj = PikeObjects[P] then
      Exit;
    if aObj = -1 then
      Exit;
    if aTile = -1 then
      Exit;

    Module := 2;
    if (aTile = INFERNAL_TILE)
    and (Tiles[aX][aY].Owner = TEMP_PLAYER)
    and (Tiles[aX][aY].Skill = sBorder) then
    begin
      Actions.PlayWAV(P, 'GorenjePerdaka', 1);
      Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
      Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$147>';
      for I := 0 to 7 do
        if I <> P then
        begin
          Players[I].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[I].PlayerStatus := Players[I].PlayerStatus + '|[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[] <$146>';
        end;
    end;

    if (aTile = INFERNAL_TILE)
    and (aTime > States.GameTime)
    and (InRange(Tiles[aX][aY].Owner, 0, 7)) then
      Exit;

    Module := 3;
    if (ObjectType(aObj) = otKill)
    or (aTile = INFERNAL_TILE) then
    begin
      T := Players[P].HeroType;
      if (not States.PlayerDefeated(P))
      and (((not Players[P].HeroMagicImmunity)
      and (not Players[P].HeroTotalImmunity)
      and (InRange(Tiles[aX][aY].Owner, 0, 7))
      or (Tiles[aX][aY].Owner = TEMP_PLAYER))) then
      begin
        Module := 4;
        if Players[P].HP > 0 then
        begin
          Actions.GroupKillAll(Players[P].Hero, False);
          if Players[P].MindStunned then
            Players[M2[P]].RebornMindTime := States.GameTime + REBORN_TIME;
          Players[P].HeroReborn := True;
          Players[P].RebornTime := States.GameTime + REBORN_TIME;
          Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), T, Players[P].TempX, Players[P].TempY, 4, 1, 1);
          Players[P].HeroInFearTime := 0;
          if (not Players[P].CaptureMind)
          and (not Players[P].MindStunned) then
            Players[P].HeroStunnedTime := 0;
          Players[P].HeroSilentTime := 0;
          Players[P].PreparingTime := 0;
          Players[P].DDTime := 0;
          Players[P].ReChargeTime := 0;

          if (Tiles[aX][aY].Skill = sRocket)
          and (Tiles[aX][aY].Owner = P)
          and (States.GameTime < Players[P].RoadSkillCancelTime) then
            Players[P].RoadSkillCancelTime := 0;

          Module := 5;
          if States.GameTime < Players[P].MindTime2 then
          begin
            Players[P].MindTime2 := 0;
            Players[P].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
            Players[P].CaptureMind := False;
            Players[M[P]].MindStunned := False;
          end;
        
          Module := 6;
          if (InRange(M2[P], 0, 7)) then
            if States.GameTime < Players[M2[P]].MindTime2 then
            begin
              Players[M2[P]].MindTime2 := 0;
              Players[M2[P]].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[M2[P]].ReCharge)));
              Players[M2[P]].CaptureMind := False;
              Players[P].MindStunned := False;
              Actions.GroupBlockOrders(Players[M2[P]].Hero, False);
            end;

            Module := 7;
            if TilesRoadLength[P] > 0 then
              for I := 0 to TilesRoadLength[P] - 1 do
                if (SetTilesRoadTimes[P][I] > States.GameTime)
                and (States.GameTime <= Players[P].RoadSkillCancelTime) then
                begin
                  SetTilesRoadTimes[P][I] := 0;
                  TilesRoadObjects[P][I] := SKILL_CANCEL_OBJ;
                end;

          if TilesFieldLength[P] > 0 then
            for I := 0 to TilesFieldLength[P] - 1 do
              if (SetTilesFieldTimes[P][I] > States.GameTime)
              and (States.GameTime <= Players[P].FieldSkillCancelTime) then
              begin
                SetTilesFieldTimes[P][I] := 0;
                TilesFieldObjects[P][I] := SKILL_CANCEL_OBJ;
              end;

          if TilesWineLength[P] > 0 then
            for I := 0 to TilesWineLength[P] - 1 do
              if (SetTilesWineTimes[P][I] > States.GameTime)
              and (States.GameTime <= Players[P].WineSkillCancelTime) then
              begin
                SetTilesWineTimes[P][I] := 0;
                TilesWineObjects[P][I] := SKILL_CANCEL_OBJ;
              end;

          if (InRange(M2[P], 0, 7))
          and Players[M2[P]].MindStunned then
            if TilesWineLength[M2[P]] > 0 then
              for I := 0 to TilesWineLength[M2[P]] - 1 do
                if (SetTilesWineTimes[M2[P]][I] > States.GameTime)
                and (States.GameTime <= Players[M2[P]].WineSkillCancelTime) then
                begin
                  SetTilesWineTimes[M2[P]][I] := 0;
                  TilesWineObjects[M2[P]][I] := SKILL_CANCEL_OBJ;
                end;

          Module := 8;
          for I := 0 to 7 do
          begin

            if Players[I].ThreadsAttacker = P then
              Players[I].ThreadsAttacker := -1;

            if Players[I].ScoutSilenceGiver = P then
              Players[I].ScoutSilenceGiver := -1;

            if Players[I].HeroExileGiver = P then
              Players[I].HeroExileGiver := -1;

            if (Players[I].ThreadsTarget = P)
            and (Players[P].ThreadsTime - States.GameTime > DELAY_OF_TURNING * 2) then
            begin
              Players[P].ThreadsTime := 0;
              Players[P].MovedByThreads := False;
              Players[I].ThreadsTarget := -1;
            end;

          end;

          Module := 9;
          Players[P].TrackStartTime := 0;
          Players[P].TrackStopTime := 0;
          Players[P].SettingTrack := False;
          Players[P].HeroExileTime := 0;
          Players[P].HeroExileBackTime := 0;
          Players[P].HeroExiled := False;
          Players[P].TowerTime := 0;
          Players[P].ReplicaTime := 0;
          Players[P].RiftTime := 0;
          Players[P].MirrorTime := 0;
          RuneCleanupTime[P] := 0;
          Players[P].ThreadsAttackTime := 0;
          if InRange(Players[P].ThreadsTarget, 0, 7) then
            Players[Players[P].ThreadsTarget].ThreadsTime := 0;
          Players[P].ThreadsTime := 0;
          Players[P].ThreadsTarget := -1;

          Module := 10;
          if (InRange(Players[P].WerewolfTime - States.GameTime, 0, 49))
          and (InRange(Players[P].TempHeroType, 14, 27)) then
          begin
            Players[P].HeroType := Players[P].TempHeroType;
            Players[P].WerewolfTime := 0;
            Players[P].RoadSkillDelay := 0;
            Players[P].FieldSkillDelay := 0;
            Players[P].WineSkillDelay := AXE_WINE_DELAY * (1 - Round(RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - WEREWOLF_TIME;
          end;

          Module := 11;
          if (InRange(Players[P].MindAppearTimeBack - States.GameTime, 0, 49))
          and (InRange(Players[P].TempHeroType, 14, 27)) then
          begin
            Players[P].HeroType := Players[P].TempHeroType;
            Players[P].MindAppearTimeBack := 0;
          end;

          Module := 12;
          for K := 0 to SPURT_LENGTH - 1 do
            SpurtTimes[P][K] := 0;

          Module := 13;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to TotemCirclesLength[P][K] - 1 do
              if (TotemCircles[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].WineSkillCancelTime)
              and (TotemCircles[P][K][I].Obj <> 255) then
                TotemCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 14;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to ExpCirclesLength[P][K] - 1 do
              if (ExpCircles[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].WineSkillCancelTime)
              and (ExpCircles[P][K][I].Obj <> 255) then
                ExpCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 15;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to RogueCirclesLength[P][K] - 1 do
              if (RogueCircles[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].RoadSkillCancelTime)
              and (RogueCircles[P][K][I].Obj <> 255) then
                RogueCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 16;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to StolenRogueCirclesLength[P][K] - 1 do
              if (StolenRogueCircles[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].RoadSkillCancelTime)
              and (StolenRogueCircles[P][K][I].Obj <> 255) then
                StolenRogueCircles[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 17;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to FireworksCircles1Length[P][K] - 1 do
              if (FireworksCircles1[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].FieldSkillCancelTime)
              and (FireworksCircles1[P][K][I].Obj <> 255) then
                FireworksCircles1[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 18;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to FireworksCircles2Length[P][K] - 1 do
              if (FireworksCircles2[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].FieldSkillCancelTime)
              and (FireworksCircles2[P][K][I].Obj <> 255) then
                FireworksCircles2[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 19;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to FireworksCircles3Length[P][K] - 1 do
              if (FireworksCircles3[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].FieldSkillCancelTime)
              and (FireworksCircles3[P][K][I].Obj <> 255) then
                FireworksCircles3[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 20;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to FireworksCircles4Length[P][K] - 1 do
              if (FireworksCircles4[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].FieldSkillCancelTime)
              and (FireworksCircles4[P][K][I].Obj <> 255) then
                FireworksCircles4[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 21;
          for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
            for I := 0 to FireworksCircles5Length[P][K] - 1 do
              if (FireworksCircles5[P][K][I].AddTime > States.GameTime)
              and (States.GameTime <= Players[P].FieldSkillCancelTime)
              and (FireworksCircles5[P][K][I].Obj <> 255) then
                FireworksCircles5[P][K][I].Obj := SKILL_CANCEL_OBJ;

          Module := 22;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if (SkillName(Tiles[aX][aY].Skill) <> '')
            and (Tiles[aX][aY].Skill <> sTower) then
            begin
              Module := 23;
              if (Tiles[aX][aY].Owner <> P)
              and (not Players[P].MindStunned)then
              begin
                Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[Tiles[aX][aY].Owner].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$67> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
                Players[Tiles[aX][aY].Owner].PlayerStatus := Players[Tiles[aX][aY].Owner].PlayerStatus + '|<$84> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]<$93> ' + SkillName(Tiles[aX][aY].Skill);
              end;
              Module := 24;
              if (Tiles[aX][aY].Owner = P)
              and (not Players[P].MindStunned)
              and (Tiles[aX][aY].Skill <> sBorder) then
              begin
                Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$82> ' + SkillName(Tiles[aX][aY].Skill);
              end;
              Module := 25;
              if (Tiles[aX][aY].Owner = M2[P])
              and (Players[P].MindStunned)
              and (Tiles[aX][aY].Skill <> sBorder) then
              begin
                Players[M2[P]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[M2[P]].PlayerStatus := Players[M2[P]].PlayerStatus + '|<$82> ' + SkillName(Tiles[aX][aY].Skill);
              end;
            end;
            Module := 26;
            if Tiles[aX][aY].Skill = sTower then
            begin
              if (Tiles[aX][aY].Owner <> P)
              and (not Players[P].MindStunned) then
              begin
                Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[Tiles[aX][aY].Owner].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$118> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner);
                Players[Tiles[aX][aY].Owner].PlayerStatus := Players[Tiles[aX][aY].Owner].PlayerStatus + '|<$119> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P);
              end;
              if (Tiles[aX][aY].Owner = P)
              and (not Players[P].MindStunned) then
              begin
                Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$117>';
              end;
              if (Tiles[aX][aY].Owner = M2[P])
              and (Players[P].MindStunned) then
              begin
                Players[M2[P]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                Players[M2[P]].PlayerStatus := Players[M2[P]].PlayerStatus + '|<$117>';
              end;
            end;
            Module := 27;
            if (P <> Tiles[aX][aY].Owner)
            and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam) then
              for I := 0 to 7 do
                if Players[I].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam then
                  Actions.PlayWAV(I, 'Retard', 1);
            Module := 28;
            if (P <> Tiles[aX][aY].Owner)
            and (Players[P].PlayersTeam <> Players[Tiles[aX][aY].Owner].PlayersTeam) then
            begin
              Players[Tiles[aX][aY].Owner].Kills := Players[Tiles[aX][aY].Owner].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
              Players[Tiles[aX][aY].Owner].KillStreak := Players[Tiles[aX][aY].Owner].KillStreak + 1;
              SetLength(Players[Tiles[aX][aY].Owner].KillTimes, Length(Players[Tiles[aX][aY].Owner].KillTimes) + 1);
              Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] := States.GameTime;
              Module := 29;
              if Length(Players[Tiles[aX][aY].Owner].KillTimes) >= 4 then
                if (Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] - Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 4] <= RAMPAGE_CHECK_TIME) then
                begin
                  Actions.PlayWAV(-1, 'Rampage', 1);
                  Players[Tiles[aX][aY].Owner].Rampage := True;
                  Players[Tiles[aX][aY].Owner].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 30;
              if Length(Players[Tiles[aX][aY].Owner].KillTimes) >= 3 then
                if (Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] - Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
                and (not Players[Tiles[aX][aY].Owner].TripleKill)
                and (not Players[Tiles[aX][aY].Owner].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'TripleKill', 1);
                  Players[Tiles[aX][aY].Owner].TripleKill := True;
                  Players[Tiles[aX][aY].Owner].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 31;
              if Length(Players[Tiles[aX][aY].Owner].KillTimes) >= 2 then
                if (Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 1] - Players[Tiles[aX][aY].Owner].KillTimes[Length(Players[Tiles[aX][aY].Owner].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
                and (not Players[Tiles[aX][aY].Owner].DoubleKill)
                and (not Players[Tiles[aX][aY].Owner].TripleKill)
                and (not Players[Tiles[aX][aY].Owner].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'DoubleKill', 1);
                  Players[Tiles[aX][aY].Owner].DoubleKill := True;
                  Players[Tiles[aX][aY].Owner].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
            end;
            Module := 32;
            if (Players[P].HeroInFear)
            and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam) then
            begin
              Players[Players[P].HeroFearGiver].Kills := Players[Players[P].HeroFearGiver].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
              Players[Players[P].HeroFearGiver].KillStreak := Players[Players[P].HeroFearGiver].KillStreak + 1;
              SetLength(Players[Players[P].HeroFearGiver].KillTimes, Length(Players[Players[P].HeroFearGiver].KillTimes) + 1);
              Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] := States.GameTime;
              Module := 33;
              if Length(Players[Players[P].HeroFearGiver].KillTimes) >= 4 then
                if (Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] - Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 4] <= RAMPAGE_CHECK_TIME) then
                begin
                  Actions.PlayWAV(-1, 'Rampage', 1);
                  Players[Players[P].HeroFearGiver].Rampage := True;
                  Players[Players[P].HeroFearGiver].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 34;
              if Length(Players[Players[P].HeroFearGiver].KillTimes) >= 3 then
                if (Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] - Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
                and (not Players[Players[P].HeroFearGiver].TripleKill)
                and (not Players[Players[P].HeroFearGiver].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'TripleKill', 1);
                  Players[Players[P].HeroFearGiver].TripleKill := True;
                  Players[Players[P].HeroFearGiver].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 35;
              if Length(Players[Players[P].HeroFearGiver].KillTimes) >= 2 then
                if (Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 1] - Players[Players[P].HeroFearGiver].KillTimes[Length(Players[Players[P].HeroFearGiver].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
                and (not Players[Players[P].HeroFearGiver].DoubleKill)
                and (not Players[Players[P].HeroFearGiver].TripleKill)
                and (not Players[Players[P].HeroFearGiver].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'DoubleKill', 1);
                  Players[Players[P].HeroFearGiver].DoubleKill := True;
                  Players[Players[P].HeroFearGiver].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
            end;
            Module := 36;
            if (Players[P].MovedByGravity)
            and (Players[P].PlayersTeam = Players[Players[P].GravityUser].PlayersTeam)
            and (P <> Players[P].GravityUser) then
              for I := 0 to 7 do
                if Players[I].PlayersTeam = Players[Players[P].GravityUser].PlayersTeam then
                  Actions.PlayWAV(I, 'Retard', 1);
            Module := 37;
            if (Players[P].MovedByGravity)
            and (Players[P].PlayersTeam <> Players[Players[P].GravityUser].PlayersTeam)
            and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam)
            and (InRange(Players[P].GravityUser, 0, 7))
            and (InRange(Tiles[aX][aY].Owner, 0, 7)) then
            begin
              Players[Players[P].GravityUser].Kills := Players[Players[P].GravityUser].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
              Players[Players[P].GravityUser].KillStreak := Players[Players[P].HeroFearGiver].KillStreak + 1;
              SetLength(Players[Players[P].GravityUser].KillTimes, Length(Players[Players[P].GravityUser].KillTimes) + 1);
              Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] := States.GameTime;
              Module := 38;
              if Length(Players[Players[P].GravityUser].KillTimes) >= 4 then
                if (Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] - Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 4] <= RAMPAGE_CHECK_TIME) then
                begin
                  Actions.PlayWAV(-1, 'Rampage', 1);
                  Players[Players[P].GravityUser].Rampage := True;
                  Players[Players[P].GravityUser].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 39;
              if Length(Players[Players[P].GravityUser].KillTimes) >= 3 then
                if (Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] - Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
                and (not Players[Players[P].GravityUser].TripleKill)
                and (not Players[Players[P].GravityUser].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'TripleKill', 1);
                  Players[Players[P].GravityUser].TripleKill := True;
                  Players[Players[P].GravityUser].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 40;
              if Length(Players[Players[P].GravityUser].KillTimes) >= 2 then
                if (Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 1] - Players[Players[P].GravityUser].KillTimes[Length(Players[Players[P].GravityUser].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
                and (not Players[Players[P].GravityUser].DoubleKill)
                and (not Players[Players[P].GravityUser].TripleKill)
                and (not Players[Players[P].GravityUser].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'DoubleKill', 1);
                  Players[Players[P].GravityUser].DoubleKill := True;
                  Players[Players[P].GravityUser].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
            end;
            Module := 41;
            if (Players[P].MovedByThreads)
            and (InRange(Players[P].ThreadsAttacker, 0, 7))
            and (Players[P].PlayersTeam = Players[Players[P].ThreadsAttacker].PlayersTeam)
            and (P <> Players[P].ThreadsAttacker) then
              for I := 0 to 7 do
                if Players[I].PlayersTeam = Players[Players[P].ThreadsAttacker].PlayersTeam then
                  Actions.PlayWAV(I, 'Retard', 1);
            Module := 42;
            if (Players[P].MovedByThreads)
            and (Players[P].PlayersTeam <> Players[Players[P].ThreadsAttacker].PlayersTeam)
            and (Players[P].PlayersTeam = Players[Tiles[aX][aY].Owner].PlayersTeam) then
            begin
              Players[Players[P].ThreadsAttacker].Kills := Players[Players[P].ThreadsAttacker].Kills + 1 + (Byte(Players[Tiles[aX][aY].Owner].DD) * Byte(Players[P].HP >= 2));
              Players[Players[P].ThreadsAttacker].KillStreak := Players[Players[P].ThreadsAttacker].KillStreak + 1;
              SetLength(Players[Players[P].ThreadsAttacker].KillTimes, Length(Players[Players[P].ThreadsAttacker].KillTimes) + 1);
              Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 1] := States.GameTime;
              Module := 43;
              if Length(Players[Players[P].ThreadsAttacker].KillTimes) >= 4 then
                if (Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 1] - Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 4] <= RAMPAGE_CHECK_TIME) then
                begin
                  Actions.PlayWAV(-1, 'Rampage', 1);
                  Players[Players[P].ThreadsAttacker].Rampage := True;
                  Players[Players[P].ThreadsAttacker].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 44;
              if Length(Players[Players[P].ThreadsAttacker].KillTimes) >= 3 then
                if (Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 1] - Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
                and (not Players[Players[P].ThreadsAttacker].TripleKill)
                and (not Players[Players[P].ThreadsAttacker].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'TripleKill', 1);
                  Players[Players[P].ThreadsAttacker].TripleKill := True;
                  Players[Players[P].ThreadsAttacker].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
              Module := 45;
              if Length(Players[Players[P].ThreadsAttacker].KillTimes) >= 2 then
                if (Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 1] - Players[Players[P].ThreadsAttacker].KillTimes[Length(Players[Players[P].ThreadsAttacker].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
                and (not Players[Players[P].ThreadsAttacker].DoubleKill)
                and (not Players[Players[P].ThreadsAttacker].TripleKill)
                and (not Players[Players[P].ThreadsAttacker].Rampage) then
                begin
                  Actions.PlayWAV(-1, 'DoubleKill', 1);
                  Players[Players[P].ThreadsAttacker].DoubleKill := True;
                  Players[Players[P].ThreadsAttacker].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                end;
            end;
          end;
          Module := 46;
          if not (Players[Tiles[aX][aY].Owner].DoubleKill)
          and not (Players[Tiles[aX][aY].Owner].TripleKill) then
            Players[Tiles[aX][aY].Owner].TempKill := P;
          if not (Players[Tiles[aX][aY].Owner].TripleKill) then
            Players[Tiles[aX][aY].Owner].TempKill2 := P;
          Module := 47;
          for K := 0 to 7 do
          begin
            if Players[K].Kills > 0 then
              if not FirstBlood then
                for I := 0 to 7 do
                begin
                  Actions.PlayWAV(-1, 'FirstBlood', 1);
                  FirstBlood := True;
                  Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$124>' + '[$' + States.PlayerColorText(P) + '] ' + States.PlayerName(P) + '[]';
                end;
            Module := 48;
            if Players[K].DoubleKill then
              for I := 0 to 7 do
              begin
                Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$125>' + '[$' + States.PlayerColorText(Players[K].TempKill) + '] ' + States.PlayerName(Players[K].TempKill) + ' [$FFFFFF]<$128>' + ' [$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]';
                Players[K].DoubleKill := False;
              end;
            Module := 49;
            if Players[K].TripleKill then
              for I := 0 to 7 do
              begin
                Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$126>' + '[$' + States.PlayerColorText(Players[K].TempKill) + '] ' + States.PlayerName(Players[K].TempKill) +',[$' + States.PlayerColorText(Players[K].TempKill2) + '] ' + States.PlayerName(Players[K].TempKill2) + ' [$FFFFFF]<$128>' + ' [$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]';
                Players[K].TripleKill := False;
              end;
            Module := 50;
            if Players[K].Rampage then
              for I := 0 to 7 do
              begin
                Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$127>' + '[]';
              end;
            Module := 51;
            if KILL_STREAK then
              for I := 0 to 7 do
              begin
                if Players[I].KillStreak = 4 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$129>' + '[]';
                end;
                if Players[I].KillStreak = 6 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$130>' + '[]';
                end;
                if Players[I].KillStreak = 8 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$131>' + '[]';
                end;
                if Players[I].KillStreak = 10 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$132>' + '[]';
                end;
              end;
          end;
          Module := 52;
          if not (Players[P].CaptureMind)
          and not (Players[P].MindStunned)
          and (InRange(Tiles[aX][aY].Owner, 0, 7)) then
            Players[P].HP := Players[P].HP - 1 - Byte(Players[Tiles[aX][aY].Owner].DD);
          if Players[P].CaptureMind then
            Players[M[P]].HP := Players[M[P]].HP - 1 - Byte(Players[Tiles[aX][aY].Owner].DD);
          if Players[P].MindStunned then
          begin
            Players[M2[P]].HP := Players[M2[P]].HP - 1 - Byte(Players[Tiles[aX][aY].Owner].DD);
            Actions.GroupBlockOrders(Players[P].Hero, True);
            Actions.GroupOrderHalt(Players[P].Hero);
          end;
          Module := 53;
          if (Tiles[aX][aY].Owner = TEMP_PLAYER)
          and (States.MapTileType(aX, aY) = INFERNAL_TILE) then
          begin
            if not (Players[P].CaptureMind)
            and not (Players[P].MindStunned) then
              Players[P].HP := Players[P].HP - 1;
            if Players[P].CaptureMind then
              Players[M[P]].HP := Players[M[P]].HP - 1;
            if Players[P].MindStunned then
            begin
              Players[M2[P]].HP := Players[M2[P]].HP - 1;
              Actions.GroupBlockOrders(Players[P].Hero, True);
              Actions.GroupOrderHalt(Players[P].Hero);
            end;
          end;
        end;
        Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      end;
    end;

    Module := 54;
    if aObj = VAGA_OBJECT then
    begin
      if (not Players[P].MindStunned)
      and (not Players[P].CaptureMind) then
        if (States.GameTime > Players[P].RegenDelay) then
        begin
          Players[P].HP := Players[P].HP + 1;
          Players[P].RegenDelay := States.GameTime + REGEN_DELAY;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if (Tiles[aX][aY].Skill = sRegen)
            and (Players[P].HP < MAX_HP) then
            begin
              Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$69> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if TileOnRuneSpawn(aX, aY) then
            RuneTaken := True;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
      if Players[P].CaptureMind then
        if (States.GameTime > Players[M[P]].RegenDelay) then
        begin
          Players[M[P]].HP := Players[M[P]].HP + 1;
          Players[M[P]].RegenDelay := States.GameTime + REGEN_DELAY;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if SkillName(Tiles[aX][aY].Skill) <> '' then
            begin
              Players[M[P]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[M[P]].PlayerStatus := Players[M[P]].PlayerStatus + '|<$69> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if TileOnRuneSpawn(aX, aY) then
            RuneTaken := True;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
      if Players[P].MindStunned then
        if (States.GameTime > Players[M2[P]].RegenDelay) then
        begin
          Players[M2[P]].HP := Players[M2[P]].HP + 1;
          Players[M2[P]].RegenDelay := States.GameTime + REGEN_DELAY;
          if InRange(Tiles[aX][aY].Owner, 0, 7) then
          begin
            if SkillName(Tiles[aX][aY].Skill) <> '' then
            begin
              Players[M2[P]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[M2[P]].PlayerStatus := Players[M2[P]].PlayerStatus + '|<$69> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
            end;
          end;
          if TileOnRuneSpawn(aX, aY) then
            RuneTaken := True;
          Actions.MapTileObjectSet(aX, aY, 255);
        end;
    end;

    Module := 55;
    if (aObj = BOWMAN_ROCKET)
    and (not Players[P].HeroMagicImmunity)
    and (not Players[P].HeroTotalImmunity)
    and (InRange(Tiles[aX][aY].Owner, 0, 7)) then
    begin
      if Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) > 0 then
        ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := 0;
      TilesRoadLength[Tiles[aX][aY].Owner] := TilesRoadLength[Tiles[aX][aY].Owner] + 9;
      SetLength(TilesRoadX[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
      SetLength(TilesRoadY[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
      SetLength(ClearTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
      SetLength(SetTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
      SetLength(TilesRoadObjects[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);

      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 1] := aX;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 1] := aY;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 2] := aX;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 2] := aY - 1;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 3] := aX;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 3] := aY + 1;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 4] := aX - 1;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 4] := aY;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 5] := aX + 1;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 5] := aY;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 6] := aX + 1;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 6] := aY + 1;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 7] := aX + 1;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 7] := aY - 1;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 8] := aX - 1;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 8] := aY + 1;
      TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 9] := aX - 1;
      TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 9] := aY - 1;

      Module := 56;
      if Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) > 0 then
        for I := 1 to 9 do
        begin
          TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - I] := BOWMAN_ROCKET2;
          ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 45 + States.KaMRandomI(3);
          SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 15 + States.KaMRandomI(3);

          if TileOnBattlefield(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) then
          begin
            Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Owner := Tiles[aX][aY].Owner;
            Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Skill := sRocket;
            Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9];
          end;

          if (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BARB_OBJECT3)
          or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_ROCKET)
          or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_OBJECT5)
          or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = WARRIOR_OBJECT7) then
            ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] + CLEANUP_TIME;

        end;

      Module := 57;
      TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - 1] := BOWMAN_ROCKET2;
      ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 45 + States.KaMRandomI(3);
      SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 15;

      ClearRoadTilesArrayTime[Tiles[aX][aY].Owner] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] + CLEAR_ARRAY_FACTOR + 5;

    end;

    Module := 58;
    if aObj = RUNE_DOUBLE_OBJ then
    begin
      if States.GameTime > Players[P].DDTime then
      begin
        Players[P].DD := True;
        Players[P].DDTime := States.GameTime + RUNE_DOUBLE_TIME;
        if TileOnRuneSpawn(aX, aY) then
          RuneTaken := True;
        Actions.MapTileObjectSet(aX, aY, 255);
      end;
    end;

    Module := 59;
    if aObj = RUNE_MAGIC_IMMUNITY_OBJ then
    begin
      if States.GameTime > Players[P].HeroMagicImmunityTime then
      begin
        Players[P].HeroMagicImmunity := True;
        Players[P].HeroMagicImmunityTime := States.GameTime + RUNE_MAGIC_IMMUNITY_TIME;
        if InRange(Tiles[aX][aY].Owner, 0, 7)
        and (not TileOnRuneSpawn(aX, aY))
        and (not RuneTaken) then
        begin
          Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$70> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
        end;
        if TileOnRuneSpawn(aX, aY) then
          RuneTaken := True;
        Actions.MapTileObjectSet(aX, aY, 255);
      end;
    end;

    Module := 60;
    if aObj = RUNE_ILLUSION_OBJ then
      for I := 0 to RUNE_ILLUSIONS_COUNT - 1 do
      begin
        Z := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].HeroType, RUNE_X + States.KaMRandomI(5) - States.KaMRandomI(5), RUNE_Y + States.KaMRandomI(5) - States.KaMRandomI(5), States.KaMRandomI(8), 1, 1);
        SetLength(Zombies, Length(Zombies) + 1);
        Zombies[Length(Zombies) - 1].ZombieOwner := P;
        Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
        Zombies[Length(Zombies) - 1].ZombieType := 3;
        Actions.GroupHungerSet(Z, RUNE_ZOMBIE_LIFE);
        if TileOnRuneSpawn(aX, aY) then
          RuneTaken := True;
        Actions.MapTileObjectSet(aX, aY, 255);
      end;

    Module := 61;
    if aObj = RUNE_RECHARGE_OBJ then
    begin
      Players[P].ReCharge := True;
      Players[P].ReChargeTime := States.GameTime + RUNE_RECHARGE_TIME;
      Players[P].RoadSkillDelay := 0;
      Players[P].FieldSkillDelay := 0;
      Players[P].WineSkillDelay := 0;
      Players[P].RocketCharges := BOWMAN_CHARGES;
      Players[P].RocketChargeTime := 0;
      Players[P].SnakeCharges := SNAKE_CHARGES;
      Players[P].SnakeChargeTime := 0;
      if TileOnRuneSpawn(aX, aY) then
        RuneTaken := True;
      Actions.MapTileObjectSet(aX, aY, 255);
    end;

    Module := 62;
    if InRange(aObj, SWORD_OBJECT1, SWORD_OBJECT1 + 2) then
    begin
      if (not States.PlayerDefeated(P))
      and (not Players[P].HeroMagicImmunity)
      and (not Players[P].HeroTotalImmunity)
      and (not Players[P].MindStunned)
      and (not Players[P].CaptureMind)
      and (Players[P].HeroStunnedTime - States.GameTime < STUNNED_TIME) then
      begin
        if Players[P].Hero > 0 then
        begin
          Actions.GroupBlockOrders(Players[P].Hero, True);
          Actions.GroupOrderHalt(Players[P].Hero);
        end;
        if InRange(Tiles[aX][aY].Owner, 0, 7)
        and (not Players[P].HeroStunned)
        and (Tiles[aX][aY].Skill = sSpikedEarth) then
        begin
          Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
        end;
        Players[P].HeroStunnedTime := States.GameTime + STUNNED_TIME;
        Players[P].HeroStunned := True;
        Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
      end;
    end;

    Module := 63;
    if aObj = SWORD_OBJECT then
    begin
      if (not States.PlayerDefeated(P))
      and (not Players[P].HeroMagicImmunity)
      and (not Players[P].HeroTotalImmunity)
      and (not Players[P].MindStunned)
      and (not Players[P].CaptureMind)
      and (Players[P].HeroStunnedTime - States.GameTime < STUNNED_ANIMATION_TIME) then
      begin
        if Players[P].Hero > 0 then
        begin
          Actions.GroupBlockOrders(Players[P].Hero, True);
          Actions.GroupOrderHalt(Players[P].Hero);
        end;
        if InRange(Tiles[aX][aY].Owner, 0, 7)
        and (not Players[P].HeroStunned)
        and (Tiles[aX][aY].Skill = sSpikedEarth) then
        begin
          Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
        end;
        Players[P].HeroStunnedTime := States.GameTime + STUNNED_ANIMATION_TIME;
        Players[P].HeroStunned := True;
        Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
      end;
    end;

    Module := 64;
    if aObj = VAGA_OBJECT6 then
    begin
      if (not States.PlayerDefeated(P))
      and (not Players[P].HeroMagicImmunity)
      and (not Players[P].HeroTotalImmunity)
      and (not Players[P].MindStunned)
      and (not Players[P].CaptureMind)
      and (Players[P].HeroStunnedTime - States.GameTime < SHOCK_TIME) then
      begin
        if Players[P].Hero > 0 then
        begin
          Actions.GroupBlockOrders(Players[P].Hero, True);
          Actions.GroupOrderHalt(Players[P].Hero);
        end;
        if InRange(Tiles[aX][aY].Owner, 0, 7)
        and (not Players[P].HeroStunned)
        and (Tiles[aX][aY].Skill = sDisorientation) then
        begin
          Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
        end;
        Players[P].HeroStunnedTime := States.GameTime + SHOCK_TIME;
        Players[P].HeroStunned := True;
        Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
      end;
    end;

    Module := 65;
    if aObj = KNIGHT_OBJECT3 then
    begin
      if (not States.PlayerDefeated(P))
      and (not Players[P].HeroMagicImmunity)
      and (not Players[P].HeroTotalImmunity)
      and (not Players[P].MindStunned)
      and (not Players[P].CaptureMind)
      and (Players[P].HeroStunnedTime - States.GameTime < DEAFENING_TIME)
      and (Tiles[aX][aY].Owner <> P) then
      begin
        if Players[P].Hero > 0 then
        begin
          Actions.GroupBlockOrders(Players[P].Hero, True);
          Actions.GroupOrderHalt(Players[P].Hero);
        end;
        if InRange(Tiles[aX][aY].Owner, 0, 7)
        and (not Players[P].HeroStunned)
        and (Tiles[aX][aY].Skill = sDeafeningClatter) then
        begin
          Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$68> ' + '[$' + States.PlayerColorText(Tiles[aX][aY].Owner) + ']' + States.PlayerName(Tiles[aX][aY].Owner) + '[]<$71> ' + SkillName(Tiles[aX][aY].Skill);
        end;
        Players[P].HeroStunnedTime := States.GameTime + DEAFENING_TIME;
        Players[P].HeroStunned := True;
        Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
      end;
    end;

    Module := 66;
    if (ObjectType(aObj) = otStun)
    and (not Players[P].MindStunned) then
      CancelSkills(P);

    except

      LogError('Exception in the script in module ' + IntToStr(Module) + ': cannot check tiles for invalid player:', [aX, aY, P, States.GameTime], SHOW_ERROR_MSG);

    end;

end;


procedure CheckTilesForAI(P: Integer);
var
  AIUnits: array of Integer;
  I, K, aObj, aX, aY, aTile, aU: Integer;
begin
  try
    aObj := -1;
    if States.PlayerEnabled(P) then
      if not States.PlayerDefeated(P) then
      begin
        AIUnits := States.PlayerGetAllUnits(P);
        if Length(AIUnits) > 0 then
          for K := 0 to Length(AIUnits) - 1 do
          begin
            if AIUnits[K] > 0 then
            begin
              aX := States.UnitPositionX(AIUnits[K]);
              aY := States.UnitPositionY(AIUnits[K]);
              aU := AIUnits[K];
            end;

            if not InRange(aX, MIN_X, MAX_X) then
              Exit; 

            if not InRange(aY, MIN_Y, MAX_Y) then
              Exit;

            if (TileOnBattlefield(aX, aY))
            or (Tiles[aX][aY].Owner = TEMP_PLAYER) then
            begin
              aObj := States.MapTileObject(aX, aY);
              aTile := States.MapTileType(aX, aY);
              if ((ObjectType(aObj) = otKill)
              or ((aTile = INFERNAL_TILE)
              and (States.UnitType(AIUnits[K]) <> 13))
              and (InRange(Tiles[aX][aY].Owner, 0, 7)))
              or ((aTile = INFERNAL_TILE)
              and (Tiles[aX][aY].Owner = TEMP_PLAYER)) then
              begin
                Actions.UnitKill(AIUnits[K], False);

                if (aObj = BOWMAN_ROCKET)
                and (Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) > 0) then
                begin
                  ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := 0;
                  TilesRoadLength[Tiles[aX][aY].Owner] := TilesRoadLength[Tiles[aX][aY].Owner] + 9;
                  SetLength(TilesRoadX[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
                  SetLength(TilesRoadY[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
                  SetLength(ClearTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
                  SetLength(SetTilesRoadTimes[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);
                  SetLength(TilesRoadObjects[Tiles[aX][aY].Owner], TilesRoadLength[Tiles[aX][aY].Owner]);

                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 1] := aX;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 1] := aY;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 2] := aX;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 2] := aY - 1;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 3] := aX;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 3] := aY + 1;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 4] := aX - 1;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 4] := aY;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 5] := aX + 1;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 5] := aY;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 6] := aX + 1;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 6] := aY + 1;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 7] := aX + 1;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 7] := aY - 1;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 8] := aX - 1;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 8] := aY + 1;
                  TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - 9] := aX - 1;
                  TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - 9] := aY - 1;

                  for I := 1 to 9 do
                  begin
                    TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - I] := BOWMAN_ROCKET2;
                    ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 45 + States.KaMRandomI(3);
                    SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := States.GameTime + 15 + States.KaMRandomI(3);

                    if TileOnBattlefield(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) then
                    begin
                      Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Owner := Tiles[aX][aY].Owner;
                      Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].Skill := sRocket;
                      Tiles[TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I]][TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]].ObjectRefreshTime := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9];
                    end;

                    if (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BARB_OBJECT3)
                    or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_ROCKET)
                    or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = BOWMAN_OBJECT5)
                    or (States.MapTileObject(TilesRoadX[Tiles[aX][aY].Owner][Length(TilesRoadX[Tiles[aX][aY].Owner]) - I], TilesRoadY[Tiles[aX][aY].Owner][Length(TilesRoadY[Tiles[aX][aY].Owner]) - I]) = WARRIOR_OBJECT7) then
                    begin
                      ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - I] + CLEANUP_TIME + 5;
                      TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - I] := SKILL_CANCEL_OBJ;
                    end;

                  end;

                  TilesRoadObjects[Tiles[aX][aY].Owner][Length(TilesRoadObjects[Tiles[aX][aY].Owner]) - 1] := BOWMAN_ROCKET2;
                  ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 45 + States.KaMRandomI(3);
                  SetTilesRoadTimes[Tiles[aX][aY].Owner][Length(SetTilesRoadTimes[Tiles[aX][aY].Owner]) - 1] := States.GameTime + 15;

                  ClearRoadTilesArrayTime[Tiles[aX][aY].Owner] := ClearTilesRoadTimes[Tiles[aX][aY].Owner][Length(ClearTilesRoadTimes[Tiles[aX][aY].Owner]) - 9] + CLEAR_ARRAY_FACTOR + 2;
         
                end;
              end;
            end;
        end;
    end;

  except

    LogError('Exception in the script: cannot check tiles for invalid AI player:', [P, aX, aY, Tiles[aX][aY].Owner, aU], SHOW_ERROR_MSG);

  end;

end;


function ArenaCheckTime: Integer;
begin
  case AlivePlayersCount of
    2: Result := 300;
    3: Result := 600;
    4: Result := 900;
    5: Result := 1500;
    6: Result := 2000;
    7: Result := 2200;
    8: Result := 2400;
    else Result := 1000000;
  end;
end;


procedure CheckArenaTimer;
begin
  if States.GameTime < GAME_START_TIME then
    Exit;
  if not NEW_ARENA then
    Exit;
  if ArenaTime > 0 then
    ArenaTime := ArenaTime - 1;
  if (ArenaTime = 0)
  and (ArenaCycles < ARENA_CYCLES - 1) then
  begin
    ArenaTime := ArenaCheckTime;
    ArenaTime2 := States.GameTime + BORDER_SPACES_TIME;
  end;
end;


procedure CheckVictoryDefeat;
var
  TeamHP: array[0..1] of Integer;
  I, J, K, P: Integer;
begin
  for I := 0 to 1 do
    TeamHP[I] := 0;

  for J := 0 to 3 do
    if States.PlayerEnabled(J) then
    begin
      TeamHP[0] := TeamHP[0] + Players[J].HP;
      if (Players[J].HP = 0)
      and (not Players[J].Defeat) then
      begin
        if Length(Zombies) > 0 then
          for I := 0 to Length(Zombies) - 1 do
            if Zombies[I].ZombieOwner = J then
              Actions.UnitKill(Zombies[I].ZombieID, False);
        for P := 0 to 7 do
          if States.PlayerEnabled(P) then
            begin
              Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[P].PlayerStatus := Players[P].PlayerStatus + '|[$' + States.PlayerColorText(J) + ']' + States.PlayerName(J) + '[] <$134>';
              if J <> P then
              begin
                if Players[P].PlayersTeam = Players[J].PlayersTeam then
                  Actions.PlayWAV(P, 'AllyKilled', 1)
                else
                  Actions.PlayWAV(P, 'EnemyKilled', 1);
              end;
            end;
        Players[J].Defeat := True;
      end;
    end;

  for K := 4 to 7 do
    if States.PlayerEnabled(K) then
    begin
      TeamHP[1] := TeamHP[1] + Players[K].HP;
      if (Players[K].HP = 0)
      and (not Players[K].Defeat) then
      begin
        if Length(Zombies) > 0 then
          for I := 0 to Length(Zombies) - 1 do
            if Zombies[I].ZombieOwner = K then
              Actions.UnitKill(Zombies[I].ZombieID, False);
        for P := 0 to 7 do
          if States.PlayerEnabled(P) then
            begin
              Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
              Players[P].PlayerStatus := Players[P].PlayerStatus + '|[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + '[] <$134>';
              if K <> P then
              begin
                if Players[P].PlayersTeam = Players[K].PlayersTeam then
                  Actions.PlayWAV(P, 'AllyKilled', 1)
                else
                  Actions.PlayWAV(P, 'EnemyKilled', 1);
              end;
            end;
        Players[K].Defeat := True;
      end;
    end;

  if TeamHP[0] = 0 then
  begin
    for K := 0 to 3 do
    begin
      if States.PlayerEnabled(K) then
      begin
        Actions.PlayerDefeat(K);
        Actions.FogRevealAll(K);
      end;
    end;
    for J := 4 to 7 do
    begin
      if States.PlayerEnabled(J) then
      begin
        Actions.PlayerWin([J], True);
        Actions.FogRevealAll(J);
      end;
    end;
  end;

  if TeamHP[1] = 0 then
  begin
    for K := 4 to 7 do
    begin
      if States.PlayerEnabled(K) then
      begin
        Actions.PlayerDefeat(K);
        Actions.FogRevealAll(K);
      end;
    end;
    for J := 0 to 3 do
    begin
      if States.PlayerEnabled(J) then
      begin
        Actions.PlayerWin([J], True);
        Actions.FogRevealAll(J);
      end;
    end;
  end;

end;


function TileNearRuneSpawn(aX, aY, aRadius: Integer): Boolean;
begin
  Result := ((Abs(aY - RUNE_Y1) <= aRadius) and (Abs(aX - RUNE_X) <= aRadius)) 
            or ((Abs(aY - RUNE_Y2) <= aRadius) and (Abs(aX - RUNE_X) <= aRadius));
end;


procedure CheckTotemCircles(P: Integer);
var
  I, K: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if TotemCirclesLength[P][K] > 0 then
        for I := 0 to TotemCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(TotemCircles[P][K][I].X, TotemCircles[P][K][I].Y) then
          begin
            if (States.GameTime = TotemCircles[P][K][I].AddTime)
            and (TotemCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
              SetCircle(P, TotemCircles[P][K][I].X, TotemCircles[P][K][I].Y, TotemCircles[P][K][I].Radius, TotemCircles[P][K][I].Obj, False, True, sTotem);
          end;
        end;
    end;
end;


procedure CheckRageCircles(P: Integer);
var
  I, K: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if RageCirclesLength[P][K] > 0 then
        for I := 0 to RageCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(RageCircles[P][K][I].X, RageCircles[P][K][I].Y) then
          begin
            if (States.GameTime = RageCircles[P][K][I].AddTime) then
              SetCircle(P, RageCircles[P][K][I].X, RageCircles[P][K][I].Y, RageCircles[P][K][I].Radius, RageCircles[P][K][I].Obj, True, False, sWaveOfRage);
          end;
        end;
    end;
end;


procedure CheckFireworks1Circles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles1Length[P][K] > 0 then
        for I := 0 to FireworksCircles1Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles1[P][K][I].X, FireworksCircles1[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles1[P][K][I].AddTime)
            and (FireworksCircles1[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles1[P][K][I].X, FireworksCircles1[P][K][I].Y, FireworksCircles1[P][K][I].Radius, FireworksCircles1[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles1[P][K][I].X - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].X + FireworksCircles1[P][K][I].Radius do
              for PosY := FireworksCircles1[P][K][I].Y - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].Y + FireworksCircles1[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles1[P][K][I].X - PosX) * (FireworksCircles1[P][K][I].X - PosX) + (FireworksCircles1[P][K][I].Y - PosY) * (FireworksCircles1[P][K][I].Y - PosY)) <= FireworksCircles1[P][K][I].Radius * FireworksCircles1[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles1Length[P][K] - 1 then
                for PosX := FireworksCircles1[P][K][I].X - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].X + FireworksCircles1[P][K][I].Radius do
                for PosY := FireworksCircles1[P][K][I].Y - FireworksCircles1[P][K][I].Radius to FireworksCircles1[P][K][I].Y + FireworksCircles1[P][K][I].Radius do
                  if (((FireworksCircles1[P][K][I].X - PosX) * (FireworksCircles1[P][K][I].X - PosX) + (FireworksCircles1[P][K][I].Y - PosY) * (FireworksCircles1[P][K][I].Y - PosY)) <= FireworksCircles1[P][K][I].Radius * FireworksCircles1[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks2Circles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles2Length[P][K] > 0 then
        for I := 0 to FireworksCircles2Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles2[P][K][I].X, FireworksCircles2[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles2[P][K][I].AddTime)
            and (FireworksCircles2[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles2[P][K][I].X, FireworksCircles2[P][K][I].Y, FireworksCircles2[P][K][I].Radius, FireworksCircles2[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles2[P][K][I].X - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].X + FireworksCircles2[P][K][I].Radius do
              for PosY := FireworksCircles2[P][K][I].Y - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].Y + FireworksCircles2[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles2[P][K][I].X - PosX) * (FireworksCircles2[P][K][I].X - PosX) + (FireworksCircles2[P][K][I].Y - PosY) * (FireworksCircles2[P][K][I].Y - PosY)) <= FireworksCircles2[P][K][I].Radius * FireworksCircles2[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles2Length[P][K] - 1 then
                for PosX := FireworksCircles2[P][K][I].X - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].X + FireworksCircles2[P][K][I].Radius do
                for PosY := FireworksCircles2[P][K][I].Y - FireworksCircles2[P][K][I].Radius to FireworksCircles2[P][K][I].Y + FireworksCircles2[P][K][I].Radius do
                  if (((FireworksCircles2[P][K][I].X - PosX) * (FireworksCircles2[P][K][I].X - PosX) + (FireworksCircles2[P][K][I].Y - PosY) * (FireworksCircles2[P][K][I].Y - PosY)) <= FireworksCircles2[P][K][I].Radius * FireworksCircles2[P][K][I].Radius) then
                  if TileOnBattlefield(PosX, PosY) then  
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks3Circles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles3Length[P][K] > 0 then
        for I := 0 to FireworksCircles3Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles3[P][K][I].X, FireworksCircles3[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles3[P][K][I].AddTime)
            and (FireworksCircles3[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles3[P][K][I].X, FireworksCircles3[P][K][I].Y, FireworksCircles3[P][K][I].Radius, FireworksCircles3[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles3[P][K][I].X - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].X + FireworksCircles3[P][K][I].Radius do
              for PosY := FireworksCircles3[P][K][I].Y - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].Y + FireworksCircles3[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles3[P][K][I].X - PosX) * (FireworksCircles3[P][K][I].X - PosX) + (FireworksCircles3[P][K][I].Y - PosY) * (FireworksCircles3[P][K][I].Y - PosY)) <= FireworksCircles3[P][K][I].Radius * FireworksCircles3[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles3Length[P][K] - 1 then
                for PosX := FireworksCircles3[P][K][I].X - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].X + FireworksCircles3[P][K][I].Radius do
                for PosY := FireworksCircles3[P][K][I].Y - FireworksCircles3[P][K][I].Radius to FireworksCircles3[P][K][I].Y + FireworksCircles3[P][K][I].Radius do
                  if (((FireworksCircles3[P][K][I].X - PosX) * (FireworksCircles3[P][K][I].X - PosX) + (FireworksCircles3[P][K][I].Y - PosY) * (FireworksCircles3[P][K][I].Y - PosY)) <= FireworksCircles3[P][K][I].Radius * FireworksCircles3[P][K][I].Radius) then
                  if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks4Circles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles4Length[P][K] > 0 then
        for I := 0 to FireworksCircles4Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles4[P][K][I].X, FireworksCircles4[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles4[P][K][I].AddTime)
            and (FireworksCircles4[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles4[P][K][I].X, FireworksCircles4[P][K][I].Y, FireworksCircles4[P][K][I].Radius, FireworksCircles4[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles4[P][K][I].X - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].X + FireworksCircles4[P][K][I].Radius do
              for PosY := FireworksCircles4[P][K][I].Y - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].Y + FireworksCircles4[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles4[P][K][I].X - PosX) * (FireworksCircles4[P][K][I].X - PosX) + (FireworksCircles4[P][K][I].Y - PosY) * (FireworksCircles4[P][K][I].Y - PosY)) <= FireworksCircles4[P][K][I].Radius * FireworksCircles4[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles4Length[P][K] - 1 then
                for PosX := FireworksCircles4[P][K][I].X - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].X + FireworksCircles4[P][K][I].Radius do
                for PosY := FireworksCircles4[P][K][I].Y - FireworksCircles4[P][K][I].Radius to FireworksCircles4[P][K][I].Y + FireworksCircles4[P][K][I].Radius do
                  if (((FireworksCircles4[P][K][I].X - PosX) * (FireworksCircles4[P][K][I].X - PosX) + (FireworksCircles4[P][K][I].Y - PosY) * (FireworksCircles4[P][K][I].Y - PosY)) <= FireworksCircles4[P][K][I].Radius * FireworksCircles4[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckFireworks5Circles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if FireworksCircles5Length[P][K] > 0 then
        for I := 0 to FireworksCircles5Length[P][K] - 1 do
        begin
          if TileOnBattlefield(FireworksCircles5[P][K][I].X, FireworksCircles5[P][K][I].Y) then
          begin
            if (States.GameTime = FireworksCircles5[P][K][I].AddTime)
            and (FireworksCircles5[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, FireworksCircles5[P][K][I].X, FireworksCircles5[P][K][I].Y, FireworksCircles5[P][K][I].Radius, FireworksCircles5[P][K][I].Obj, False, False, sDeadlyFireworks);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := FireworksCircles5[P][K][I].X - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].X + FireworksCircles5[P][K][I].Radius do
              for PosY := FireworksCircles5[P][K][I].Y - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].Y + FireworksCircles5[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((FireworksCircles5[P][K][I].X - PosX) * (FireworksCircles5[P][K][I].X - PosX) + (FireworksCircles5[P][K][I].Y - PosY) * (FireworksCircles5[P][K][I].Y - PosY)) <= FireworksCircles5[P][K][I].Radius * FireworksCircles5[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = FireworksCircles5Length[P][K] - 1 then
                for PosX := FireworksCircles5[P][K][I].X - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].X + FireworksCircles5[P][K][I].Radius do
                for PosY := FireworksCircles5[P][K][I].Y - FireworksCircles5[P][K][I].Radius to FireworksCircles5[P][K][I].Y + FireworksCircles5[P][K][I].Radius do
                  if (((FireworksCircles5[P][K][I].X - PosX) * (FireworksCircles5[P][K][I].X - PosX) + (FireworksCircles5[P][K][I].Y - PosY) * (FireworksCircles5[P][K][I].Y - PosY)) <= FireworksCircles5[P][K][I].Radius * FireworksCircles5[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckExpCircles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if ExpCirclesLength[P][K] > 0 then
        for I := 0 to ExpCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(ExpCircles[P][K][I].X, ExpCircles[P][K][I].Y) then
          begin
            if (States.GameTime = ExpCircles[P][K][I].AddTime)
            and (ExpCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, ExpCircles[P][K][I].X, ExpCircles[P][K][I].Y, ExpCircles[P][K][I].Radius, ExpCircles[P][K][I].Obj, False, False, sRevengeFromNowhere);

              if not CHANGE_RELIEF then
                Exit;

              if I > ExpCirclesLength[P][ExpCirclesCounter[P]] div 2 then
                for PosX := ExpCircles[P][K][I].X - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].X + ExpCircles[P][K][I].Radius do
                for PosY := ExpCircles[P][K][I].Y - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].Y + ExpCircles[P][K][I].Radius do
                begin
                  aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                  if aRelief < 0 then
                    aRelief := -1 * aRelief;
                  if (((ExpCircles[P][K][I].X - PosX) * (ExpCircles[P][K][I].X - PosX) + (ExpCircles[P][K][I].Y - PosY) * (ExpCircles[P][K][I].Y - PosY)) <= ExpCircles[P][K][I].Radius * ExpCircles[P][K][I].Radius) then
                    if (TileOnBattlefield(PosX, PosY))
                    and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                    and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                      Actions.MapTileHeightSet(PosX, PosY, aRelief);
                end;

              if I = ExpCirclesLength[P][K] - 1 then
                for PosX := ExpCircles[P][K][I].X - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].X + ExpCircles[P][K][I].Radius do
                for PosY := ExpCircles[P][K][I].Y - ExpCircles[P][K][I].Radius to ExpCircles[P][K][I].Y + ExpCircles[P][K][I].Radius do
                  if (((ExpCircles[P][K][I].X - PosX) * (ExpCircles[P][K][I].X - PosX) + (ExpCircles[P][K][I].Y - PosY) * (ExpCircles[P][K][I].Y - PosY)) <= ExpCircles[P][K][I].Radius * ExpCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckKnightCircles(P: Integer);
var
  I, K: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if KnightCirclesLength[P][K] > 0 then
        for I := 0 to KnightCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(KnightCircles[P][K][I].X, KnightCircles[P][K][I].Y) then
          begin
            if (States.GameTime = KnightCircles[P][K][I].AddTime) then
            begin
              SetCircle(P, KnightCircles[P][K][I].X, KnightCircles[P][K][I].Y, KnightCircles[P][K][I].Radius, KnightCircles[P][K][I].Obj, True, False, sDeafeningClatter);
            end;
          end;
        end;
    end;
end;


procedure CheckRogueCircles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if RogueCirclesLength[P][K] > 0 then
        for I := 0 to RogueCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(RogueCircles[P][K][I].X, RogueCircles[P][K][I].Y) then
          begin
            if (States.GameTime = RogueCircles[P][K][I].AddTime)
            and (RogueCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, RogueCircles[P][K][I].X, RogueCircles[P][K][I].Y, RogueCircles[P][K][I].Radius, RogueCircles[P][K][I].Obj, False, False, sMentalBurst);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := RogueCircles[P][K][I].X - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].X + RogueCircles[P][K][I].Radius do
              for PosY := RogueCircles[P][K][I].Y - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].Y + RogueCircles[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                aRelief := -1 * aRelief;
                if (((RogueCircles[P][K][I].X - PosX) * (RogueCircles[P][K][I].X - PosX) + (RogueCircles[P][K][I].Y - PosY) * (RogueCircles[P][K][I].Y - PosY)) <= RogueCircles[P][K][I].Radius * RogueCircles[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = RogueCirclesLength[P][K] - 1 then
                for PosX := RogueCircles[P][K][I].X - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].X + RogueCircles[P][K][I].Radius do
                for PosY := RogueCircles[P][K][I].Y - RogueCircles[P][K][I].Radius to RogueCircles[P][K][I].Y + RogueCircles[P][K][I].Radius do
                  if (((RogueCircles[P][K][I].X - PosX) * (RogueCircles[P][K][I].X - PosX) + (RogueCircles[P][K][I].Y - PosY) * (RogueCircles[P][K][I].Y - PosY)) <= RogueCircles[P][K][I].Radius * RogueCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckStolenRogueCircles(P: Integer);
var
  I, K, aRelief, PosX, PosY: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if StolenRogueCirclesLength[P][K] > 0 then
        for I := 0 to StolenRogueCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(StolenRogueCircles[P][K][I].X, StolenRogueCircles[P][K][I].Y) then
          begin
            if (States.GameTime = StolenRogueCircles[P][K][I].AddTime)
            and (StolenRogueCircles[P][K][I].Obj <> SKILL_CANCEL_OBJ) then
            begin
              SetCircle(P, StolenRogueCircles[P][K][I].X, StolenRogueCircles[P][K][I].Y, StolenRogueCircles[P][K][I].Radius, StolenRogueCircles[P][K][I].Obj, False, False, sMentalBurst);

              if not CHANGE_RELIEF then
                Exit;

              for PosX := StolenRogueCircles[P][K][I].X - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].X + StolenRogueCircles[P][K][I].Radius do
              for PosY := StolenRogueCircles[P][K][I].Y - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].Y + StolenRogueCircles[P][K][I].Radius do
              begin
                aRelief := States.MapTileHeight(PosX, PosY) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
                if aRelief < 0 then
                  aRelief := -1 * aRelief;
                if (((StolenRogueCircles[P][K][I].X - PosX) * (StolenRogueCircles[P][K][I].X - PosX) + (StolenRogueCircles[P][K][I].Y - PosY) * (StolenRogueCircles[P][K][I].Y - PosY)) <= StolenRogueCircles[P][K][I].Radius * StolenRogueCircles[P][K][I].Radius) then
                  if (TileOnBattlefield(PosX, PosY))
                  and (InRange(States.MapTileHeight(PosX, PosY), 0, 45))
                  and (not TileNearRuneSpawn(PosX, PosY, 2)) then
                    Actions.MapTileHeightSet(PosX, PosY, aRelief);
              end;

              if I = StolenRogueCirclesLength[P][K] - 1 then
                for PosX := StolenRogueCircles[P][K][I].X - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].X + StolenRogueCircles[P][K][I].Radius do
                for PosY := StolenRogueCircles[P][K][I].Y - StolenRogueCircles[P][K][I].Radius to StolenRogueCircles[P][K][I].Y + StolenRogueCircles[P][K][I].Radius do
                  if (((StolenRogueCircles[P][K][I].X - PosX) * (StolenRogueCircles[P][K][I].X - PosX) + (StolenRogueCircles[P][K][I].Y - PosY) * (StolenRogueCircles[P][K][I].Y - PosY)) <= StolenRogueCircles[P][K][I].Radius * StolenRogueCircles[P][K][I].Radius) then
                    if TileOnBattlefield(PosX, PosY) then
                      Actions.MapTileHeightSet(PosX, PosY, Tiles[PosX][PosY].Relief);
            end;
          end;
        end;
    end;
end;


procedure CheckViseCircles(P: Integer);
var
  I, K: Integer;
begin
  if States.PlayerEnabled(P) then
    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin
      if ViseCirclesLength[P][K] > 0 then
        for I := 0 to ViseCirclesLength[P][K] - 1 do
        begin
          if TileOnBattlefield(ViseCircles[P][K][I].X, ViseCircles[P][K][I].Y) then
          begin
            if (States.GameTime = ViseCircles[P][K][I].AddTime) then
            begin
              SetCircle(P, ViseCircles[P][K][I].X, ViseCircles[P][K][I].Y, VISE_RADIUS, 255, True, False, sViseOfDeath);
              SetCircle(P, ViseCircles[P][K][I].X, ViseCircles[P][K][I].Y, ViseCircles[P][K][I].Radius, ViseCircles[P][K][I].Obj, True, False, sViseOfDeath);
            end;
          end;
        end;
    end;
end;


procedure CheckGravityCircles(P: Integer);
var
  I, X, Y, O, U, G, UT, CC, OT, HT, ZT, aX, aY: Integer;
begin
  if States.PlayerEnabled(P) then
    if GravityCirclesLength[P] > 0 then
      for CC := 0 to GravityCirclesLength[P] - 1 do
      begin
        if TileOnBattlefield(GravityCircles[P][CC].X, GravityCircles[P][CC].Y) then
        begin
          if (States.GameTime = GravityCircles[P][CC].AddTime) then
          begin
            SetCircle(P, GravityCircles[P][CC].X, GravityCircles[P][CC].Y, GRAVITY_RADIUS, 255, False, True, sGravity);
            SetCircle(P, GravityCircles[P][CC].X, GravityCircles[P][CC].Y, GravityCircles[P][CC].Radius, GravityCircles[P][CC].Obj, False, True, sGravity);
            for X := GravityCircles[P][CC].X - GravityCircles[P][CC].Radius - 1 to GravityCircles[P][CC].X + GravityCircles[P][CC].Radius + 1 do
            for Y := GravityCircles[P][CC].Y - GravityCircles[P][CC].Radius - 1 to GravityCircles[P][CC].Y + GravityCircles[P][CC].Radius + 1 do
            begin
              if (((X - GravityCircles[P][CC].X) * (X - GravityCircles[P][CC].X) + (Y - GravityCircles[P][CC].Y) * (Y - GravityCircles[P][CC].Y)) <= GravityCircles[P][CC].Radius * GravityCircles[P][CC].Radius) then
              begin
                U := States.UnitAt(X, Y);
                if U > 0 then
                begin
                  O := States.UnitOwner(U);
                  UT := States.UnitType(U);
                  aX := States.UnitPositionX(U);
                  aY := States.UnitPositionY(U);
                  if (InRange(O, 0, 7))
                  and (not Players[O].HeroMagicImmunity)
                  and (not Players[O].HeroTotalImmunity)
                  and (States.MapTileObject(aX, aY) <> WARRIOR_OBJECT7) then
                  begin
                    Actions.GroupKillAll(Players[O].Hero, True);
                    while States.StatArmyCount(O) = 0 do
                      Players[O].Hero := Actions.GiveGroup(O, Players[O].HeroType, Players[P].GravityX + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].GravityY + States.KaMRandomI(2) - States.KaMRandomI(2), States.KaMRandomI(8), 1, 1);
                    Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
                    if not Players[O].MovedByGravity then
                    begin
                      Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
                      Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$72> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]<$71> ' + SkillName(sGravity);
                      Players[O].MovedByGravity := True;
                      Players[O].GravityUser := P;
                      Players[O].GravityTime := States.GameTime + GRAVITY_MOVE_TIME;
                      if Players[O].HeroStunned then
                        Actions.GroupBlockOrders(Players[O].Hero, True);
                    end;
                    Break;
                    Exit;
                  end
                  else
                    if (InRange(O, 8, 11)) then 
                    begin
                      for I := 0 to Length(Zombies) - 1 do
                        if U = Zombies[I].ZombieID then
                        begin
                          OT := Zombies[I].ZombieOwner;
                          HT := States.UnitHunger(Zombies[I].ZombieID);
                          ZT := Zombies[I].ZombieType;
                        end;
                      if (InRange(UT, 14, 27))
                      and (States.MapTileObject(aX, aY) <> WARRIOR_OBJECT7) then
                      begin
                        Actions.GroupKillAll(States.UnitsGroup(U), True);
                        G := Actions.GiveGroup(O, UT, Players[P].GravityX + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].GravityY + States.KaMRandomI(2) - States.KaMRandomI(2), States.KaMRandomI(8), 1, 1);
                        SetLength(Zombies, Length(Zombies) + 1);
                        Zombies[Length(Zombies) - 1].ZombieOwner := OT;
                        Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(G, 0);
                        Zombies[Length(Zombies) - 1].ZombieType := ZT;
                        Actions.GroupHungerSet(G, HT);
                        Break;
                        Exit;
                      end
                      else
                        if (UT = 13)
                        and (States.MapTileObject(aX, aY) <> WARRIOR_OBJECT7) then
                        begin
                          Actions.UnitKill(U, True);
                          G := Actions.GiveUnit(O, UT, Players[P].GravityX + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].GravityY + States.KaMRandomI(2) - States.KaMRandomI(2), States.KaMRandomI(8));
                          SetLength(Zombies, Length(Zombies) + 1);
                          Zombies[Length(Zombies) - 1].ZombieOwner := OT;
                          Zombies[Length(Zombies) - 1].ZombieID := G;
                          Zombies[Length(Zombies) - 1].ZombieType := ZT;
                          Actions.UnitHungerSet(G, HT);
                          Break;
                          Exit;
                        end;
                    end;
                  if not InRange (O, 0, 11) then
                    Exit;
                end;
              end;
            end;
          end;
        end;
      end;
end;


procedure OnPlayerVictory(P: Integer);
begin
  if (InRange(P, 0, 7)) then
  begin
    Actions.FogRevealAll(P);
    if (Length(PlayersLeft) > 0)
    and (Length(PlayersRight) > 0) then
    begin
      GameOver := True;
      VictoryTime := States.GameTime + VICTORY_DELAY;
    end;
  end;
end;


procedure OnUnitWounded(aID, aAttacker: Integer);
var
  I: Integer;
begin
  if Length(Zombies) <= 0 then
    Exit;
  for I := 0 to Length(Zombies) - 1 do
    if not States.UnitDead(Zombies[I].ZombieID) then
      if aAttacker = Zombies[I].ZombieID then
      begin
        LastAttacker := Zombies[I].ZombieOwner;
        LastAttackerZombieType := Zombies[I].ZombieType;
        LastAttackerUnitType := States.UnitType(aAttacker);
      end;
end;


procedure OnUnitAttacked(aID, aAttacker: Integer);
var
  I, P, Z, X, Y, T, O: Integer;
begin
  if Length(Zombies) <= 0 then
    Exit;
  O := States.UnitOwner(aID);
  for I := 0 to Length(Zombies) - 1 do
    if not States.UnitDead(Zombies[I].ZombieID) then
      if aAttacker = Zombies[I].ZombieID then
      begin
        P := Zombies[I].ZombieOwner;
        if (Players[P].MirrorTime >= States.GameTime)
        and (not Players[O].HeroMagicImmunity)
        and (not Players[O].HeroTotalImmunity) then
        begin
          SetLength(Zombies, Length(Zombies) + 1);
          Zombies[Length(Zombies) - 1].ZombieOwner := P;
          X := States.UnitPositionX(Zombies[I].ZombieID);
          Y := States.UnitPositionY(Zombies[I].ZombieID);
          T := States.UnitType(Zombies[I].ZombieID);
          Z := Actions.GiveGroup(Players[P].ZombiePlayer, T, X, Y, States.KaMRandomI(8), 1, 1);
          Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
          Zombies[Length(Zombies) - 1].ZombieType := 3;
          Actions.GroupHungerSet(Z, REBEL_ZOMBIE_LIFE * (1 + Byte(Players[P].DD)));
        end;
      end;
end;


procedure OnUnitDied(aID, aKiller: Integer);
var
  I, K, O, aX, aY, X, Y, G: Integer;
begin
  if aID <= 0 then
    Exit;

  if States.GameTime > GAME_START_TIME then
  begin
    SortScoresLeft;
    SortScoresRight;
  end;
  
  O := States.UnitOwner(aID);
  aX := States.UnitPositionX(aID);
  aY := States.UnitPositionY(aID);
  G := States.UnitsGroup(aID);

  if not InRange(aX, MIN_X, MAX_X) then
    Exit; 

  if not InRange(aY, MIN_Y, MAX_Y) then
    Exit;

  for I := 0 to 7 do
    if aID = Players[I].AITarget then
      Players[I].AITarget := -1;
  
  if InRange(O, 0, 7) then
  begin

    if (Players[O].CaptureMind)
    and (Players[O].Hero <> G) then
      O := M[Q[O]];     

    for X := aX - ANIMATION_CHECK_RADIUS to aX + ANIMATION_CHECK_RADIUS do
    for Y := aY - ANIMATION_CHECK_RADIUS to aY + ANIMATION_CHECK_RADIUS do
      if TileOnBattlefield(X, Y) then
        if not InRange(States.MapTileType(X, Y), INFERNAL_TILE - 3, INFERNAL_TILE) then
          Actions.MapTileSet(X, Y, Tiles[X][Y].TileType, Tiles[X][Y].TileDirection);

    if TileOnBattlefield(aX, aY) then
    begin
      Players[O].LastX := aX;
      Players[O].LastY := aY;
      Players[O].LastDir := States.UnitDirection(aID);
    end;

    if (InRange(aX, MIN_X, MAX_X))
    and (InRange(aY, MIN_Y, MAX_Y)) then
      if Tiles[aX][aY].Owner = TEMP_PLAYER then
        ArenaTime2 := States.GameTime + BORDER_SPACES_TIME;

  end;

  if InRange(O, 8, 11) then
  begin
    for I := Low(Zombies) to High(Zombies) do
      if aID = Zombies[I].ZombieID then
        Zombies[I].ZombieID := -1;
    CheckZombieArray;
  end;

  if (InRange(O, 0, 7))
  and (InRange(aKiller, 9, 11)) then
  begin

    Players[O].HeroSilentTime := 0;
    if (not Players[O].CaptureMind)
    and (not Players[O].MindStunned) then
      Players[O].HeroStunnedTime := 0;
    Players[O].HeroInFearTime := 0;
    Players[O].PreparingTime := 0;
    Players[O].DDTime := 0;
    Players[O].ReChargeTime := 0;

    if States.GameTime < Players[O].MindTime2 then
    begin
      Players[O].MindTime2 := 0;
      Players[O].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[O].ReCharge)));
      Players[O].CaptureMind := False;
      Players[M[O]].MindStunned := False;
    end;
    
    if (InRange(M2[O], 0, 7)) then
      if States.GameTime < Players[M2[O]].MindTime2 then
      begin
        Players[M2[O]].MindTime2 := 0;
        Players[M2[O]].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[M2[O]].ReCharge)));
        Players[M2[O]].CaptureMind := False;
        Players[O].MindStunned := False;
        Actions.GroupBlockOrders(Players[M2[O]].Hero, False);
      end;

    if (InRange(Players[O].WerewolfTime - States.GameTime, 0, 49))
    and (InRange(Players[O].TempHeroType, 14, 27)) then
    begin
      Players[O].HeroType := Players[O].TempHeroType;
      Players[O].WerewolfTime := 0;
      Players[O].RoadSkillDelay := 0;
      Players[O].FieldSkillDelay := 0;
      Players[O].WineSkillDelay := AXE_WINE_DELAY * (1 - Round(RECHARGE_FACTOR * Byte(Players[O].ReCharge))) - WEREWOLF_TIME;
    end;

    if (InRange(Players[O].MindAppearTimeBack - States.GameTime, 0, 49))
    and (InRange(Players[O].TempHeroType, 14, 27)) then
    begin
      Players[O].HeroType := Players[O].TempHeroType;
      Players[O].MindAppearTimeBack := 0;
    end;
    
    if TilesRoadLength[O] > 0 then
      for I := 0 to TilesRoadLength[O] - 1 do
        if (SetTilesRoadTimes[O][I] > States.GameTime)
        and (States.GameTime <= Players[O].RoadSkillCancelTime) then
        begin
          SetTilesRoadTimes[O][I] := 0;
          TilesRoadObjects[O][I] := SKILL_CANCEL_OBJ;
        end;

    if TilesFieldLength[O] > 0 then
      for I := 0 to TilesFieldLength[O] - 1 do
        if (SetTilesFieldTimes[O][I] > States.GameTime)
        and (States.GameTime <= Players[O].FieldSkillCancelTime) then
        begin
          SetTilesFieldTimes[O][I] := 0;
          TilesFieldObjects[O][I] := SKILL_CANCEL_OBJ;
        end;

    if TilesWineLength[O] > 0 then
      for I := 0 to TilesWineLength[O] - 1 do
        if (SetTilesWineTimes[O][I] > States.GameTime)
        and (States.GameTime <= Players[O].WineSkillCancelTime) then
        begin
          SetTilesWineTimes[O][I] := 0;
          TilesWineObjects[O][I] := SKILL_CANCEL_OBJ;
        end;
          
    if (InRange(M2[O], 0, 7))
    and Players[M2[O]].MindStunned then
      if TilesWineLength[M2[O]] > 0 then
        for I := 0 to TilesWineLength[M2[O]] - 1 do
          if (SetTilesWineTimes[M2[O]][I] > States.GameTime)
          and (States.GameTime <= Players[M2[O]].WineSkillCancelTime) then
          begin
            SetTilesWineTimes[M2[O]][I] := 0;
            TilesWineObjects[M2[O]][I] := SKILL_CANCEL_OBJ;
          end;

  end;

  if (InRange(aKiller, 9, 11))
  and (InRange(O, 0, 7)) then
  begin

    for I := 0 to 7 do
    begin

      if Players[I].ThreadsAttacker = O then
        Players[I].ThreadsAttacker := -1;

      if Players[I].ScoutSilenceGiver = O then
        Players[I].ScoutSilenceGiver := -1;

      if Players[I].HeroExileGiver = O then
        Players[I].HeroExileGiver := -1;

      if Players[I].ThreadsTarget = O then
      begin
        Players[O].ThreadsTime := 0;
        Players[O].MovedByThreads := False;
        Players[I].ThreadsTarget := -1;
      end;

    end;

    Players[O].TrackStartTime := 0;
    Players[O].TrackStopTime := 0;
    Players[O].SettingTrack := False;
    Players[O].HeroExileTime := 0;
    Players[O].HeroExileBackTime := 0;
    Players[O].HeroExiled := False;
    Players[O].TowerTime := 0;
    Players[O].ReplicaTime := 0;
    Players[O].RiftTime := 0;
    Players[O].MirrorTime := 0;
    RuneCleanupTime[O] := 0;
    Players[O].ThreadsTime := 0;
    Players[O].ThreadsAttackTime := 0;
    if InRange(Players[O].ThreadsTarget, 0, 7) then
      Players[Players[O].ThreadsTarget].ThreadsTime := 0;
    Players[O].ThreadsTarget := -1;

    for K := 0 to SPURT_LENGTH - 1 do
      SpurtTimes[O][K] := 0;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to TotemCirclesLength[O][K] - 1 do
        if (TotemCircles[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].WineSkillCancelTime)
        and (TotemCircles[O][K][I].Obj <> 255) then
          TotemCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to ExpCirclesLength[O][K] - 1 do
        if (ExpCircles[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].WineSkillCancelTime)
        and (ExpCircles[O][K][I].Obj <> 255) then
          ExpCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to RogueCirclesLength[O][K] - 1 do
        if (RogueCircles[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].RoadSkillCancelTime)
        and (RogueCircles[O][K][I].Obj <> 255)  then
          RogueCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to StolenRogueCirclesLength[O][K] - 1 do
        if (StolenRogueCircles[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].RoadSkillCancelTime)
        and (StolenRogueCircles[O][K][I].Obj <> 255)  then
          StolenRogueCircles[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles1Length[O][K] - 1 do
        if (FireworksCircles1[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].FieldSkillCancelTime)
        and (FireworksCircles1[O][K][I].Obj <> 255)  then
          FireworksCircles1[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles2Length[O][K] - 1 do
        if (FireworksCircles2[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].FieldSkillCancelTime)
        and (FireworksCircles2[O][K][I].Obj <> 255)  then
          FireworksCircles2[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles3Length[O][K] - 1 do
        if (FireworksCircles3[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].FieldSkillCancelTime)
        and (FireworksCircles3[O][K][I].Obj <> 255)  then
          FireworksCircles3[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles4Length[O][K] - 1 do
        if (FireworksCircles4[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].FieldSkillCancelTime)
        and (FireworksCircles4[O][K][I].Obj <> 255)  then
          FireworksCircles4[O][K][I].Obj := SKILL_CANCEL_OBJ;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
      for I := 0 to FireworksCircles5Length[O][K] - 1 do
        if (FireworksCircles5[O][K][I].AddTime > States.GameTime)
        and (States.GameTime <= Players[O].FieldSkillCancelTime)
        and (FireworksCircles5[O][K][I].Obj <> 255)  then
          FireworksCircles5[O][K][I].Obj := SKILL_CANCEL_OBJ;

  end;

  if (InRange(aKiller, 9, 11))
  and (InRange(States.UnitOwner(aID), 0, 7))
  and (aID = States.GroupMember(Players[O].Hero, 0)) then
  begin
    if InRange(LastAttacker, 0, 11) then
    begin
      Players[LastAttacker].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
      if not Players[O].CaptureMind then
      begin
        Players[LastAttacker].Kills := Players[LastAttacker].Kills + 1;
        Players[LastAttacker].KillStreak := Players[LastAttacker].KillStreak + 1;
        if not Players[O].MindStunned then
          Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
      end;
      if Players[O].CaptureMind then
      begin
        if Players[LastAttacker].MindStunned then
        begin
          Players[M2[LastAttacker]].Kills := Players[M2[LastAttacker]].Kills + 1;
          Players[M2[LastAttacker]].KillStreak := Players[M2[LastAttacker]].KillStreak + 1;
          Players[O].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
        end;
        if not Players[LastAttacker].MindStunned then 
          for I := 0 to 7 do
            if Players[I].PlayersTeam = Players[LastAttacker].PlayersTeam then
              Actions.PlayWAV(I, 'Retard', 1);
      end;
      
      if (LastAttackerUnitType = 13) then
      begin
        if not (Players[O].CaptureMind)
        and not (Players[O].MindStunned) then
        begin
          Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$105> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$106> ' + '[$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
          if (Players[O].HP > 1)
          and (Players[LastAttacker].DD) then
          begin
            Players[LastAttacker].Kills := Players[LastAttacker].Kills + 1;
            Players[O].HP := Players[O].HP - 1;
          end;
        end;
        if Players[O].CaptureMind then
        begin
          if Players[LastAttacker].MindStunned then
          begin
            Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$84> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + ' [$FFFFFF]<$141>' + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$120> ' + '[]';
          end;
          if not Players[LastAttacker].MindStunned then 
          begin
            Players[M[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
            Players[M[O]].PlayerStatus := Players[M[O]].PlayerStatus + '|<$105> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$106> ' + '[$' + States.PlayerColorText(M[O]) + ']' + States.PlayerName(M[O]) + '[]';
          end;
          if (Players[O].HP > 1)
          and (Players[LastAttacker].DD) then
          begin
            Players[LastAttacker].Kills := Players[LastAttacker].Kills + 1;
            Players[O].HP := Players[O].HP - 1;
          end;
        end;
        if Players[O].MindStunned then
        begin
          Players[M2[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[M2[O]].PlayerStatus := Players[M2[O]].PlayerStatus + '|<$105> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$106> ' + '[$' + States.PlayerColorText(M2[O]) + ']' + States.PlayerName(M2[O]) + '[]';
          if (Players[M2[O]].HP > 1)
          and (Players[LastAttacker].DD) then
          begin
            Players[LastAttacker].Kills := Players[LastAttacker].Kills + 1;
            Players[M2[O]].HP := Players[M2[O]].HP - 1;
          end;
        end;
      end;
      
      if (LastAttackerUnitType = 14) then
      begin
        if not (Players[O].CaptureMind)
        and not (Players[O].MindStunned) then
        begin
          Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$75> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$89> ' + '[$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
        end;
        if Players[O].CaptureMind then
        begin
          if Players[LastAttacker].MindStunned then
          begin
            Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$84> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + ' [$FFFFFF]<$142>' + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$121> ' + '[]';
          end;
          if not Players[LastAttacker].MindStunned then 
          begin
            Players[M[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
            Players[M[O]].PlayerStatus := Players[M[O]].PlayerStatus + '|<$75> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$89> ' + '[$' + States.PlayerColorText(M[O]) + ']' + States.PlayerName(M[O]) + '[]';
          end;
        end;
        if Players[O].MindStunned then
        begin
          Players[M2[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[M2[O]].PlayerStatus := Players[M2[O]].PlayerStatus + '|<$75> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$89> ' + '[$' + States.PlayerColorText(M2[O]) + ']' + States.PlayerName(M2[O]) + '[]';
        end;
      end;
            
      if (InRange(LastAttackerUnitType, 15, 27))
      and (LastAttackerZombieType = 3) then
      begin
        if not (Players[O].CaptureMind)
        and not (Players[O].MindStunned) then
        begin
          Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$76> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$90> ' + '[$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
        end;
        if Players[O].CaptureMind then
        begin
          if Players[LastAttacker].MindStunned then
          begin
            Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$84> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + ' [$FFFFFF]<$143>' + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$122> ' + '[]';
          end;
          if not Players[LastAttacker].MindStunned then 
          begin
            Players[M[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
            Players[M[O]].PlayerStatus := Players[M[O]].PlayerStatus + '|<$76> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$90> ' + '[$' + States.PlayerColorText(M[O]) + ']' + States.PlayerName(M[O]) + '[]';
          end;
        end;
        if Players[O].MindStunned then
        begin
          Players[M2[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[M2[O]].PlayerStatus := Players[M2[O]].PlayerStatus + '|<$76> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$90> ' + '[$' + States.PlayerColorText(M2[O]) + ']' + States.PlayerName(M2[O]) + '[]';
        end;
      end;
            
      if (InRange(LastAttackerUnitType, 15, 27))
      and (LastAttackerZombieType = 2) then
      begin
        if not (Players[O].CaptureMind)
        and not (Players[O].MindStunned) then
        begin
          Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$107> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$108> ' + '[$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
        end;
        if Players[O].CaptureMind then
        begin
          if Players[LastAttacker].MindStunned then
          begin
            Players[O].PlayerStatus := Players[O].PlayerStatus + '|<$84> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + ' [$FFFFFF]<$144>' + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$123> ' + '[]';
          end;
          if not Players[LastAttacker].MindStunned then 
          begin
            Players[M[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
            Players[M[O]].PlayerStatus := Players[M[O]].PlayerStatus + '|<$107> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
            Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$108> ' + '[$' + States.PlayerColorText(M[O]) + ']' + States.PlayerName(M[O]) + '[]';
          end;
        end;
        if Players[O].MindStunned then
        begin
          Players[M2[O]].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[M2[O]].PlayerStatus := Players[M2[O]].PlayerStatus + '|<$107> ' + '[$' + States.PlayerColorText(LastAttacker) + ']' + States.PlayerName(LastAttacker) + '[]';
          Players[LastAttacker].PlayerStatus := Players[LastAttacker].PlayerStatus + '|<$108> ' + '[$' + States.PlayerColorText(M2[O]) + ']' + States.PlayerName(M2[O]) + '[]';
        end;
      end;
            
      Players[O].RespawnCheckTime := States.GameTime + 10;
      if not Players[O].MindStunned then 
      begin
        SetLength(Players[LastAttacker].KillTimes, Length(Players[LastAttacker].KillTimes) + 1);
        Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] := States.GameTime;
          if Length(Players[LastAttacker].KillTimes) >= 4 then
            if (Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] - Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 4] <= RAMPAGE_CHECK_TIME) then
            begin
              Actions.PlayWAV(-1, 'Rampage', 1);
              Players[LastAttacker].Rampage := True;
              Players[LastAttacker].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
            end;
          if Length(Players[LastAttacker].KillTimes) >= 3 then
            if (Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] - Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 3] <= TRIPLE_KILL_CHECK_TIME)
            and (not Players[LastAttacker].TripleKill)
            and (not Players[LastAttacker].Rampage) then
            begin
              Actions.PlayWAV(-1, 'TripleKill', 1);
              Players[LastAttacker].TripleKill := True;
              Players[LastAttacker].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
            end;
          if Length(Players[LastAttacker].KillTimes) >= 2 then
            if (Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 1] - Players[LastAttacker].KillTimes[Length(Players[LastAttacker].KillTimes) - 2] <= DOUBLE_KILL_CHECK_TIME)
            and (not Players[LastAttacker].DoubleKill)
            and (not Players[LastAttacker].TripleKill)
            and (not Players[LastAttacker].Rampage) then
            begin
              Actions.PlayWAV(-1, 'DoubleKill', 1);
              Players[LastAttacker].DoubleKill := True;
              Players[LastAttacker].KillsCountTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
            end;
          if not (Players[LastAttacker].DoubleKill)
          and not (Players[LastAttacker].TripleKill) then
            Players[LastAttacker].TempKill := O;
          if not (Players[LastAttacker].TripleKill) then
            Players[LastAttacker].TempKill2 := O;
          for K := 0 to 7 do
          begin
            if Players[K].Kills > 0 then
              if not FirstBlood then
                for I := 0 to 7 do
                begin
                  Actions.PlayWAV(-1, 'FirstBlood', 1);
                  FirstBlood := True;
                  Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$124>' + '[$' + States.PlayerColorText(O) + '] ' + States.PlayerName(O)+ '[]';
                end;
              if Players[K].DoubleKill then
                for I := 0 to 7 do
                begin
                  Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$125>' + '[$' + States.PlayerColorText(Players[K].TempKill) + '] ' + States.PlayerName(Players[K].TempKill) + ' [$FFFFFF]<$128>' + ' [$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
                  Players[K].DoubleKill := False;
                end;
              if Players[K].TripleKill then
                for I := 0 to 7 do
                begin
                  Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$126>' + '[$' + States.PlayerColorText(Players[K].TempKill) + '] ' + States.PlayerName(Players[K].TempKill) +',[$' + States.PlayerColorText(Players[K].TempKill2) + '] ' + States.PlayerName(Players[K].TempKill2) + ' [$FFFFFF]<$128>' + ' [$' + States.PlayerColorText(O) + ']' + States.PlayerName(O) + '[]';
                  Players[K].TripleKill := False;
                end;
              if Players[K].Rampage then
                for I := 0 to 7 do
                begin
                  Players[I].KillStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStatus := '[$' + States.PlayerColorText(K) + ']' + States.PlayerName(K) + ' [$FFFFFF]<$127>' + '[]';
                end;
              if KILL_STREAK then
              for I := 0 to 7 do
              begin
                if Players[I].KillStreak = 4 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$129>' + '[]';
                end;
                if Players[I].KillStreak = 6 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$130>' + '[]';
                end;
                if Players[I].KillStreak = 8 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$131>' + '[]';
                end;
                if Players[I].KillStreak = 10 then
                begin
                  Players[I].KillStreakStatusTime := States.GameTime + MAX_TIME_BETWEEN_KILLS;
                  Players[I].KillStreakStatus := '[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + ' [$FFFFFF]<$132>' + '[]';
                end;
              end;
          end;   
      end;
    end;
    if Players[O].HP > 0 then
    begin 
      Players[O].Hero := -1;
      Players[O].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(O), AI_TEMP_PLAYER, TEMP_PLAYER), Players[O].HeroType, Players[O].TempX, Players[O].TempY, 4, 1, 1);
      Players[O].HeroReborn := True;
      Players[O].RebornTime := States.GameTime + REBORN_TIME;
      if not (Players[O].CaptureMind)
      and not (Players[O].MindStunned) then
        Players[States.UnitOwner(aID)].HP := Players[States.UnitOwner(aID)].HP - 1;
      if Players[O].CaptureMind then
      begin
        Players[M[O]].HP := Players[M[O]].HP - 1;
        Players[M[O]].RebornMindTime2 := States.GameTime + REBORN_TIME;
      end;
      if Players[O].MindStunned then
        begin
          Players[M2[O]].RebornMindTime := States.GameTime + REBORN_TIME;
          Players[M2[O]].HP := Players[M2[O]].HP - 1;
          Actions.GroupBlockOrders(Players[O].Hero, True);
          Actions.GroupOrderHalt(Players[O].Hero);
        end;
    end;
    Actions.GroupHungerSet(Players[O].Hero, States.UnitMaxHunger);
  end;
end;


procedure RandomChoice;
var
  I: Integer;
begin
  for I := 0 to 7 do
    if (States.PlayerEnabled(I)) then
      if (not Players[I].HeroChosen)
      and (Players[I].Hero = -1) then
      begin
        if (States.PlayerIsAI(I))
        and (not AI_ENABLED) then
          Exit;
        Players[I].HeroType := States.KaMRandomI(12) + 15;
        Players[I].HeroChosen := True;
        Players[I].TempHeroType := Players[I].HeroType;
      end;
end;


procedure SetHeroes;
var
  I, J, K: Integer;
begin

  for J := 0 to Length(AISoldiers) - 1 do
    if States.GroupOwner(AISoldiers[J]) <> 8 then
      Actions.GroupKillAll(AISoldiers[J], True);

  for I := 4 to 7 do
    if States.PlayerEnabled(I) then
      Actions.PlayerAllianceChange(I, 8, True, False);

  for I := 0 to 7 do
    if Players[I].HeroChosen then
    begin
      Players[I].HeroTotalImmunity := True;
      Players[I].HeroTotalImmunityTime := States.GameTime + TOTAL_IMMUNITY_TIME;
      Players[I].Hero := Actions.GiveGroup(I, Players[I].HeroType, Players[I].SpawnX, Players[I].SpawnY, Players[I].Direction, 1, 1);
      Actions.GroupHungerSet(Players[I].Hero, States.UnitMaxHunger);
      Actions.CinematicStart(I);
      Actions.CinematicPanTo(I, Players[I].SpawnX, Players[I].SpawnY, 0);
      Actions.CinematicEnd(I);
    end;

  for K := 0 to 7 do
    if States.PlayerEnabled(K) then
    begin
      Actions.FogCoverAll(K);
      Actions.FogRevealRect(K, 1, 39, 70, 109);
    end;

  Actions.ShowMsg(-1, '<$62>');

  Actions.ShowMsg(-1, '<$63>');

end;


procedure UnlockDebug;
var
  I: Integer;
begin
  if not DEBUG_MODE then
    Exit;
  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      Actions.HouseAllow(I, 27, True);
      Actions.HouseUnlock(I, 27);
      Actions.HouseAllow(I, 14, True);
      Actions.HouseUnlock(I, 14);
      Actions.HouseAllow(I, 9, True);
      Actions.HouseUnlock(I, 9);
      Actions.HouseAllow(I, 11, True);
      Actions.HouseUnlock(I, 11);
      Actions.HouseAllow(I, 3, True);
      Actions.HouseUnlock(I, 3);
    end;
end;


procedure CheckTowers;
var
  I, K: Integer;
var
  TowersLeft, TowersRight: array of Integer;
begin
  TowersLeft := States.PlayerGetAllHouses(10);
  TowersRight := States.PlayerGetAllHouses(11);

  if Length(TowersLeft) > 0 then
    for I := 0 to Length(TowersLeft) - 1 do
      Actions.HouseAddDamage(TowersLeft[I], 3);

  if Length(TowersRight) > 0 then
    for K := 0 to Length(TowersRight) - 1 do
      Actions.HouseAddDamage(TowersRight[K], 3);

end;


procedure CheckTowersTiles;
var
  TowersLeft, TowersRight: array of Integer;
  I, K, X, Y, X1, Y1: Integer;
begin
  TowersLeft := States.PlayerGetAllHouses(10);
  TowersRight := States.PlayerGetAllHouses(11);

  if Length(TowersLeft) > 0 then
    for I := 0 to Length(TowersLeft) - 1 do
    if TowersLeft[I] > 0 then
      begin
        X := States.HousePositionX(TowersLeft[I]);
        Y := States.HousePositionY(TowersLeft[I]);
        for X1 := X - 2 to X + 1 do
        for Y1 := Y - 2 to Y + 1 do
          if TileOnBattlefield(X1, Y1) then
          begin
            if InRange(States.HouseDamage(TowersLeft[I]), 185, 190) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE - 3, Tiles[X1][Y1].TileDirection);
            if InRange(States.HouseDamage(TowersLeft[I]), 191, 195) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE - 2, Tiles[X1][Y1].TileDirection);
            if InRange(States.HouseDamage(TowersLeft[I]), 196, 200) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE - 1, Tiles[X1][Y1].TileDirection);
            if InRange(States.HouseDamage(TowersLeft[I]), 201, 250) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE, Tiles[X1][Y1].TileDirection);
          end;
      end;

  if Length(TowersRight) > 0 then
    for K := 0 to Length(TowersRight) - 1 do
      if TowersRight[K] > 0 then
      begin
        X := States.HousePositionX(TowersRight[K]);
        Y := States.HousePositionY(TowersRight[K]);
        for X1 := X - 2 to X + 1 do
        for Y1 := Y - 2 to Y + 1 do
          if TileOnBattlefield(X1, Y1) then
          begin
            if InRange(States.HouseDamage(TowersRight[K]), 185, 190) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE - 3, Tiles[X1][Y1].TileDirection);
            if InRange(States.HouseDamage(TowersRight[K]), 191, 195) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE - 2, Tiles[X1][Y1].TileDirection);
            if InRange(States.HouseDamage(TowersRight[K]), 196, 200) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE - 1, Tiles[X1][Y1].TileDirection);
            if InRange(States.HouseDamage(TowersRight[K]), 201, 250) then
              Actions.MapTileSet(X1, Y1, INFERNAL_TILE, Tiles[X1][Y1].TileDirection);
          end;
      end;

end;


//CHECK STATUS


procedure CheckHP(P: Integer);
begin
  try
    if Players[P].HP < 0 then
      Players[P].HP := 0;

    if Players[P].HP > MAX_HP then
      Players[P].HP := MAX_HP;

    if Players[P].HP = 0 then
    begin
      Players[P].HeroReborn := False;
      Players[P].RebornTime := 0;
      if Players[P].CaptureMind then
      begin
        Players[M[P]].HeroReborn := False;
        Players[M[P]].RebornTime := 0;
      end;
      if not (Players[P].MovedToTribune)
      and not (Players[P].CaptureMind) then
      begin
        if Players[P].MindStunned then
        begin
          Players[P].HeroType := Players[P].HeroMindType;
          Players[M[P]].MindX := States.UnitPositionX(States.GroupMember(Players[M[P]].Hero, 0));
          Players[M[P]].MindY := States.UnitPositionY(States.GroupMember(Players[M[P]].Hero, 0));
          Players[M[P]].MindDir := States.UnitDirection(States.GroupMember(Players[M[P]].Hero, 0));
          Players[P].StunnedMindTime := States.GameTime + 1;
          Players[M2[P]].CaptureMindTime := States.GameTime + 1;
        end;
        Actions.FogRevealAll(P);
        Actions.CinematicStart(P);
        Actions.CinematicPanTo(P, Players[P].TribuneX, Players[P].TribuneY, 0);
        Actions.CinematicEnd(P);
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].TribuneX, Players[P].TribuneY, 4, 1, 1);
        Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
        Actions.GroupBlockOrders(Players[P].Hero, True);
        Players[P].MovedToTribune := True;
      end;
    end;

    if (Players[P].HP <= 0)
    and (not States.FogRevealed(P, 2, 40)) then
      Actions.FogRevealAll(P);

    if (Players[P].HP <= 0)
    and (Players[P].MovedToTribune) then
      Actions.GroupBlockOrders(Players[P].Hero, True);

    if (Players[P].HP > 0)
    and (States.FogRevealed(P, Players[P].TempX, Players[P].TempY))
    and (not States.PlayerVictorious(P)) then
    begin
      Actions.FogCoverAll(P);
      Actions.FogRevealRect(P, 1, 39, 70, 109);
    end;

  except
    LogError('Exception in the script: cannot update HP for invalid player:', [P], SHOW_ERROR_MSG);
  end;

end;


procedure CheckExile(P: Integer);
begin
  try
    if (States.GameTime = Players[P].HeroExileTime)
    and (InRange(Players[P].HeroExileGiver, 0, 7)) then
    begin
      if (InRange(Players[P].WerewolfTime - States.GameTime, 0, 49))
      and (InRange(Players[P].TempHeroType, 14, 27)) then
      begin
        Players[P].HeroType := Players[P].TempHeroType;
        Players[P].WerewolfTime := 0;
        Players[P].RoadSkillDelay := 0;
        Players[P].FieldSkillDelay := 0;
        Players[P].WineSkillDelay := AXE_WINE_DELAY * (1 - Round(RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - WEREWOLF_TIME;
      end;
      Players[P].HeroExileX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Players[P].HeroExileY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      Players[P].HeroExileDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      Players[P].HeroExileBackTime := States.GameTime + EXILE_TIME;
      Actions.MapTileSet(Players[P].HeroExileX, Players[P].HeroExileY, EXILE_TILE, States.KaMRandomI(4));
      if (P <> Players[P].HeroExileGiver) 
      and (not Players[P].MindStunned) then
      begin
        Players[P].PlayerStatusTime := States.GameTime + EXILE_TIME + 5;
        Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$110> ' + '[$' + States.PlayerColorText(Players[P].HeroExileGiver) + ']' + States.PlayerName(Players[P].HeroExileGiver) + '[]';
        Players[Players[P].HeroExileGiver].PlayerStatusTime := States.GameTime + EXILE_TIME + 5;
        Players[Players[P].HeroExileGiver].PlayerStatus := Players[Players[P].HeroExileGiver].PlayerStatus + '|<$111> ' + '[$' + States.PlayerColorText(P) + ']' + States.PlayerName(P) + '[]';
      end;
    end;
  except
    LogError('Exception in the script: cannot update Exile status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckExileTile(P: Integer);
begin
  try
    if States.GameTime < Players[P].HeroExileBackTime then
      if States.MapTileType(Players[P].HeroExileX, Players[P].HeroExileY) <> EXILE_TILE then
        Actions.MapTileSet(Players[P].HeroExileX, Players[P].HeroExileY, EXILE_TILE, States.KaMRandomI(4));
  except
    LogError('Exception in the script: cannot update Exile tile for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckExileBack(P: Integer);
var
  U: Integer;
begin
  try
    if States.GameTime = Players[P].HeroExileBackTime then
    begin
      U := States.UnitAt(Players[P].HeroExileX, Players[P].HeroExileY);
      Players[P].HeroExiled := False;
      Actions.GroupKillAll(Players[P].Hero, True);
      if U <= 0 then
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].HeroExileX, Players[P].HeroExileY, Players[P].HeroExileDir, 1, 1)
      else
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].HeroExileX + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].HeroExileY + States.KaMRandomI(2) - States.KaMRandomI(2), Players[P].HeroExileDir, 1, 1);
      Actions.MapTileSet(Players[P].HeroExileX, Players[P].HeroExileY, Tiles[Players[P].HeroExileX][Players[P].HeroExileY].TileType, Tiles[Players[P].HeroExileX][Players[P].HeroExileY].TileDirection);
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    end;
  except
    LogError('Exception in the script: cannot update Exile Back status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckReborn(P: Integer);
begin
  try
    if States.GameTime = Players[P].RebornTime then
    begin
      if (InRange(P, 0, 3))
      and (not States.PlayerAllianceCheck(Players[4].ZombiePlayer, P)) then
        Actions.PlayerAllianceChange(Players[4].ZombiePlayer, P, True, True);
      if (InRange(P, 4, 7))
      and (not States.PlayerAllianceCheck(Players[0].ZombiePlayer, P)) then
        Actions.PlayerAllianceChange(Players[0].ZombiePlayer, P, True, True);
      Players[P].HeroTotalImmunity := True;
      Players[P].HeroTotalImmunityTime := States.GameTime + TOTAL_IMMUNITY_TIME;
      Actions.GroupKillAll(Players[P].Hero, True);
      if Players[P].MindStunned then
        Players[P].Hero := Actions.GiveGroup(M2[P], Players[M2[P]].HeroMindType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
      if not Players[P].MindStunned then
      begin
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
        Actions.CinematicStart(P);
        Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
        Actions.CinematicEnd(P);
      end;
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      Players[P].KillStreak := 0;
      Players[P].HeroReborn := False;
    end;
  except
    LogError('Exception in the script: cannot check Reborn status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckThreadsPrepare(P: Integer);
begin
  try
    if (States.GameTime = Players[P].ThreadsTime - DELAY_OF_TURNING)
    and (InRange(Players[P].ThreadsAttacker, 0, 7)) then
      if Players[Players[P].ThreadsAttacker].ThreadsAttackTime > 0 then
      begin
        Players[P].ThreadsX := IfThen(States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) >= CurrentMinY, States.UnitPositionX(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)), Players[Players[P].ThreadsAttacker].LastX);
        Players[P].ThreadsY := IfThen(States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)) >= CurrentMinY, States.UnitPositionY(States.GroupMember(Players[Players[P].ThreadsAttacker].Hero, 0)), Players[Players[P].ThreadsAttacker].LastY);
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      end;
  except
    LogError('Exception in the script: cannot check Threads Prepare status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckThreads(P: Integer);
var
  StunnedByControl: Boolean;
begin
  try

    if (States.GameTime = Players[P].ThreadsTime)
    and (InRange(Players[P].ThreadsAttacker, 0, 7)) then
    begin
      StunnedByControl := (Players[Players[P].ThreadsAttacker].HeroStunned)
                          and (not Players[Players[P].ThreadsAttacker].Preparing);
      if (not Players[Players[P].ThreadsAttacker].HeroReborn)
      and (not Players[Players[P].ThreadsAttacker].HeroInFear)
      and (not Players[Players[P].ThreadsAttacker].HeroSilent)
      and (not StunnedByControl) then
      if Players[Players[P].ThreadsAttacker].ThreadsAttackTime > 0 then
        begin
          Actions.GroupKillAll(Players[P].Hero, True);
          Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].ThreadsDX + Players[P].ThreadsX, Players[P].ThreadsDY + Players[P].ThreadsY, Players[P].ThreadsUnitDir, 1, 1);
          Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
          if (Players[P].HeroStunned)
          or (Players[P].HeroInFear) then
            Actions.GroupBlockOrders(Players[P].Hero, True);
          Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
          Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$72> ' + '[$' + States.PlayerColorText(Players[P].ThreadsAttacker) + ']' + States.PlayerName(Players[P].ThreadsAttacker) + '[]<$71> ' + SkillName(sThreadsOfDeath);
        end;
      end;

    if (States.GameTime >= Players[P].ThreadsTime + THREADS_DELAY)
    and (Players[P].MovedByThreads) then
      Players[P].MovedByThreads := False;

  except
    LogError('Exception in the script: cannot check Threads status for invalid player:', [P], SHOW_ERROR_MSG);
  end;

end;


procedure CheckZombiesThreads(P: Integer);
var
  I, Z, H: Integer;
begin
  try
    if (States.GameTime = Players[P].ThreadsAttackTime)
    and (Length(Zombies) > 0) then
    begin
      CheckZombieArray;
      for I := 0 to Length(Zombies) - 1 do
        if (Zombies[I].ZombieThreadsTime = States.GameTime)
        and (not States.UnitDead(Zombies[I].ZombieID)) then
        begin
          H := States.UnitHunger(Zombies[I].ZombieID);
          SetLength(Zombies, Length(Zombies) + 1);
          Zombies[Length(Zombies) - 1].ZombieOwner := Zombies[I].ZombieOwner;
          Zombies[Length(Zombies) - 1].ZombieThreadsDir := States.UnitDirection(Zombies[I].ZombieID);
          Zombies[Length(Zombies) - 1].ZombieThreadsX := FrontX(P);
          Zombies[Length(Zombies) - 1].ZombieThreadsY := FrontY(P);
          Z := Actions.GiveGroup(Players[Zombies[I].ZombieOwner].ZombiePlayer, States.UnitType(Zombies[I].ZombieID), Zombies[Length(Zombies) - 1].ZombieThreadsX, Zombies[Length(Zombies) - 1].ZombieThreadsY, Zombies[Length(Zombies) - 1].ZombieThreadsDir, 1, 1);
          Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
          Zombies[Length(Zombies) - 1].ZombieType := Zombies[I].ZombieType;
          Actions.GroupHungerSet(Z, H);
          Actions.UnitKill(Zombies[I].ZombieID, True);
        end;
      end;
  except
    LogError('Exception in the script: cannot check zombies to move for invalid owner:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckLure(P: Integer);
var
  Z: Integer;
begin
  try
    if States.GameTime = Players[P].LureTime then
    begin
       SetLength(Zombies, Length(Zombies) + 1);
       Zombies[Length(Zombies) - 1].ZombieOwner := P;
       Zombies[Length(Zombies) - 1].ZombieType := Players[P].LureZombieType;
       Z := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].LureType, Players[P].LureX, Players[P].LureY, Players[P].LureDir, 1, 1);
       Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
       Actions.GroupHungerSet(Z, Players[P].LureHunger);
    end;
  except
    LogError('Exception in the script: cannot check lured zombies for invalid owner:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckReplica(P: Integer);
var
  I, Z: Integer;
  R: Single;
  Lure: Boolean;
begin
  try
    if States.GameTime = Players[P].ReplicaTime then
    begin
      if (InRange(Players[P].ReplicaTarget, 0, 7))
      and (Players[P].Hero > 0)
      and (Players[Players[P].ReplicaTarget].Hero > 0) then
      begin
        Players[P].ReplicaX := IfThen(TileOnBattlefield(States.UnitPositionX(States.GroupMember(Players[Players[P].ReplicaTarget].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[Players[P].ReplicaTarget].Hero, 0))), BackX(Players[P].ReplicaTarget), Players[Players[P].ReplicaTarget].LastX);
        Players[P].ReplicaY := IfThen(TileOnBattlefield(States.UnitPositionX(States.GroupMember(Players[Players[P].ReplicaTarget].Hero, 0)), States.UnitPositionY(States.GroupMember(Players[Players[P].ReplicaTarget].Hero, 0))), BackY(Players[P].ReplicaTarget), Players[Players[P].ReplicaTarget].LastY);
        Players[P].ReplicaDir := States.UnitDirection(States.GroupMember(Players[Players[P].ReplicaTarget].Hero, 0));
        SetLength(Zombies, Length(Zombies) + 1);
        Zombies[Length(Zombies) - 1].ZombieOwner := P;
        Z := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].ReplicaType, Players[P].ReplicaX, Players[P].ReplicaY, Players[P].ReplicaDir, 1, 1);
        Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
        Zombies[Length(Zombies) - 1].ZombieType := 3;
        Actions.GroupHungerSet(Z, REBEL_ZOMBIE_LIFE * (1 + Byte(Players[P].DD)));
      end;

      if Length(Zombies) > 0 then
        for I := 0 to Length(Zombies) - 1 do
          if (Zombies[I].ZombieKillTime = States.GameTime)
          and (not States.UnitDead(Zombies[I].ZombieID)) then
          begin
            R := States.KaMRandom;
            Lure := R < REPLICA_LURE_CHANCE;
            if Lure then
            begin
              Players[P].LureType := States.UnitType(Zombies[I].ZombieID);
              Players[P].LureX := States.UnitPositionX(Zombies[I].ZombieID);
              Players[P].LureY := States.UnitPositionY(Zombies[I].ZombieID);
              Players[P].LureDir := States.UnitDirection(Zombies[I].ZombieID);
              Players[P].LureTime := States.GameTime + DELAY_OF_TURNING;
              Players[P].LureHunger := States.UnitHunger(Zombies[I].ZombieID);
              Players[P].LureZombieType := Zombies[I].ZombieType;
            end;
            Actions.UnitKill(Zombies[I].ZombieID, Lure);
          end;
    end;
  except
    LogError('Exception in the script: cannot check Replica status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckRift(P: Integer);
var
  I, K, Z: Integer;
begin
  try
    if States.GameTime = Players[P].RiftTime then
    begin
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].RiftX, Players[P].RiftY, Players[P].RiftDir, 1, 1);
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      if Length(Zombies) > 0 then
        for I := 0 to Length(Zombies) - 1 do
          if (Zombies[I].ZombieOwner = P)
          and (Zombies[I].ZombieTeleportTime = States.GameTime)
          and (not States.UnitDead(Zombies[I].ZombieID)) then
          begin
            SetLength(Zombies, Length(Zombies) + 1);
            Zombies[Length(Zombies) - 1].ZombieOwner := P;
            Zombies[Length(Zombies) - 1].ZombieType := Zombies[I].ZombieType;
            Zombies[Length(Zombies) - 1].ZombieHunger := States.UnitHunger(Zombies[I].ZombieID);
            Zombies[Length(Zombies) - 1].ZombieTeleportTime := Zombies[I].ZombieTeleportTime;
            Zombies[Length(Zombies) - 1].ZombieKillTime := Zombies[I].ZombieKillTime;
            Zombies[Length(Zombies) - 1].ZombieThreadsTime := Zombies[I].ZombieThreadsTime;
            Zombies[Length(Zombies) - 1].ZombieThreadsX := Zombies[I].ZombieThreadsX;
            Zombies[Length(Zombies) - 1].ZombieThreadsY := Zombies[I].ZombieThreadsY;
            Zombies[Length(Zombies) - 1].ZombieThreadsDir := Zombies[I].ZombieThreadsDir;
            Z := Actions.GiveGroup(Players[P].ZombiePlayer, States.UnitType(Zombies[I].ZombieID), Players[P].RiftX, Players[P].RiftY, States.KaMRandomI(8), 1, 1);
            Actions.GroupHungerSet(Z, Zombies[Length(Zombies) - 1].ZombieHunger);
            Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
            Actions.UnitKill(Zombies[I].ZombieID, True);
          end;
      for K := 0 to RIFT_ADD_ILLUSIONS - 1 do
      begin
        SetLength(Zombies, Length(Zombies) + 1);
        Zombies[Length(Zombies) - 1].ZombieOwner := P;
        Z := Actions.GiveGroup(Players[P].ZombiePlayer, Players[P].HeroType, Players[P].RiftX + States.KaMRandomI(3) - States.KaMRandomI(3), Players[P].RiftY + States.KaMRandomI(3) - States.KaMRandomI(3), Players[P].RiftDir, 1, 1);
        Zombies[Length(Zombies) - 1].ZombieID := States.GroupMember(Z, 0);
        Zombies[Length(Zombies) - 1].ZombieType := 3;
        Actions.GroupHungerSet(Z, REBEL_ZOMBIE_LIFE * (1 + Byte(Players[P].DD)));
      end;
    end;
  except
    LogError('Exception in the script: cannot check Rift status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckTeleport(P: Integer);
begin
  try
    if States.GameTime = Players[P].TeleportTime then
    begin
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].TeleportX, Players[P].TeleportY, Players[P].TeleportDir, 1, 1);
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    end;
  except
    LogError('Exception in the script: cannot check teleport for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckVaga(P: Integer);
begin
  try
    if States.GameTime = Players[P].VagaAppearTime then
    begin
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, 27, Players[P].VagaX, Players[P].VagaY, Players[P].VagaDir, 1, 1);
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      Players[P].WerewolfTime := States.GameTime + WEREWOLF_TIME;
      if Players[P].HP > 0 then
      begin
        Actions.FogCoverAll(P);
        Actions.FogRevealRect(P, 1, 39, 70, 109);
      end;
    end;
  except
    LogError('Exception in the script: cannot check Vagabond appear status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckWerewolf(P: Integer);
begin
  try
    if States.GameTime = Players[P].WerewolfTime then
    begin
      Players[P].VagaX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Players[P].VagaY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      Players[P].VagaDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      Players[P].VagaAppearTimeBack := States.GameTime + DELAY_OF_TURNING;
      if Players[P].HP > 0 then
      begin
        Actions.FogCoverAll(P);
        Actions.FogRevealRect(P, 1, 39, 70, 109);
      end;
    end;
  except
    LogError('Exception in the script: cannot check Werewolf status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckVagaBack(P: Integer);
begin
  try
    if States.GameTime = Players[P].VagaAppearTimeBack then  
    begin
      if Players[P].Hero > 0 then   
      begin
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, Players[P].VagaX, Players[P].VagaY, Players[P].VagaDir, 1, 1);
        Players[P].HeroType := Players[P].TempHeroType;
        Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
        Players[P].RoadSkillDelay := 0;
        Players[P].FieldSkillDelay := 0;
        Players[P].WineSkillDelay := AXE_WINE_DELAY * (1 - Round(RECHARGE_FACTOR * Byte(Players[P].ReCharge))) - WEREWOLF_TIME;
        Players[P].SettingTrack := False;
        if Players[P].HP > 0 then
        begin
          Actions.FogCoverAll(P);
          Actions.FogRevealRect(P, 1, 39, 70, 109);
        end;
      end;
    end;
  except
    LogError('Exception in the script: cannot check Vagabond appear back status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckFieryTrack(P: Integer);
begin
  try

    if States.GameTime = Players[P].TrackStartTime then
    begin
      Players[P].SettingTrack := True;
      Players[P].TrackStopTime := States.GameTime + TRACK_TIME;
    end;

    if States.GameTime = Players[P].TrackStopTime then
      Players[P].SettingTrack := False;

    if (Players[P].SettingTrack)
    and ((States.GameTime - Players[P].TrackStopTime) mod TRACK_FACTOR = 0)
    and (States.GroupOwner(Players[P].Hero) = P)
    and (Players[P].Hero > 0)
    and (Players[P].HP > 0)
    and (TileOnBattlefield(BackX(P), BackY(P))) then
    begin
      TilesFieldLength[P] := TilesFieldLength[P] + 1;
      SetLength(TilesFieldX[P], TilesFieldLength[P]);
      SetLength(TilesFieldY[P], TilesFieldLength[P]);
      SetLength(ClearTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(SetTilesFieldTimes[P], TilesFieldLength[P]);
      SetLength(TilesFieldObjects[P], TilesFieldLength[P]);  
      TilesFieldX[P][Length(TilesFieldX[P]) - 1] := BackX(P);    
      TilesFieldY[P][Length(TilesFieldY[P]) - 1] := BackY(P);
      Tiles[BackX(P)][BackY(P)].TrackTime := Players[P].TrackStopTime + 5;
      TilesFieldObjects[P][Length(TilesFieldObjects[P]) - 1] := VAGA_OBJECT8;    
      ClearTilesFieldTimes[P][Length(ClearTilesFieldTimes[P]) - 1] := Players[P].TrackStopTime + 3;    
      SetTilesFieldTimes[P][Length(SetTilesFieldTimes[P]) - 1] := States.GameTime + 1;
      Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - 1]][TilesFieldY[P][Length(TilesFieldY[P]) - 1]].Owner := P;
      Tiles[TilesFieldX[P][Length(TilesFieldX[P]) - 1]][TilesFieldY[P][Length(TilesFieldY[P]) - 1]].Skill := sTrack;
    end;

  except
    LogError('Exception in the script: cannot check Fiery Track status for invalid player:', [P], SHOW_ERROR_MSG);
  end;

end;


procedure CheckFear(P: Integer);
var
  aX, aY: Integer;
begin
  try

    if Players[P].HeroInFear then
      CancelSkills(P);

    if (Players[P].HeroInFear)
    and not (Players[P].HeroStunned)
    and (Players[P].Hero > 0) then
    begin
      aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      Actions.GroupOrderWalk(Players[P].Hero, aX + States.KaMRandomI(3) - States.KaMRandomI(3), aY + States.KaMRandomI(3) - States.KaMRandomI(3), States.KaMRandomI(8));
    end;

    if (States.GameTime >= Players[P].HeroInFearTime)
    and (Players[P].HeroInFear)
    and (Players[P].Hero > 0) then
    begin
      Players[P].HeroInFear := False;
      Actions.GroupBlockOrders(Players[P].Hero, False);
      Actions.GroupOrderHalt(Players[P].Hero);
    end;

  except
    LogError('Exception in the script: cannot check Fear status for invalid player:', [P], SHOW_ERROR_MSG);
  end;

end;


procedure CheckZombieStun(P: Integer);
var
  K: Integer;
begin
  try

    if States.GameTime = Players[P].ZombieStunTime then
      if Length(Zombies) > 0 then
        for K := 0 to Length(Zombies) - 1 do
          if not States.UnitDead(Zombies[K].ZombieID) then
            if (Zombies[K].ZombieOwner = P)
            and (InRange(Zombies[K].ZombieType, 1, 2)) then
              if not States.UnitDead(Zombies[K].ZombieID) then
                ZombieStun(P, Zombies[K].ZombieID);

  except
    LogError('Exception in the script: cannot check Stun for invalid Zombie:', [P], SHOW_ERROR_MSG);
  end;

end;


procedure CheckMind(P: Integer);
begin
  try
    if States.GameTime = Players[P].MindTime then
    begin
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[M[P]].MindX, Players[M[P]].MindY, Players[M[P]].MindDir, 1, 1);
      Actions.GroupKillAll(Players[M[P]].Hero, True);
      Players[M[P]].Hero := Actions.GiveGroup(M[P], Players[M[P]].HeroType, Players[P].MindX, Players[P].MindY, Players[P].MindDir, 1, 1);
      Actions.GroupBlockOrders(Players[P].Hero, True);
      Actions.GroupOrderHalt(Players[P].Hero); 
      Actions.GroupBlockOrders(Players[M[P]].Hero, True);
      Actions.GroupOrderHalt(Players[M[P]].Hero);  
      Players[P].MindTime2 := States.GameTime + 30;
      Players[M[P]].HeroStunned := True;
      Players[M[P]].HeroStunnedTime := States.GameTime + 30;
      Actions.FogCoverAll(P);
      Actions.FogRevealRect(P, 1, 39, 70, 109);
      Actions.FogCoverAll(M[P]);
      Actions.FogRevealRect(M[P], 1, 39, 70, 109);
    end;
  except
    LogError('Exception in the script: cannot check Mind status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckMind2(P: Integer);
begin
  try
    if States.GameTime = Players[P].MindTime2 then
    begin
      if (Players[P].HeroExiled)
      or (Players[M[P]].HeroExiled) then
      begin
        Players[P].WineSkillDelay := Round((SCOUT_WINE_DELAY + CAPTURE_MIND_TIME) * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        Players[P].CaptureMind := False;
        Players[M[P]].MindStunned := False;
        Actions.GroupBlockOrders(Players[P].Hero, False);
      end;
      if (Players[P].CaptureMind)
      and (Players[M[P]].MindStunned) then
      begin
        Players[P].TempSpawnX := Players[P].SpawnX;
        Players[P].TempSpawnY := Players[P].SpawnY;
        Players[M[P]].TempSpawnX := Players[M[P]].SpawnX;
        Players[M[P]].TempSpawnY := Players[M[P]].SpawnY;
        Players[P].SpawnX := Players[M[P]].SpawnX;
        Players[P].SpawnY := Players[M[P]].SpawnY;
        Players[M[P]].SpawnX := Players[P].TempSpawnX;
        Players[M[P]].SpawnY := Players[P].TempSpawnY;
        Players[P].TempDirection := Players[P].Direction;
        Players[M[P]].TempDirection := Players[M[P]].Direction;
        Players[P].Direction := Players[M[P]].Direction;
        Players[M[P]].Direction := Players[P].TempDirection;
        Players[M[P]].TempLastX := Players[M[P]].LastX;
        Players[M[P]].TempLastY := Players[M[P]].LastY;
        Players[M[P]].LastX := Players[P].LastX;
        Players[M[P]].LastY := Players[P].LastY;        
        Players[P].HeroMindType := Players[P].HeroType;
        Players[M[P]].HeroMindType := Players[M[P]].HeroType;
        Players[P].TempHeroMindType := Players[P].TempHeroType;
        Players[P].TempStolenSkill := Players[P].StolenSkill;
        Players[P].TempStolenSkillTime := Players[P].StolenSkillTime;
        Players[P].TempStolenSkillName := Players[P].StolenSkillName;
        Players[P].TempReCharge := Players[P].ReCharge;
        Players[P].TempReChargeTime := Players[P].ReChargeTime;
        Players[P].TempDD := Players[P].DD;
        Players[P].TempDDTime := Players[P].DDTime;
        Players[P].TempHeroMagicImmunity :=  Players[P].HeroMagicImmunity;
        Players[P].TempHeroMagicImmunityTime := Players[P].HeroMagicImmunityTime;
        Players[P].TempHeroTotalImmunity :=  Players[P].HeroTotalImmunity;
        Players[P].TempHeroTotalImmunityTime := Players[P].HeroTotalImmunityTime;          
        Players[P].MindX := States.UnitPositionX(States.GroupMember(Players[M[P]].Hero, 0));
        Players[P].MindY := States.UnitPositionY(States.GroupMember(Players[M[P]].Hero, 0));
        Players[P].MindDir := States.UnitDirection(States.GroupMember(Players[M[P]].Hero, 0));
        Players[M[P]].MindX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
        Players[M[P]].MindY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
        Players[M[P]].MindDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
        Actions.GroupKillAll(Players[M[P]].Hero, True);
        Players[M[P]].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(M[P]), AI_TEMP_PLAYER, TEMP_PLAYER), Players[M[P]].HeroType, Players[M[P]].TempX, Players[M[P]].TempY, 4, 1, 1);
        Players[P].MindAppearTime := States.GameTime + DELAY_OF_TURNING;
        Actions.FogCoverAll(P);
        Actions.FogRevealRect(P, 1, 39, 70, 109);
        Actions.FogCoverAll(M[P]);
        Actions.FogRevealRect(M[P], 1, 39, 70, 109);
      end;
    end;
  except
    LogError('Exception in the script: cannot check Mind2 status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckMindAppear(P: Integer);
begin
  try
    if States.GameTime = Players[P].MindAppearTime then
    begin
      Actions.FogCoverAll(P);
      Actions.FogRevealRect(P, 1, 39, 70, 109);
      Actions.FogCoverAll(M[P]);
      Actions.FogRevealRect(M[P], 1, 39, 70, 109);
      Players[P].WerewolfTime := Players[M[P]].WerewolfTime;
      Players[P].HeroType := Players[M[P]].HeroType;
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[M[P]].HeroType, Players[P].MindX, Players[P].MindY, Players[P].MindDir, 1, 1);
      Players[P].HeroStunned := Players[M[P]].HeroStunned;
      Players[P].HeroStunnedTime := Players[M[P]].HeroStunnedTime;
      Players[M[P]].HeroStunned := True;
      Actions.GroupKillAll(Players[M[P]].Hero, True);
      Players[M[P]].Hero := Actions.GiveGroup(P, Players[P].HeroMindType, Players[M[P]].MindX, Players[M[P]].MindY, Players[M[P]].MindDir, 1, 1);
      Players[P].TempHeroType := Players[M[P]].TempHeroType;
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
      Actions.GroupHungerSet(Players[M[P]].Hero, States.UnitMaxHunger);
      Actions.GroupBlockOrders(Players[M[P]].Hero, True);
      Actions.GroupOrderHalt(Players[M[P]].Hero);  
      Players[P].StolenSkill := Players[M[P]].StolenSkill;
      Players[P].StolenSkillTime := Players[M[P]].StolenSkillTime;
      Players[P].StolenSkillName := Players[M[P]].StolenSkillName;
      Players[P].ReCharge := Players[M[P]].ReCharge;
      Players[P].ReChargeTime := Players[M[P]].ReChargeTime;
      Players[P].DD := Players[M[P]].DD;
      Players[P].DDTime := Players[M[P]].DDTime;
      Players[M[P]].HeroMagicImmunity := Players[P].HeroMagicImmunity;
      Players[M[P]].HeroMagicImmunityTime := Players[P].HeroMagicImmunityTime;
      Players[M[P]].HeroTotalImmunity := Players[P].HeroTotalImmunity;
      Players[M[P]].HeroTotalImmunityTime := Players[P].HeroTotalImmunityTime;
      Players[P].Preparing := Players[M[P]].Preparing;
      Players[P].PreparingTime := Players[M[P]].PreparingTime;
      Players[P].HeroInFear := Players[M[P]].HeroInFear;
      Players[P].HeroInFearTime := Players[M[P]].HeroInFearTime;
      Players[P].SettingTrack := Players[M[P]].SettingTrack;
      Players[P].TrackStopTime := Players[M[P]].TrackStopTime;
      Players[M[P]].SettingTrack := False;
      Players[M[P]].TrackStopTime := 0;
      Players[P].RoadSkillDelay := Players[M[P]].RoadSkillDelay;
      Players[P].FieldSkillDelay := Players[M[P]].FieldSkillDelay;
      Players[P].WineSkillDelay := Players[M[P]].WineSkillDelay;
      Players[P].RocketCharges := Players[M[P]].RocketCharges; 
      Players[P].RocketChargeTime := Players[M[P]].RocketChargeTime;
      Players[P].SnakeCharges := Players[M[P]].SnakeCharges; 
      Players[P].SnakeChargeTime := Players[M[P]].SnakeChargeTime; 
      if Players[M[P]].PlayersTeam = 1 then
      begin
        Players[M[P]].PlayersTeam := 0;
        Players[M[P]].UsedPlayersTeam := True;
      end;
      if (Players[M[P]].PlayersTeam = 0)
      and (not Players[M[P]].UsedPlayersTeam) then
        Players[M[P]].PlayersTeam := 1;
      Players[M[P]].UsedPlayersTeam := False;
      Players[P].HeroMagicImmunity := True;
      Players[P].HeroMagicImmunityTime := States.GameTime + CAPTURE_MIND_TIME;
      Players[M[P]].HeroStunnedTime := States.GameTime + CAPTURE_MIND_TIME;
      Players[M[P]].StunnedMindTime := States.GameTime + CAPTURE_MIND_TIME; 
      Players[P].CaptureMindTime := States.GameTime + CAPTURE_MIND_TIME;
      Players[P].MindMagicImmunityTime := States.GameTime + CAPTURE_MIND_TIME - 10;
    end;
  except
    LogError('Exception in the script: cannot check Mind Appear status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckMindCapture(P: Integer);
begin
  try
    if States.GameTime = Players[P].CaptureMindTime then
    begin
      if Players[M[P]].HP > 0 then 
      begin
        Actions.FogCoverAll(P);
        Actions.FogRevealRect(P, 1, 39, 70, 109);
        Actions.FogCoverAll(M[P]);
        Actions.FogRevealRect(M[P], 1, 39, 70, 109);
        Players[M[P]].MindX := States.UnitPositionX(States.GroupMember(Players[M[P]].Hero, 0));
        Players[M[P]].MindY := States.UnitPositionY(States.GroupMember(Players[M[P]].Hero, 0));
        Players[M[P]].MindDir := States.UnitDirection(States.GroupMember(Players[M[P]].Hero, 0));
        Actions.GroupKillAll(Players[M[P]].Hero, True);
        Players[M[P]].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(M[P]), AI_TEMP_PLAYER, TEMP_PLAYER), Players[M[P]].HeroType, Players[M[P]].TempX, Players[M[P]].TempY, 4, 1, 1);
      end;
      Players[P].MindX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
      Players[P].MindY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));
      Players[P].MindDir := States.UnitDirection(States.GroupMember(Players[P].Hero, 0));
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(IfThen(States.PlayerIsAI(P), AI_TEMP_PLAYER, TEMP_PLAYER), Players[P].HeroType, Players[P].TempX, Players[P].TempY, 4, 1, 1);
      Players[P].MindAppearTimeBack := States.GameTime + DELAY_OF_TURNING;
    end;
  except
    LogError('Exception in the script: cannot check Mind Capture status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckMindBack(P: Integer);
begin
  try
    if States.GameTime = Players[P].MindAppearTimeBack then
    begin
      Players[P].CaptureMind := False;
      Players[M[P]].MindStunned := False;
      if (Players[P].Hero > 0)
      and (Players[M[P]].Hero > 0) then
      begin
        if Players[P].HeroType = 27 then
        begin
          Players[M[P]].WerewolfTime := Players[P].WerewolfTime;
          Players[P].WerewolfTime := 0;
          Players[M[P]].HeroMindType := 27;
        end;          
        Players[P].HeroType := Players[P].HeroMindType;
        Players[M[P]].HeroType := Players[M[P]].HeroMindType;
        Players[P].TempHeroType := Players[P].TempHeroMindType;
        if (not Players[M[P]].HeroReborn)
        and (not Players[M[P]].HeroExiled) then
        begin
          Actions.GroupKillAll(Players[P].Hero, True);
          Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[M[P]].MindX, Players[M[P]].MindY, Players[M[P]].MindDir, 1, 1);
          Actions.CinematicStart(P);
          Actions.CinematicPanTo(P, Players[M[P]].MindX, Players[M[P]].MindY, 0);
          Actions.CinematicEnd(P);
        end;
        if (not Players[P].HeroReborn) then
        begin
          Actions.GroupKillAll(Players[M[P]].Hero, True);
          Players[M[P]].Hero := Actions.GiveGroup(M[P], Players[M[P]].HeroType, Players[P].MindX, Players[P].MindY, Players[P].MindDir, 1, 1);
          Actions.CinematicStart(M[P]);
          Actions.CinematicPanTo(M[P], Players[P].MindX, Players[P].MindY, 0);
          Actions.CinematicEnd(M[P]);
        end;
        Players[P].SpawnX := Players[P].TempSpawnX;
        Players[P].SpawnY := Players[P].TempSpawnY;
        Players[M[P]].SpawnX := Players[M[P]].TempSpawnX;
        Players[M[P]].SpawnY := Players[M[P]].TempSpawnY;
        Players[M[P]].LastX := Players[M[P]].TempLastX;
        Players[M[P]].LastY := Players[M[P]].TempLastY;
        Players[P].Direction := Players[P].TempDirection;
        Players[M[P]].Direction := Players[M[P]].TempDirection;
        Players[M[P]].ReCharge := Players[P].ReCharge;
        Players[P].ReCharge := Players[P].TempReCharge;
        Players[M[P]].RoadSkillDelay := Players[P].RoadSkillDelay;
        Players[M[P]].FieldSkillDelay := Players[P].FieldSkillDelay;
        Players[M[P]].WineSkillDelay := Players[P].WineSkillDelay;
        Players[P].RoadSkillDelay := 0;
        Players[P].FieldSkillDelay := 0;
        Players[P].WineSkillDelay := Round(SCOUT_WINE_DELAY * (1 - RECHARGE_FACTOR * Byte(Players[P].ReCharge)));
        Players[M[P]].LastUsedSkill := Players[P].LastUsedSkill;
        Players[M[P]].StolenSkill := Players[P].StolenSkill;
        Players[M[P]].StolenSkillTime := Players[P].StolenSkillTime;
        Players[M[P]].StolenSkillName := Players[P].StolenSkillName;
        Players[P].StolenSkill := Players[P].TempStolenSkill;
        Players[P].StolenSkillTime := Players[P].TempStolenSkillTime;
        Players[P].StolenSkillName := Players[P].TempStolenSkillName;
        Players[M[P]].ReChargeTime := Players[P].ReChargeTime;
        Players[P].ReChargeTime := Players[P].TempReChargeTime;
        Players[M[P]].DD := Players[P].DD;
        Players[P].DD := Players[P].TempDD;
        Players[M[P]].DDTime := Players[P].DDTime;
        Players[P].DDTime := Players[P].TempDDTime;
        Players[P].HeroMagicImmunity :=  Players[P].TempHeroMagicImmunity;
        Players[P].HeroMagicImmunityTime := Players[P].TempHeroMagicImmunityTime;
        Players[P].HeroTotalImmunity :=  Players[P].TempHeroTotalImmunity;
        Players[P].HeroTotalImmunityTime := Players[P].TempHeroTotalImmunityTime;
        Players[M[P]].HeroInFear := Players[P].HeroInFear;
        Players[M[P]].HeroInFearTime := Players[P].HeroInFearTime;
        Players[P].TempHeroReborn := Players[M[P]].HeroReborn;
        Players[P].TempRebornTime := Players[M[P]].RebornTime;
        Players[M[P]].HeroReborn := Players[P].HeroReborn;
        Players[M[P]].RebornTime := Players[P].RebornTime;
        Players[P].HeroReborn :=  Players[P].TempHeroReborn;
        Players[P].RebornTime := Players[P].TempRebornTime;
        Players[M[P]].HeroStunned := Players[P].HeroStunned;
        Players[M[P]].HeroStunnedTime := Players[P].HeroStunnedTime;
        Players[M[P]].SettingTrack := Players[P].SettingTrack;
        Players[M[P]].TrackStopTime := Players[P].TrackStopTime;
        Players[P].SettingTrack := False;
        Players[P].TrackStopTime := 0;
        Players[P].HeroExileTime := Players[M[P]].HeroExileTime;
        Players[P].HeroExileBackTime := Players[M[P]].HeroExileBackTime;
        Players[P].HeroExileX := Players[M[P]].HeroExileX;
        Players[P].HeroExileY := Players[M[P]].HeroExileY;
        Players[P].HeroExileGiver := Players[M[P]].HeroExileGiver;
        Players[P].HeroExileDir := Players[M[P]].HeroExileDir;
        Players[P].HeroExiled := Players[M[P]].HeroExiled;
        Players[M[P]].HeroExiled := False;
        Players[M[P]].HeroExileBackTime := 0;
        Players[M[P]].RocketCharges := Players[P].RocketCharges; 
        Players[M[P]].RocketChargeTime := Players[P].RocketChargeTime;
        Players[M[P]].SnakeCharges := Players[P].SnakeCharges; 
        Players[M[P]].SnakeChargeTime := Players[P].SnakeChargeTime;
        if Players[M[P]].PlayersTeam = 1 then
        begin
          Players[M[P]].PlayersTeam := 0;
          Players[M[P]].UsedPlayersTeam := True;
        end;
        if (Players[M[P]].PlayersTeam = 0)
        and (not Players[M[P]].UsedPlayersTeam) then
          Players[M[P]].PlayersTeam := 1;
        Players[M[P]].UsedPlayersTeam := False;
        Players[M[P]].LastUsedSkill := Players[P].LastUsedSkill;
        Players[P].LastUsedSkill := sMind;
        Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
        Actions.GroupHungerSet(Players[M[P]].Hero, States.UnitMaxHunger);
        Players[M[P]].HeroMagicImmunity := True;
        Players[M[P]].HeroMagicImmunityTime := States.GameTime + 20;
      end;
    end;
  except
    LogError('Exception in the script: cannot check Mind Back status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckMindImmunity(P: Integer);
begin
  try
    if States.GameTime = Players[P].MindMagicImmunityTime then
    begin
      Players[M[P]].HeroMagicImmunity := True;
      Players[M[P]].HeroMagicImmunityTime := States.GameTime + 10;
    end;
  except
    LogError('Exception in the script: cannot check Mind Immunity status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckMindSpurt(P: Integer);
begin
  try
    if InRange(P, 0, 7) then
      if InRange(M[P], 0, 7) then
        if (Players[P].SpurtEndTime >= Players[P].CaptureMindTime)
        and (Players[P].CaptureMind)
        and (Players[M[P]].MindStunned) then
        begin
          Players[P].HeroMagicImmunityTime := Players[P].SpurtEndTime + 1;
          Players[M[P]].HeroStunnedTime := Players[P].SpurtEndTime + 1;
          Players[M[P]].StunnedMindTime := Players[P].SpurtEndTime + 1; 
          Players[P].CaptureMindTime := Players[P].SpurtEndTime + 1;
          Players[P].MindAppearTimeBack := Players[P].SpurtEndTime + 1 + DELAY_OF_TURNING;
          Players[P].MindMagicImmunityTime := Players[P].SpurtEndTime - 9;
        end;
  except
    LogError('Exception in the script: cannot check Raging Spurt status for invalid Mind:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckScoutSilence(P: Integer);
begin
  try
    if (States.GameTime = Players[P].ScoutSilenceStartTime)
    and (InRange(Players[P].ScoutSilenceGiver, 0, 11)) then
    begin
      Players[P].PlayerStatusTime := States.GameTime + GAMEPLAY_STATUS_TIME;
      Players[P].PlayerStatus := Players[P].PlayerStatus + '|<$73> ' + '[$' + States.PlayerColorText(Players[P].ScoutSilenceGiver) + ']' + States.PlayerName(Players[P].ScoutSilenceGiver) + '[]<$71> ' + SkillName(sSilence);
      Players[P].HeroSilent := True;
      Players[P].HeroSilentTime := States.GameTime + SILENCE_SCOUT_TIME;
      if not Players[P].MindStunned then
        CancelSkills(P);
    end;
  except
    LogError('Exception in the script: cannot check Scout Silence status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckSpurtStart(P: Integer);
begin
  try
    if States.GameTime = Players[P].SpurtStartTime then
    begin
      StartSpurt(P);
      if not Players[P].HeroMagicImmunity then
      begin
        Players[P].HeroMagicImmunityTime := (States.GameTime + SPURT_TIME + 5) - 27;
        Players[P].HeroMagicImmunity := True;
      end;
    end;
  except
    LogError('Exception in the script: cannot check Spurt Start status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckKnightAppear(P: Integer);
begin
  try
    if (States.GameTime = Players[P].KnightAppearTime)  
    and (Players[P].Hero > 0) then   
    begin
      Actions.GroupKillAll(Players[P].Hero, True);
      Players[P].Hero := Actions.GiveGroup(P, Players[P].TempHeroType, Players[P].KnightX, Players[P].KnightY, Players[P].KnightDir, 1, 1);
      Players[P].HeroType := Players[P].TempHeroType;
      Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    end;
  except
    LogError('Exception in the script: cannot check Knight appear status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckAIKnightCombo(P: Integer);
begin
  try
    if States.GameTime = Players[P].AIKnightComboTime then
      Players[P].AIKnightCombo := False;
  except
    LogError('Exception in the script: cannot check AI Knight combo status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckKills(P: Integer);
begin
  try
    if States.GameTime = Players[P].KillsCountTime then
    begin
      Players[P].DoubleKill := False;
      Players[P].TripleKill := False;
      Players[P].Rampage := False;
      SetLength(Players[P].KillTimes, 0);
      Players[P].KillsCountTime := 0;
    end;
  except
    LogError('Exception in the script: cannot check kills status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckReChoice(P: Integer);
begin
  try
    if (States.GameTime = Players[P].ReChoiceTime)
    and (Players[P].ReChoice) then
      EndReChoice(P);
  except
    LogError('Exception in the script: cannot check ReChoice status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure BlockReChoice;
var
  I: Integer;
begin
  for I := 0 to 7 do
    Players[I].ReChoiceAllowed := False;
  Actions.ShowMsg(-1, '<$151>');
end;


procedure CheckLocation(P: Integer);
begin
  try
    if (States.PlayerEnabled(P))
    and (Players[P].Hero > 0) then
      if (States.UnitPositionY(States.GroupMember(Players[P].Hero, 0)) < CurrentMinY)
      and (States.GroupOwner(Players[P].Hero) = P)
      and (Players[P].HP > 0) then
      begin
        Actions.GroupKillAll(Players[P].Hero, True);
        Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].LastX, Players[P].LastY, Players[P].LastDir, 1, 1);
      end;
  except
    LogError('Exception in the script: cannot check location for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckFireworksCleanup(P: Integer);
var
  aX, aY: Integer;
begin
  try
    if States.GameTime = Players[P].FireworkTime then
      for aX := Players[P].FireworkX - FIREWORKS1_RADIUS - FIREWORKS2_RADIUS - 2 to Players[P].FireworkX + FIREWORKS1_RADIUS + FIREWORKS2_RADIUS + 2 do
      for aY := Players[P].FireworkY - FIREWORKS1_RADIUS - FIREWORKS2_RADIUS - 2 to Players[P].FireworkY + FIREWORKS1_RADIUS + FIREWORKS2_RADIUS + 2 do
        if (States.MapTileObject(aX, aY) = AXE_OBJECT2)
        or (States.MapTileObject(aX, aY) = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(aX, aY, 255);
  except
    LogError('Exception in the script: cannot check Fireworks cleanup for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckSuddenCleanup(P: Integer);
var
  aX, aY: Integer;
begin
  try
    if States.GameTime = Players[P].SuddenTime then
      for aX := Players[P].SuddenX - 1 to Players[P].SuddenX + 1 do
      for aY := Players[P].SuddenY - 1 to Players[P].SuddenY + 1 do
        if States.MapTileObject(aX, aY) = XBOW_OBJECT3 then
          Actions.MapTileObjectSet(aX, aY, 255);
  except
    LogError('Exception in the script: cannot check Sudden Death cleanup for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckRocketCleanup(P: Integer);
var
  aX, aY: Integer;
begin
  try
    if States.GameTime = Players[P].RocketTime then
      for aX := Players[P].RocketX - 1 to Players[P].RocketX + 1 do
      for aY := Players[P].RocketY - 1 to Players[P].RocketY + 1 do
        if States.MapTileObject(aX, aY) = BOWMAN_ROCKET2 then
          Actions.MapTileObjectSet(aX, aY, 255);
  except
    LogError('Exception in the script: cannot check Rocket cleanup for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckSkillsCleanup(P: Integer);
begin
  try
    CheckFireworksCleanup(P);
    CheckSuddenCleanup(P);
    CheckRocketCleanup(P);
  except
    LogError('Something went wrong when trying to check skills cleanup:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure ClearAISkills(P: Integer);
begin
  try
    if States.GameTime = Players[P].SkillTime then
      Players[P].CastingSkill := False;
  except
    LogError('Exception in the script: cannot clear AI skills for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure ClearBuffsDebuffsStatus(P: Integer);
begin
  try

    if (States.GameTime >= Players[P].HeroMagicImmunityTime)
    and (Players[P].HeroMagicImmunity) then
      Players[P].HeroMagicImmunity := False;

    if (States.GameTime >= Players[P].HeroTotalImmunityTime)
    and (Players[P].HeroTotalImmunity) then
      Players[P].HeroTotalImmunity := False;

    if (States.GameTime >= Players[P].DDTime)
    and (Players[P].DD) then
      Players[P].DD := False;

    if (States.GameTime >= Players[P].ReChargeTime)
    and (Players[P].ReCharge) then
      Players[P].ReCharge := False;

    if (States.GameTime >= Players[P].PreparingTime)
    and (Players[P].Preparing) then
      Players[P].Preparing := False;

    if (States.GameTime >= Players[P].GravityTime)
    and (Players[P].MovedByGravity) then
      Players[P].MovedByGravity := False;

    if (States.GameTime >= Players[P].HeroSilentTime)
    and (Players[P].HeroSilent) then
    begin
      Players[P].HeroSilent := False;
      Actions.GroupBlockOrders(Players[P].Hero, False);
    end;

    if (States.GameTime >= Players[P].HeroStunnedTime)
    and (Players[P].HeroStunned) then
    begin
      Players[P].HeroStunned := False;
      if Players[P].Hero > 0 then
      begin
        Actions.GroupBlockOrders(Players[P].Hero, False);
        Actions.GroupOrderHalt(Players[P].Hero);
      end;
    end;
    
    if Players[P].HeroStunned then
    begin
      Actions.GroupOrderHalt(Players[P].Hero);
      Actions.GroupBlockOrders(Players[P].Hero, True);
    end;

    if (Players[P].MindStunned)
    and (not Players[M2[P]].CaptureMind) then
      Players[P].MindStunned := False;

  except
    LogError('Exception in the script: cannot clear buffs/debuffs for invalid player:', [P], SHOW_ERROR_MSG);
  end;

end;


procedure ClearStatusString(P: Integer);
begin
  try
    if States.GameTime = Players[P].PlayerStatusTime then
      Players[P].PlayerStatus := '';
  except
    LogError('Exception in the script: cannot clear status for invalid player:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckStatus(P: Integer);
begin
  try
    if States.PlayerEnabled(P) then
    begin
      CheckHP(P);
      CheckReborn(P);
      CheckKills(P);
      CheckExile(P);
      CheckExileTile(P);
      CheckExileBack(P);
      CheckThreadsPrepare(P);
      CheckThreads(P);
      CheckZombiesThreads(P);
      CheckReplica(P);
      CheckRift(P);
      CheckTeleport(P);
      CheckVaga(P);
      CheckWerewolf(P);
      CheckVagaBack(P);
      CheckFieryTrack(P);
      CheckFear(P);
      CheckZombieStun(P);
      CheckMindSpurt(P);
      CheckMind(P);
      CheckMind2(P);
      CheckMindAppear(P);
      CheckMindCapture(P);
      CheckMindBack(P);
      CheckMindImmunity(P);
      CheckScoutSilence(P);
      CheckLure(P);
      CheckKnightAppear(P);
      CheckSpurtStart(P);
      CheckReChoice(P);
      CheckLocation(P);
      CheckSkillsCleanup(P);
      ClearAISkills(P);
      ClearBuffsDebuffsStatus(P);
      ClearStatusString(P);
      CancelSkillMindSilent(P);
      CheckAIKnightCombo(P);
    end;
  except
    LogError('Exception in the script: something went wrong when trying to check status:', [P], SHOW_ERROR_MSG);
  end;
end;


procedure CheckTileRoadObjects(P: Integer);
var
  K, aRelief: Integer;
begin
  for K := 0 to TilesRoadLength[P] - 1 do
  begin
    if (TilesRoadX[P][K] > 0)
    and (TilesRoadY[P][K] > 0) then
      if TileOnBattlefield_2(TilesRoadX[P][K], TilesRoadY[P][K])
      and (TilesRoadObjects[P][K] <> SKILL_CANCEL_OBJ) then
      begin

        Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := Players[P].LastRoadSkill;
        Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner := P;

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = BARB_OBJECT3)
        and (States.GameTime > Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].ShieldTime) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].ShieldTime)
        and (TilesRoadObjects[P][K] = KNIGHT_OBJECT4) then
        begin
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], KNIGHT_OBJECT4);
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := sRagingSpurt;
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].ShieldTime)
        and (TilesRoadObjects[P][K] = SCOUT_OBJECT6) then
        begin
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := sBoomerang;
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].ShieldTime)
        and (TilesRoadObjects[P][K] = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], CIRCLE_FILL_OBJ);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], WARRIOR_OBJECT5);

        if (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K] - 1))
        and (TilesRoadObjects[P][K] = WARRIOR_OBJECT7) then
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], WARRIOR_OBJECT7);

        if States.GameTime = ClearTilesRoadTimes[P][K] + CLEAR_ARRAY_FACTOR - 1 then
          Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Skill := sNone;

        if (InRange(States.GameTime, ClearTilesRoadTimes[P][K], CLEAR_ARRAY_FACTOR - 1 + ClearTilesRoadTimes[P][K]))
        and ((States.MapTileObject(TilesRoadX[P][K], TilesRoadY[P][K]) <> 255) and (TilesRoadObjects[P][K] <> KNIGHT_OBJECT))
        or ((TilesRoadObjects[P][K] = KNIGHT_OBJECT) and (States.MapTileObject(TilesRoadX[P][K], TilesRoadY[P][K]) = KNIGHT_OBJECT)) then
        begin
          Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], 255);

          if not CHANGE_RELIEF then
            Exit;

          if InRange(States.MapTileHeight(TilesRoadX[P][K], TilesRoadY[P][K]), 0, 45) then
            Actions.MapTileHeightSet(TilesRoadX[P][K], TilesRoadY[P][K], Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Relief);

        end;

        if (TilesRoadObjects[P][K] = BARB_OBJECT)
        and (States.MapTileObject(TilesRoadX[P][K], TilesRoadY[P][K]) = BARB_OBJECT)
        and (InRange(States.GameTime, SetTilesRoadTimes[P][K], ClearTilesRoadTimes[P][K]))
        and (States.GameTime mod 3 = 0)
        and (InRange(States.MapTileHeight(TilesRoadX[P][K], TilesRoadY[P][K]), 0, 45)) then
        begin
          if not CHANGE_RELIEF then
            Exit;
          aRelief := Tiles[TilesRoadX[P][K]][TilesRoadY[P][K]].Relief + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
          if aRelief < 0 then
            aRelief := -1 * aRelief;
          Actions.MapTileHeightSet(TilesRoadX[P][K], TilesRoadY[P][K], aRelief);
        end;

        if States.GameTime = SetTilesRoadTimes[P][K] then
          if CanPlaceObject(TilesRoadX[P][K], TilesRoadY[P][K]) then
            if not Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], TilesRoadObjects[P][K]) then
              if ObjectType(TilesRoadObjects[P][K]) = otKill then
                Actions.MapTileObjectSet(TilesRoadX[P][K], TilesRoadY[P][K], UNIVERSAL_KILL_OBJ);
      end;
    end;
end;


procedure CheckTileFieldObjects(P: Integer);
var
  K, aRelief, C: Integer;
begin
  for K := 0 to TilesFieldLength[P] - 1 do
  begin
    if (TilesFieldX[P][K] > 0)
    and (TilesFieldY[P][K] > 0) then
      if TileOnBattlefield_2(TilesFieldX[P][K], TilesFieldY[P][K])
      and (TilesFieldObjects[P][K] <> SKILL_CANCEL_OBJ) then
      begin

        Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Skill := Players[P].LastFieldSkill;
        Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner := P;

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = WARRIOR_OBJECT7) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], WARRIOR_OBJECT7);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].ShieldTime)
        and (TilesFieldObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesFieldTimes[P][K], 1 + ClearTilesFieldTimes[P][K]))
        and (States.GameTime > Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].ShieldTime)
        and (TilesFieldObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

        if (InRange(States.GameTime, ClearTilesFieldTimes[P][K], 1 + ClearTilesFieldTimes[P][K]))
        and (TilesFieldObjects[P][K] = WARRIOR_OBJECT7) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = BARB_OBJECT3)
        and (States.GameTime > Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].ShieldTime) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].ShieldTime)
        and (TilesFieldObjects[P][K] = KNIGHT_OBJECT4) then
        begin
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], KNIGHT_OBJECT4);
          Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Skill := sRagingSpurt;
          Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].ShieldTime)
        and (TilesFieldObjects[P][K] = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], CIRCLE_FILL_OBJ);

        if (InRange(States.GameTime, SetTilesFieldTimes[P][K], ClearTilesFieldTimes[P][K] - 1))
        and (TilesFieldObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], WARRIOR_OBJECT5);

        if States.GameTime = ClearTilesFieldTimes[P][K] + CLEAR_ARRAY_FACTOR - 1 then
          Tiles[TilesFieldX[P][K]][TilesFieldY[P][K]].Skill := sNone;

        if (InRange(States.GameTime, ClearTilesFieldTimes[P][K], 2 + ClearTilesFieldTimes[P][K]))
        and (States.MapTileObject(TilesFieldX[P][K], TilesFieldY[P][K]) <> 255) then
        begin
          Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], 255);

          if P = 8 then
            if TileOnBattlefield(TilesFieldX[8][K], TilesFieldY[8][K]) then
              Actions.MapTileHeightSet(TilesFieldX[8][K], TilesFieldY[8][K], Tiles[TilesFieldX[8][K]][TilesFieldY[8][K]].Relief);
        end;

        if States.GameTime = SetTilesFieldTimes[P][K] then
        begin
          if CanPlaceObject(TilesFieldX[P][K], TilesFieldY[P][K]) then
            if not Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], TilesFieldObjects[P][K]) then
              if ObjectType(TilesFieldObjects[P][K]) = otKill then
                Actions.MapTileObjectSet(TilesFieldX[P][K], TilesFieldY[P][K], UNIVERSAL_KILL_OBJ);
          if P = 8 then
            for C := 0 to 1 + States.KaMRandomI(3) do
            begin
              if not CHANGE_RELIEF then
                Exit;
              aRelief := States.MapTileHeight(TilesFieldX[8][K], TilesFieldY[8][K]) + States.KaMRandomI(RELIEF_CHANGE_FACTOR) - States.KaMRandomI(RELIEF_CHANGE_FACTOR);
              if aRelief < 0 then
                aRelief := -1 * aRelief;
              if TileOnBattlefield(TilesFieldX[8][K], TilesFieldY[8][K]) then
                Actions.MapTileHeightSet(TilesFieldX[8][K], TilesFieldY[8][K], aRelief);
            end;
        end;
      end;
    end;
end;


procedure CheckTileWineObjects(P: Integer);
var
  K: Integer;
begin
  for K := 0 to TilesWineLength[P] - 1 do
  begin
    if (TilesWineX[P][K] > 0)
    and (TilesWineY[P][K] > 0) then
      if TileOnBattlefield_2(TilesWineX[P][K], TilesWineY[P][K])
      and (TilesWineObjects[P][K] <> SKILL_CANCEL_OBJ) then
      begin

        Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Skill := Players[P].LastWineSkill;
        Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Owner := P;

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = WARRIOR_OBJECT7) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], WARRIOR_OBJECT7);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesWineX[P][K]][TilesWineY[P][K]].ShieldTime)
        and (TilesWineObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BOWMAN_OBJECT5);

        if (InRange(States.GameTime, ClearTilesWineTimes[P][K], 1 + ClearTilesWineTimes[P][K]))
        and (TilesWineObjects[P][K] = BOWMAN_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], 255);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = BARB_OBJECT3)
        and (States.GameTime > Tiles[TilesWineX[P][K]][TilesWineY[P][K]].ShieldTime) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], BARB_OBJECT3);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesWineX[P][K]][TilesWineY[P][K]].ShieldTime)
        and (TilesWineObjects[P][K] = KNIGHT_OBJECT4) then
        begin
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], KNIGHT_OBJECT4);
          Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Skill := sRagingSpurt;
          Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Owner := P;
        end;

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (States.GameTime > Tiles[TilesWineX[P][K]][TilesWineY[P][K]].ShieldTime)
        and (TilesWineObjects[P][K] = CIRCLE_FILL_OBJ) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], CIRCLE_FILL_OBJ);

        if (InRange(States.GameTime, SetTilesWineTimes[P][K], ClearTilesWineTimes[P][K] - 1))
        and (TilesWineObjects[P][K] = WARRIOR_OBJECT5) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], WARRIOR_OBJECT5);

        if (InRange(States.GameTime, ClearTilesWineTimes[P][K], CLEAR_ARRAY_FACTOR - 1 + ClearTilesWineTimes[P][K]))
        and (States.MapTileObject(TilesWineX[P][K], TilesWineY[P][K]) <> 255) then
          Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], 255);

        if States.GameTime = SetTilesWineTimes[P][K] then
          if CanPlaceObject(TilesWineX[P][K], TilesWineY[P][K]) then
            if not Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], TilesWineObjects[P][K]) then
              if ObjectType(TilesWineObjects[P][K]) = otKill then
                Actions.MapTileObjectSet(TilesWineX[P][K], TilesWineY[P][K], UNIVERSAL_KILL_OBJ);

        if States.GameTime = ClearTilesWineTimes[P][K] + CLEAR_ARRAY_FACTOR - 1 then
          Tiles[TilesWineX[P][K]][TilesWineY[P][K]].Skill := sNone;

      end;
    end;
end;


procedure ClearArrays;
var
  I, K: Integer;
begin

  for I := 0 to 11 do
  begin

    if States.GameTime = ClearRoadTilesArrayTime[I] then
    begin
      TilesRoadLength[I] := 0;
      SetLength(TilesRoadX[I], TilesRoadLength[I]);
      SetLength(TilesRoadY[I], TilesRoadLength[I]);
      SetLength(ClearTilesRoadTimes[I], TilesRoadLength[I]);
      SetLength(SetTilesRoadTimes[I], TilesRoadLength[I]);
      SetLength(TilesRoadObjects[I], TilesRoadLength[I]);
    end;

    if States.GameTime = ClearFieldTilesArrayTime[I] then
    begin
      TilesFieldLength[I] := 0;
      SetLength(TilesFieldX[I], TilesFieldLength[I]);
      SetLength(TilesFieldY[I], TilesFieldLength[I]);
      SetLength(ClearTilesFieldTimes[I], TilesFieldLength[I]);
      SetLength(SetTilesFieldTimes[I], TilesFieldLength[I]);
      SetLength(TilesFieldObjects[I], TilesFieldLength[I]);
    end;

    if States.GameTime = ClearWineTilesArrayTime[I] then
    begin
      TilesWineLength[I] := 0;
      SetLength(TilesWineX[I], TilesWineLength[I]);
      SetLength(TilesWineY[I], TilesWineLength[I]);
      SetLength(ClearTilesWineTimes[I], TilesWineLength[I]);
      SetLength(SetTilesWineTimes[I], TilesWineLength[I]);
      SetLength(TilesWineObjects[I], TilesWineLength[I]);
    end;

    if States.GameTime = TimeToClearGravityArray[I] then
    begin
      GravityCirclesLength[I] := 0;
      SetLength(GravityCircles[I], 0);
    end;

    for K := 0 to MAX_CIRCLES_AT_ONCE - 1 do
    begin

      if States.GameTime = TimeToClearRageArray[I][K] then
      begin
        RageCirclesLength[I][K] := 0;
        SetLength(RageCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearTotemArray[I][K] then
      begin
        TotemCirclesLength[I][K] := 0;
        SetLength(TotemCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearViseArray[I][K] then
      begin
        ViseCirclesLength[I][K] := 0;
        SetLength(ViseCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearExpArray[I][K] then
      begin
        ExpCirclesLength[I][K] := 0;
        SetLength(ExpCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks1Array[I][K] then
      begin
        FireworksCircles1Length[I][K] := 0;
        SetLength(FireworksCircles1[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks2Array[I][K] then
      begin
        FireworksCircles2Length[I][K] := 0;
        SetLength(FireworksCircles2[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks3Array[I][K] then
      begin
        FireworksCircles3Length[I][K] := 0;
        SetLength(FireworksCircles3[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks4Array[I][K] then
      begin
        FireworksCircles4Length[I][K] := 0;
        SetLength(FireworksCircles4[I][K], 0);
      end;

      if States.GameTime = TimeToClearFireworks5Array[I][K] then
      begin
        FireworksCircles5Length[I][K] := 0;
        SetLength(FireworksCircles5[I][K], 0);
      end;

      if States.GameTime = TimeToClearRogueArray[I][K] then
      begin
        RogueCirclesLength[I][K] := 0;
        SetLength(RogueCircles[I][K], 0);
      end;

      if States.GameTime = TimeToClearStolenRogueArray[I][K] then
      begin
        StolenRogueCirclesLength[I][K] := 0;
        SetLength(StolenRogueCircles[I][K], 0);
      end;

    end;

  end;

end;


procedure CheckLinks(P: Integer);
var
  G, K, Count: Integer;
  Groups: array of Integer;
begin
  if Players[P].CaptureMind then
  begin
    Groups := States.PlayerGetAllGroups(P);
    for K := 0 to length(Groups) - 1 do
    begin
      if Groups[K] > 0 then
      begin
        G := Groups[K];
        Count := States.GroupMemberCount(G);
        if Count > 1 then
        begin
          Actions.GroupKillAll(G, True);
          Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[M[P]].LastX, Players[M[P]].LastY, Players[P].Direction, 1, 1);
          Players[M[P]].Hero := Actions.GiveGroup(P, 21, Players[P].LastX, Players[P].LastY, Players[M[P]].Direction, 1, 1);
          Actions.ShowMsg(P, '<$999>'); //Easter egg
        end;
      end;
    end;
  end;
end;


procedure CheckEffects(P: Integer);
var
  aX, aY, aU, X, Y, Tile: Integer;
begin
  aU := Players[P].Hero;
  if aU <= 0 then
    Exit;
  if Players[P].HP <= 0 then
    Exit;
  aX := States.UnitPositionX(States.GroupMember(Players[P].Hero, 0));
  aY := States.UnitPositionY(States.GroupMember(Players[P].Hero, 0));

  if not TileOnBattlefield(aX, aY) then
    Exit;

  if States.GameTime mod EFFECT_CHECK_FACTOR < 3 then
    for X := aX - 2 to aX + 2 do
    for Y := aY - 2 to aY + 2 do
      if TileOnBattlefield(X, Y) then
      begin
        Tile := States.MapTileType(X, Y);
        if (Tile = MAGIC_IMMUNITY_ANIMATION)
        or (Tile = TOTAL_IMMUNITY_ANIMATION)
        or (Tile = DOUBLE_ANIMATION)
        or (Tile = RECHARGE_ANIMATION)
        or (Tile = MIND_ANIMATION)
        or (Tile = STUN_ANIMATION)
        or (Tile = FEAR_ANIMATION)
        or (Tile = SILENCE_ANIMATION) then
          Actions.MapTileSet(X, Y, Tiles[X][Y].TileType, Tiles[X][Y].TileDirection);
      end;

  if (States.GameTime mod EFFECT_CHECK_FACTOR >= 3)
  and (not InRange(States.MapTileType(aX, aY), INFERNAL_TILE - 3, INFERNAL_TILE)) then
  begin
    if Players[P].HeroMagicImmunity then
      Actions.MapTileSet(aX, aY, MAGIC_IMMUNITY_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroTotalImmunity then
      Actions.MapTileSet(aX, aY, TOTAL_IMMUNITY_ANIMATION, States.KaMRandomI(4));
    if Players[P].DD then
      Actions.MapTileSet(aX, aY, DOUBLE_ANIMATION, States.KaMRandomI(4));
    if Players[P].ReCharge then
      Actions.MapTileSet(aX, aY, RECHARGE_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroStunned then
      Actions.MapTileSet(aX, aY, STUN_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroInFear then
      Actions.MapTileSet(aX, aY, FEAR_ANIMATION, States.KaMRandomI(4));
    if Players[P].HeroSilent then
      Actions.MapTileSet(aX, aY, SILENCE_ANIMATION, States.KaMRandomI(4));
    if Players[P].MindStunned then
      Actions.MapTileSet(aX, aY, MIND_ANIMATION, States.KaMRandomI(4));
  end;

end;


procedure CheckAlliances(P: Integer);
begin

  if (InRange(P, 0, 3))
  and (not Players[P].CaptureMind)
  and (not Players[P].MindStunned) then
    if not States.PlayerAllianceCheck(Players[P].ZombiePlayer, P) then
      Actions.PlayerAllianceChange(Players[P].ZombiePlayer, P, True, True);

  if (InRange(P, 4, 7))
  and (not Players[P].CaptureMind)
  and (not Players[P].MindStunned) then
    if not States.PlayerAllianceCheck(Players[P].ZombiePlayer, P) then
      Actions.PlayerAllianceChange(Players[P].ZombiePlayer, P, True, True);

end;


procedure ClearDefence(P: Integer);
var
  aX, aY: Integer;
begin
  for aX := CurrentMinX to CurrentMaxX do
  for aY := CurrentMinY to CurrentMaxY do
    if States.MapTileObject(aX, aY) = ShieldObjects[P] then
      Actions.MapTileObjectSet(aX, aY, 255);
end;


procedure ClearPikeObj(P: Integer);
var
  aX, aY: Integer;
begin
  for aX := CurrentMinX to CurrentMaxX do
  for aY := CurrentMinY to CurrentMaxY do
    if States.MapTileObject(aX, aY) = PikeObjects[P] then
      Actions.MapTileObjectSet(aX, aY, 255);
end;


function ObjectIsTree(aX, aY: Integer): Boolean;
begin
  if TileOnBattlefield(aX, aY) then
    Result := ((States.MapTileObject(aX, aY) = 157)
              or (States.MapTileObject(aX, aY) = 158)
              or (States.MapTileObject(aX, aY) = 159)
              or (States.MapTileObject(aX, aY) = 160)
              or (States.MapTileObject(aX, aY) = 172));
end;


function TileHasTreesAround(aX, aY: Integer): Boolean;
begin
  if TileOnBattlefield(aX, aY) then
    Result := ((ObjectIsTree(aX + 1, aY))
              or (ObjectIsTree(aX + 1, aY + 1))
              or (ObjectIsTree(aX + 1, aY - 1))
              or (ObjectIsTree(aX - 1, aY - 1))
              or (ObjectIsTree(aX - 1, aY))
              or (ObjectIsTree(aX - 1, aY + 1))
              or (ObjectIsTree(aX, aY + 1))
              or (ObjectIsTree(aX, aY - 1)));
end;


procedure PlantTrees;
var
 aX, aY: Integer;
begin
  aX := States.KaMRandomI(46) + 13;
  aY := States.KaMRandomI(46) + 52;
  if (CanUseWineFieldSkill(aX, aY))
  and ((aX <> RUNE_X) and (aY <> RUNE_Y1))
  and ((aX <> RUNE_X) and (aY <> RUNE_Y2))
  and (not TileHasTreesAround(aX, aY))
  and (States.MapTileObject(aX, aY) <> BARB_OBJECT3)
  and (States.MapTileObject(aX, aY) <> BOWMAN_OBJECT5)
  and (States.MapTileObject(aX, aY) <> BOWMAN_ROCKET) then
    if (States.KaMRandom < PLANT_TREES_FACTOR)
    and (States.MapTileObject(aX, aY) = 255) then
    begin
      Actions.MapTileObjectSet(aX, aY, 157);
      Tiles[aX][aY].TreeTime := States.GameTime;
    end;

  for aX := CurrentMinX to CurrentMaxX do
  for aY := CurrentMinY to CurrentMaxY do
    if States.GameTime mod aX * TREES_GROW_FACTOR = 0 then
    begin

      if (States.MapTileObject(aX, aY) = 157)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE1) then
        Actions.MapTileObjectSet(aX, aY, 158);

      if (States.MapTileObject(aX, aY) = 158)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE2) then
        Actions.MapTileObjectSet(aX, aY, 159);

      if (States.MapTileObject(aX, aY) = 159)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE3) then
        Actions.MapTileObjectSet(aX, aY, 160);

      if (States.MapTileObject(aX, aY) = 160)
      and (States.GameTime >= Tiles[aX][aY].TreeTime + TREE_AGE4)
      and (States.KaMRandom < PLANT_TREES_FACTOR/2) then
        Actions.MapTileObjectSet(aX, aY, 172);

  end;

end;


procedure CheckRespawn(P: Integer);
begin
  if (States.PlayerEnabled(P))
  and (States.GameTime >= Players[P].RespawnCheckTime)
  and (Players[P].RespawnCheckTime > 0)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Players[P].HP > 0)
  and (Players[P].Hero = -1) then
  begin
    Players[P].Hero := Actions.GiveGroup(P, Players[P].HeroType, Players[P].SpawnX, Players[P].SpawnY, Players[P].Direction, 1, 1);
    Players[P].HeroTotalImmunity := True;
    Players[P].HeroTotalImmunityTime := States.GameTime + TOTAL_IMMUNITY_TIME;
    Actions.GroupHungerSet(Players[P].Hero, States.UnitMaxHunger);
    Actions.CinematicStart(P);
    Actions.CinematicPanTo(P, Players[P].SpawnX, Players[P].SpawnY, 0);
    Actions.CinematicEnd(P);
    Exit;
  end;
end;


procedure CheckArena;
var
  I, J, K, aX, aY, aX1, aY1: Integer;
begin
  if not NEW_ARENA then
    Exit;
  ArenaCycles := ArenaCycles + 1;
  if InRange(ArenaCycles, -1, ARENA_CYCLES - 1) then
  begin
    for aX := CurrentMinX to CurrentMaxX do
    begin
      Actions.MapTileSet(aX, CurrentMinY, 245, 0);
      Actions.MapTileSet(aX, CurrentMaxY, 245, 0);
      Actions.MapTileObjectSet(aX, CurrentMinY, 255);
      Actions.MapTileObjectSet(aX, CurrentMaxY, 255);
      Tiles[aX][CurrentMinY].TileType := 245;
      Tiles[aX][CurrentMaxY].TileType := 245;
    end;
    for aY := CurrentMinY to CurrentMaxY do
    begin
      Actions.MapTileSet(CurrentMinX, aY, 245, 0);
      Actions.MapTileSet(CurrentMaxX, aY, 245, 0);
      Actions.MapTileObjectSet(CurrentMinX, aY, 255);
      Actions.MapTileObjectSet(CurrentMaxX, aY, 255);
      Tiles[CurrentMinX][aY].TileType := 245;
      Tiles[CurrentMaxX][aY].TileType := 245;
    end;
    for J := 0 to 7 do
      for aX1 := Players[J].SpawnX - 1 to Players[J].SpawnX + 1 do
        for aY1 := Players[J].SpawnY - 1 to Players[J].SpawnY + 1 do
        begin
          Actions.MapTileSet(aX1, aY1, 36, States.KaMRandomI(4));
          Tiles[aX1][aY1].TileType := 36;
          Tiles[aX1][aY1].TileDirection := States.MapTileRotation(aX1, aY1);
        end;
    CurrentMinX := CurrentMinX + 1;
    CurrentMaxX := CurrentMaxX - 1;
    CurrentMinY := CurrentMinY + 1;
    CurrentMaxY := CurrentMaxY - 1;
    case MAX_Y - CurrentMaxY of
      1: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 6;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 6;
           Players[0].SpawnY := CurrentMinY + 6;
           Players[1].SpawnY := Players[0].SpawnY + 11;
           Players[2].SpawnY := Players[1].SpawnY + 11;
           Players[3].SpawnY := CurrentMaxY - 6;
           Players[4].SpawnY := CurrentMinY + 6;
           Players[5].SpawnY := Players[0].SpawnY + 11;
           Players[6].SpawnY := Players[1].SpawnY + 11;
           Players[7].SpawnY := CurrentMaxY - 6;
         end;
      2: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 6;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 6;
           Players[0].SpawnY := CurrentMinY + 6;
           Players[1].SpawnY := Players[0].SpawnY + 10;
           Players[2].SpawnY := Players[1].SpawnY + 11;
           Players[3].SpawnY := CurrentMaxY - 6;
           Players[4].SpawnY := CurrentMinY + 6;
           Players[5].SpawnY := Players[0].SpawnY + 10;
           Players[6].SpawnY := Players[1].SpawnY + 11;
           Players[7].SpawnY := CurrentMaxY - 6;
         end;
      3: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 6;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 6;
           Players[0].SpawnY := CurrentMinY + 6;
           Players[1].SpawnY := Players[0].SpawnY + 9;
           Players[2].SpawnY := Players[1].SpawnY + 11;
           Players[3].SpawnY := CurrentMaxY - 6;
           Players[4].SpawnY := CurrentMinY + 6;
           Players[5].SpawnY := Players[0].SpawnY + 9;
           Players[6].SpawnY := Players[1].SpawnY + 11;
           Players[7].SpawnY := CurrentMaxY - 6;
         end;
      4: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 6;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 6;
           Players[0].SpawnY := CurrentMinY + 6;
           Players[1].SpawnY := Players[0].SpawnY + 9;
           Players[2].SpawnY := Players[1].SpawnY + 9;
           Players[3].SpawnY := CurrentMaxY - 6;
           Players[4].SpawnY := CurrentMinY + 6;
           Players[5].SpawnY := Players[0].SpawnY + 9;
           Players[6].SpawnY := Players[1].SpawnY + 9;
           Players[7].SpawnY := CurrentMaxY - 6;
         end;
      5: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 5;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 5;
           Players[0].SpawnY := CurrentMinY + 5;
           Players[1].SpawnY := Players[0].SpawnY + 9;
           Players[2].SpawnY := Players[1].SpawnY + 9;
           Players[3].SpawnY := CurrentMaxY - 5;
           Players[4].SpawnY := CurrentMinY + 5;
           Players[5].SpawnY := Players[0].SpawnY + 9;
           Players[6].SpawnY := Players[1].SpawnY + 9;
           Players[7].SpawnY := CurrentMaxY - 5;
         end;
      6: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 5;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 5;
           Players[0].SpawnY := CurrentMinY + 5;
           Players[1].SpawnY := Players[0].SpawnY + 8;
           Players[2].SpawnY := Players[1].SpawnY + 9;
           Players[3].SpawnY := CurrentMaxY - 5;
           Players[4].SpawnY := CurrentMinY + 5;
           Players[5].SpawnY := Players[0].SpawnY + 8;
           Players[6].SpawnY := Players[1].SpawnY + 9;
           Players[7].SpawnY := CurrentMaxY - 5;
         end;
      7: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 5;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 5;
           Players[0].SpawnY := CurrentMinY + 5;
           Players[1].SpawnY := Players[0].SpawnY + 7;
           Players[2].SpawnY := Players[1].SpawnY + 9;
           Players[3].SpawnY := CurrentMaxY - 5;
           Players[4].SpawnY := CurrentMinY + 5;
           Players[5].SpawnY := Players[0].SpawnY + 7;
           Players[6].SpawnY := Players[1].SpawnY + 9;
           Players[7].SpawnY := CurrentMaxY - 5;
         end;
      8: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 5;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 5;
           Players[0].SpawnY := CurrentMinY + 5;
           Players[1].SpawnY := Players[0].SpawnY + 7;
           Players[2].SpawnY := Players[1].SpawnY + 7;
           Players[3].SpawnY := CurrentMaxY - 5;
           Players[4].SpawnY := CurrentMinY + 5;
           Players[5].SpawnY := Players[0].SpawnY + 7;
           Players[6].SpawnY := Players[1].SpawnY + 7;
           Players[7].SpawnY := CurrentMaxY - 5;
         end;
      9: begin
           for I := 0 to 3 do
             Players[I].SpawnX := CurrentMinX + 5;
           for K := 4 to 7 do
             Players[K].SpawnX := CurrentMaxX - 5;
           Players[0].SpawnY := CurrentMinY + 5;
           Players[1].SpawnY := Players[0].SpawnY + 6;
           Players[2].SpawnY := Players[1].SpawnY + 7;
           Players[3].SpawnY := CurrentMaxY - 5;
           Players[4].SpawnY := CurrentMinY + 5;
           Players[5].SpawnY := Players[0].SpawnY + 6;
           Players[6].SpawnY := Players[1].SpawnY + 7;
           Players[7].SpawnY := CurrentMaxY - 5;
         end;
      10: begin
            for I := 0 to 3 do
              Players[I].SpawnX := CurrentMinX + 4;
            for K := 4 to 7 do
              Players[K].SpawnX := CurrentMaxX - 4;
            Players[0].SpawnY := CurrentMinY + 4;
            Players[1].SpawnY := Players[0].SpawnY + 6;
            Players[2].SpawnY := Players[1].SpawnY + 7;
            Players[3].SpawnY := CurrentMaxY - 4;
            Players[4].SpawnY := CurrentMinY + 4;
            Players[5].SpawnY := Players[0].SpawnY + 6;
            Players[6].SpawnY := Players[1].SpawnY + 7;
            Players[7].SpawnY := CurrentMaxY - 4;
          end;
    end;
    for J := 0 to 7 do
      begin
        Actions.MapTileSet(Players[J].SpawnX, Players[J].SpawnY, 47, 0);
        Actions.MapTileSet(Players[J].SpawnX + 1, Players[J].SpawnY, 64, 3);
        Actions.MapTileSet(Players[J].SpawnX - 1, Players[J].SpawnY, 64, 1);
        Actions.MapTileSet(Players[J].SpawnX, Players[J].SpawnY - 1, 64, 2);
        Actions.MapTileSet(Players[J].SpawnX, Players[J].SpawnY + 1, 64, 0);
        Actions.MapTileSet(Players[J].SpawnX + 1, Players[J].SpawnY + 1, 247, 3);
        Actions.MapTileSet(Players[J].SpawnX - 1, Players[J].SpawnY + 1, 247, 0);
        Actions.MapTileSet(Players[J].SpawnX - 1, Players[J].SpawnY - 1, 247, 1);
        Actions.MapTileSet(Players[J].SpawnX + 1, Players[J].SpawnY - 1, 247, 2);
        for aX1 := Players[J].SpawnX - 1 to Players[J].SpawnX + 1 do
          for aY1 := Players[J].SpawnY - 1 to Players[J].SpawnY + 1 do
          begin
            Tiles[aX1][aY1].TileType := States.MapTileType(aX1, aY1);
            Tiles[aX1][aY1].TileDirection := States.MapTileRotation(aX1, aY1);
          end;
      end;
  end;
end;


procedure CheckBorder(aTile: Integer);
var
  aX, aY: Integer;
begin
  if not NEW_ARENA then
    Exit;
  if InRange(ArenaCycles, -1, ARENA_CYCLES - 1) then
  begin
    for aX := CurrentMinX to CurrentMaxX do
    begin
      Actions.MapTileSet(aX, CurrentMinY, aTile, 0);
      Actions.MapTileSet(aX, CurrentMaxY, aTile, 0);
      Tiles[aX][CurrentMinY].TileType := aTile;
      Tiles[aX][CurrentMaxY].TileType := aTile;
      Tiles[aX][CurrentMinY].Skill := sBorder;
      Tiles[aX][CurrentMaxY].Skill := sBorder;
      Tiles[aX][CurrentMinY].Owner := TEMP_PLAYER;
      Tiles[aX][CurrentMaxY].Owner := TEMP_PLAYER;
    end;
    for aY := CurrentMinY to CurrentMaxY do
    begin
      Actions.MapTileSet(CurrentMinX, aY, aTile, 0);
      Actions.MapTileSet(CurrentMaxX, aY, aTile, 0);
      Tiles[CurrentMinX][aY].TileType := aTile;
      Tiles[CurrentMaxX][aY].TileType := aTile;
      Tiles[CurrentMinX][aY].Skill := sBorder;
      Tiles[CurrentMaxX][aY].Skill := sBorder;
      Tiles[CurrentMinX][aY].Owner := TEMP_PLAYER;
      Tiles[CurrentMaxX][aY].Owner := TEMP_PLAYER;
    end;
  end;
end;


procedure CheckBorderSpaces;
var
  aX, aY: Integer;
begin
  if not NEW_ARENA then
    Exit;
  if InRange(ArenaCycles, 0, ARENA_CYCLES - 1) then
  begin
    for aX := CurrentMinX - 2 to CurrentMaxX + 2 do
    begin
      Actions.MapTileSet(aX, CurrentMinY - 1, 206, 0);
      Actions.MapTileSet(aX, CurrentMaxY + 1, 206, 2);
      Actions.MapTileSet(aX, CurrentMinY - 2, 7, States.KaMRandomI(4));
      Actions.MapTileSet(aX, CurrentMaxY + 2, 7, States.KaMRandomI(4));
      Actions.MapTileHeightSet(aX, CurrentMinY - 2, States.MapTileHeight(25, 47) + States.KaMRandomI(10));
      Actions.MapTileHeightSet(aX, CurrentMaxY + 2, States.MapTileHeight(25, 47) + States.KaMRandomI(10));
      Actions.MapTileHeightSet(aX, CurrentMinY - 1, States.MapTileHeight(25, 47) + States.KaMRandomI(5));
      Actions.MapTileHeightSet(aX, CurrentMaxY + 1, States.MapTileHeight(25, 47) + States.KaMRandomI(5));
      if TileOnBattlefield(aX, CurrentMinY) then
      begin
        Actions.MapTileHeightSet(aX, CurrentMinY, Max(5, States.MapTileHeight(aX, CurrentMinY) + States.KaMRandomI(5) - States.KaMRandomI(8)));
        Tiles[aX][CurrentMinY].Relief := States.MapTileHeight(aX, CurrentMinY);
      end;
      if TileOnBattlefield(aX, CurrentMaxY) then
      begin
        Actions.MapTileHeightSet(aX, CurrentMaxY, Max(5, States.MapTileHeight(aX, CurrentMaxY) + States.KaMRandomI(5) - States.KaMRandomI(8)));
        Tiles[aX][CurrentMaxY].Relief := States.MapTileHeight(aX, CurrentMaxY);
      end;
    end;
    for aY := CurrentMinY - 1 to CurrentMaxY + 1 do
    begin
      Actions.MapTileSet(CurrentMinX - 1, aY, 206, 3);
      Actions.MapTileSet(CurrentMaxX + 1, aY, 206, 1);
      Actions.MapTileSet(CurrentMinX - 2, aY, 7, States.KaMRandomI(4));
      Actions.MapTileSet(CurrentMaxX + 2, aY, 7, States.KaMRandomI(4));
      Actions.MapTileHeightSet(CurrentMinX - 2, aY, States.MapTileHeight(25, 47) + States.KaMRandomI(10));
      Actions.MapTileHeightSet(CurrentMaxX + 2, aY, States.MapTileHeight(25, 47) + States.KaMRandomI(10));
      Actions.MapTileHeightSet(CurrentMinX - 1, aY, States.MapTileHeight(25, 47) + States.KaMRandomI(5));
      Actions.MapTileHeightSet(CurrentMaxX + 1, aY, States.MapTileHeight(25, 47) + States.KaMRandomI(5));
      if TileOnBattlefield(CurrentMinX, aY) then
      begin
        Actions.MapTileHeightSet(CurrentMinX, aY, Max(5, States.MapTileHeight(CurrentMinX, aY) + States.KaMRandomI(5) - States.KaMRandomI(8)));
        Tiles[CurrentMinX][aY].Relief := States.MapTileHeight(CurrentMinX, aY);
      end;
      if TileOnBattlefield(CurrentMaxX, aY) then
      begin
        Actions.MapTileHeightSet(CurrentMaxX, aY, Max(5, States.MapTileHeight(CurrentMaxX, aY) + States.KaMRandomI(5) - States.KaMRandomI(8)));
        Tiles[CurrentMaxX][aY].Relief := States.MapTileHeight(CurrentMaxX, aY);
      end;
    end;
    Actions.MapTileSet(CurrentMinX - 1, CurrentMinY - 1, 202, 1);
    Actions.MapTileSet(CurrentMinX - 1, CurrentMaxY + 1, 202, 0);
    Actions.MapTileSet(CurrentMaxX + 1, CurrentMinY - 1, 202, 2);
    Actions.MapTileSet(CurrentMaxX + 1, CurrentMaxY + 1, 202, 3);
  end;
end;


procedure OnTick;
var
  N: array[0..19] of Integer;
  I, K, S1, S2, S3, S4, S5, S6, S7, S8: Integer;  
begin

  if (GameOver)
  and (VictoryTime > 0)
  and (States.GameTime > VictoryTime) then
    Exit;

  if InRange(States.GameTime, GAME_START_TIME + 3, GAME_START_TIME + 10) then
    for K := 0 to 7 do
      if States.PlayerEnabled(K) then
      begin
        Actions.FogCoverAll(K);
        Actions.FogRevealRect(K, 1, 39, 70, 109);
      end;

  if States.GameTime = 1 then
    SetScreen;

  for I := 0 to 7 do
    if States.Gametime > CHOOSE_HERO_TIMER then
    begin
      if States.GameTime = Players[I].DefenceTime then
        ClearDefence(I);

      if States.GameTime = Players[I].ClearPikeObjTime then
        ClearPikeObj(I);

      if not Players[I].HeroReborn then
      begin
        if States.GameTime >= Players[I].SkillCastRespawnTime then
          if Players[I].Hero > 0 then
            if InRange(States.GroupOwner(Players[I].Hero), AI_TEMP_PLAYER, TEMP_PLAYER) then
              RespawnUnit(I);

        CheckRespawn(I);

      end;

      AIWalkAfterSkill(I);

      AIWalkIdle(I);

      AIEscapePrison(I);

      CheckAlliancesAfterShield(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 22) then
            AIKnight(I);
      
      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 16) then
            AISword(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 23) then
            AIBarb(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 18) then
            AICrossbow(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if (AICanUseSkills(I, 20)) then
            AIPikeman(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 19) then
            AILance(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if (AICanUseSkills(I, 26)) then
            AIWarrior(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 17) then
            AIBowman(I);

      if Players[I].Hero > 0 then
        if States.GroupMember(Players[I].Hero, 0) > 0 then
          if AICanUseSkills(I, 15) then
            AIAxe(I);

    end;

  CheckRuneTime;

  CheckRuneCleanup;

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      CheckEffects(I);
      CheckLinks(I);
    end;

  if States.GameTime = RECHOICE_MAX_TIME then
    BlockReChoice;

  ZombieTakeRune;

  CheckArenaTimer;

  if (ArenaTime = 1)
  and (States.GameTime > GAME_START_TIME) then
    CheckArena;

  if (ArenaTime = BORDER_TIME1)
  and (States.GameTime > GAME_START_TIME) then
    CheckBorder(INFERNAL_TILE - 2);

  if (ArenaTime = BORDER_TIME2)
  and (States.GameTime > GAME_START_TIME) then
    CheckBorder(INFERNAL_TILE - 1);

  if (InRange(ArenaTime, BORDER_TIME3, 2))
  and (States.GameTime > GAME_START_TIME) then
  begin
    CheckBorder(INFERNAL_TILE);
    ArenaTime2 := States.GameTime + BORDER_SPACES_TIME;
  end;

  if States.GameTime = ArenaTime2 then
    CheckBorderSpaces;

  if States.GameTime mod ZOMBIE_STORM_FACTOR = 0 then
  begin
    ZombieStormLeft;
    ZombieStormRight;
  end;

  if States.GameTime mod RELIEF_REGEN_TIME = 0 then
    RegenRelief;

  if States.GameTime mod TILES_RECHECK_TIME = 0 then
    CheckTileCleanup(False);

  for I := 0 to 7 do
    if States.PlayerEnabled(I) then
    begin
      CheckDelays(I);
      CheckStolenSkillTime(I);
      CheckAlliances(I);
      if States.GameTime = Players[I].TowerTime then
        PlaceTower(I);
    end;

  for N[13] := 0 to 11 do
    if (States.PlayerEnabled(N[13])) then
      if TilesRoadLength[N[13]] > 0 then
        CheckTileRoadObjects(N[13]);

  for N[14] := 0 to 11 do
    if TilesFieldLength[N[14]] > 0 then
      CheckTileFieldObjects(N[14]);

  for N[15] := 0 to 11 do
    if TilesWineLength[N[15]] > 0 then
      CheckTileWineObjects(N[15]);

  for I := 0 to 7 do
    if Players[I].Hero > 0 then
      CheckTiles(I);

  for I := 8 to 11 do
    CheckTilesForAI(I);

  for N[0] := 0 to 7 do
    CheckRageCircles(N[0]);

  for N[1] := 0 to 7 do
    CheckExpCircles(N[1]);

  for N[3] := 0 to 7 do
    CheckViseCircles(N[3]);

  for N[4] := 0 to 7 do
    CheckTotemCircles(N[4]);

  for N[5] := 0 to 7 do
    CheckGravityCircles(N[5]);

  for N[6] := 0 to 7 do
    CheckFireworks1Circles(N[6]);

  for N[7] := 0 to 7 do
    CheckFireworks2Circles(N[7]);

  for N[8] := 0 to 7 do
    CheckFireworks3Circles(N[8]);

  for N[9] := 0 to 7 do
    CheckFireworks4Circles(N[9]);

  for N[10] := 0 to 7 do
    CheckFireworks5Circles(N[10]);

  for N[12] := 0 to 7 do
    CheckKnightCircles(N[12]);

  for N[16] := 0 to 7 do
    CheckRogueCircles(N[16]);

  for N[11] := 0 to 7 do
    CheckStolenRogueCircles(N[11]);

  if States.GameTime = CHOOSE_HERO_TIMER then
  begin
    RandomChoice;
    for I := 0 to 3 do
      if (States.PlayerEnabled(I))
      and (Players[I].HeroChosen) then
        Players[I].TempHero := Actions.GiveGroup(I, Players[I].HeroType, 16, 15, 4, 1, 1);
    for I := 4 to 7 do
      if (States.PlayerEnabled(I))
      and (Players[I].HeroChosen) then
        Players[I].TempHero := Actions.GiveGroup(I, Players[I].HeroType, 19, 15, 4, 1, 1);
    for K := 0 to 7 do
      if Players[K].TempHero > 0 then
      begin
        Actions.GroupHungerSet(Players[K].TempHero, States.UnitMaxHunger);
        Actions.GroupOrderWalk(Players[K].TempHero, 30, 18, 6);
        Actions.GroupBlockOrders(Players[K].TempHero, True);
      end;
  end;

  if States.GameTime > GAME_START_TIME then
  begin
    for I := 0 to 7 do
      if Players[I].TempHero > 0 then
        Actions.GroupKillAll(Players[I].TempHero, True);
    TeamInfo[0] := '';
    TeamInfo[1] := '';
    Scores[0] := '';
    Scores[1] := '';

    for I := 0 to 3 do
      if (States.PlayerEnabled(I))
      and (Players[I].HeroChosen) then
        TeamInfo[0] := TeamInfo[0] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]' + ReChoiceColor(I) + ' {R} []' + IfThenStr(DEBUG_MODE, ' ([$BE662A]CT' + IntToStr(Players[I].PlayersTeam) + '[], [$7037AF]TT' + IntToStr(Players[I].TempPlayersTeam) + '[])', '') + ':' + PlayerInfo(I);

    for I := 4 to 7 do
      if (States.PlayerEnabled(I))
      and (Players[I].HeroChosen) then
        TeamInfo[1] := TeamInfo[1] + '|[$' + States.PlayerColorText(I) + ']' + States.PlayerName(I) + '[]' + ReChoiceColor(I) + ' {R} []' + IfThenStr(DEBUG_MODE, ' ([$BE662A]CT' + IntToStr(Players[I].PlayersTeam) + '[], [$7037AF]TT' + IntToStr(Players[I].TempPlayersTeam) + '[])', '') + ':' + PlayerInfo(I);

    for I := 0 to Length(SortedPlayersLeft) - 1 do
      Scores[0] := Scores[0] + '|[$' + States.PlayerColorText(SortedPlayersLeft[I]) + ']' + States.PlayerName(SortedPlayersLeft[I]) + '[]: ' + KillsColor(SortedPlayersLeft[I]) + IntToStr(Players[SortedPlayersLeft[I]].Kills) + '[]';

    for I := 0 to Length(SortedPlayersRight) - 1 do
      Scores[1] := Scores[1] + '|[$' + States.PlayerColorText(SortedPlayersRight[I]) + ']' + States.PlayerName(SortedPlayersRight[I]) + '[]: ' + KillsColor(SortedPlayersRight[I]) + IntToStr(Players[SortedPlayersRight[I]].Kills) + '[]';

  end;

  for I := 0 to 3 do
    if (States.PlayerEnabled(I))
    and (Players[I].HeroChosen)
    and (States.GameTime > CHOOSE_HERO_TIMER)
    and (not Players[I].ReChoice) then
    begin
      Actions.OverlayTextSet(I, '<$33> [$ADAF67]' + States.UnitTypeName(Players[I].HeroType) + '[]!'
      + '||<$35>: ' + RoadSkillName(I, Players[I].HeroType) + IfThenStr((Players[I].HeroType <> 17) and (Players[I].HeroType <> 26), '. <$34>: ' + IntToStr(Players[I].RoadSkillDelay/10), '.')
      + '|<$36>: ' + FieldSkillName(I, Players[I].HeroType) + '.' + SacrificialTeleportColor(I) + ' <$34>: ' + IntToStr(Players[I].FieldSkillDelay/10) + '[]'
      + '|<$37>: ' + WineSkillName(I, Players[I].HeroType) + '.' + StolenSacrificialTeleportColor(I) + IfThenStr(Players[I].StolenSkillName <> '<$10>', ' <$34>: ' + IntToStr(Players[I].WineSkillDelay/10) + '[]', '')
      + '|<$39>: ' + HPColor(I) + HPString(I) + '[]|' + '|<$45>: ' + IntToStr(RuneTime/10) + IfThenStr(ArenaTime > 0, '||<$145>: ' + IntToStr(ArenaTime/10) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Array: ' + IntToStr(Length(zombies)) + '|Units: ' + IntToStr(AIUnitsCount) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Lowest HP has player: ' + IntToStr(HasLowestHPLeft) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Strongest hero has player: ' + IntToStr(StrongestHeroLeft) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Needs double damage: player ' + IntToStr(NeedsDDLeft) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Needs recharge: player ' + IntToStr(NeedsReChargeLeft) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Closest to rune player: ' + IntToStr(ClosestToRuneLeft) + '|', '')
      + StatusText(I) + '|||<$41>:|' + TeamInfo[0] + '|||<$79>:|' + Scores[0]);
    end;

  for I := 4 to 7 do
    if (States.PlayerEnabled(I))
    and (Players[I].HeroChosen)
    and (States.GameTime > CHOOSE_HERO_TIMER)
    and (not Players[I].ReChoice) then
    begin
      Actions.OverlayTextSet(I, '<$33> [$ADAF67]' + States.UnitTypeName(Players[I].HeroType) + '[]!'
      + '||<$35>: ' + RoadSkillName(I, Players[I].HeroType) + IfThenStr((Players[I].HeroType <> 17) and (Players[I].HeroType <> 26), '. <$34>: ' + IntToStr(Players[I].RoadSkillDelay/10), '.')
      + '|<$36>: ' + FieldSkillName(I, Players[I].HeroType) + '.' + SacrificialTeleportColor(I) + ' <$34>: ' + IntToStr(Players[I].FieldSkillDelay/10) + '[]'
      + '|<$37>: ' + WineSkillName(I, Players[I].HeroType) + '.' + StolenSacrificialTeleportColor(I)  + IfThenStr(Players[I].StolenSkillName <> '<$10>', ' <$34>: ' + IntToStr(Players[I].WineSkillDelay/10) + '[]', '')
      + '|<$39>: ' + HPColor(I) + HPString(I) + '[]|' + '|<$45>: ' + IntToStr(RuneTime/10) + IfThenStr(ArenaTime > 0, '||<$145>: ' + IntToStr(ArenaTime/10) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Array: ' + IntToStr(Length(zombies)) + '|Units: ' + IntToStr(AIUnitsCount) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Lowest HP has player: ' + IntToStr(HasLowestHPRight) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Strongest hero has player: ' + IntToStr(StrongestHeroRight) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Needs double damage: player ' + IntToStr(NeedsDDRight) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Needs recharge: player ' + IntToStr(NeedsReChargeRight) + '|', '')
      + IfThenStr(DEBUG_MODE, '|Closest to rune player: ' + IntToStr(ClosestToRuneRight) + '|', '')
      + StatusText(I) + '|||<$41>:|' + TeamInfo[1] + '|||<$79>:|' + Scores[1]);
    end;

  for I := 0 to 7 do
    if Players[I].ReChoice then
      Actions.OverlayTextSet(I, '<$64> ' + IntToStr((Players[I].ReChoiceTime - States.GameTime)/10));

  if States.GameTime mod 12000 = 0 then
    AutoFeed;

  for K := 0 to 7 do
    CheckStatus(K);

  if States.GameTime < CHOOSE_HERO_TIMER then
  begin
    Actions.OverlayTextSet(-1, '<$38>: ' + IntToStr((CHOOSE_HERO_TIMER - States.GameTime) / 10) + ' (<$40>)|');
    for I := 0 to 3 do
      if States.PlayerEnabled(I) then
        Actions.OverlayTextAppend(I, TeamChoice[0]);

    for I := 4 to 7 do
      if States.PlayerEnabled(I) then
        Actions.OverlayTextAppend(I, TeamChoice[1]);
  end;

  if States.GameTime = GAME_START_TIME then
  begin
    SetHeroes;
    UnlockDebug;
  end;

  if States.GameTime > GAME_START_TIME then
    CheckVictoryDefeat;

  ClearArrays;

  if States.GameTime mod PLANT_TREES_TIME = 0 then
    PlantTrees;

  if (States.GameTime mod AVOID_FACTOR = 0)
  and (States.GameTime > CHOOSE_HERO_TIMER) then
    for I := 0 to 7 do
      AvoidDanger(I);

  if (States.GameTime mod AVOID_FACTOR = 0)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Length(States.PlayerGetAllHouses(Players[4].ZombiePlayer)) > 0) then
    for I := 0 to 3 do
      AvoidTowers(I);

  if (States.GameTime mod AVOID_FACTOR = 0)
  and (States.GameTime > CHOOSE_HERO_TIMER)
  and (Length(States.PlayerGetAllHouses(Players[0].ZombiePlayer)) > 0) then
    for I := 4 to 7 do
      AvoidTowers(I);

  if States.GameTime mod AI_IGNORE_FACTOR = 0 then
    for I := 0 to 7 do
      AIIgnore(I);

  if States.GameTime mod TOWERS_CHECK_FACTOR = 0 then
    CheckTowers;

  if States.GameTime mod TOWERS_TILES_FACTOR = 0 then
    CheckTowersTiles;

  if not DEBUG_MODE then
    for I := 0 to 7 do
      if States.PlayerEnabled(I) then
        if (States.PlayerIsAI(I))
        and (States.GameTime = Players[I].AIChoiceTime) then
          AIHeroChoice(I);

  for S1 := 0 to (Players[0].CurrentSpurtLength - 1) do
    CheckSpurt(0, S1);

  for S2 := 0 to (Players[1].CurrentSpurtLength - 1) do
    CheckSpurt(1, S2);

  for S3 := 0 to (Players[2].CurrentSpurtLength - 1) do
    CheckSpurt(2, S3);

  for S4 := 0 to (Players[3].CurrentSpurtLength - 1) do
    CheckSpurt(3, S4);

  for S5 := 0 to (Players[4].CurrentSpurtLength - 1) do
    CheckSpurt(4, S5);

  for S6 := 0 to (Players[5].CurrentSpurtLength - 1) do
    CheckSpurt(5, S6);

  for S7 := 0 to (Players[6].CurrentSpurtLength - 1) do
    CheckSpurt(6, S7);

  for S8 := 0 to (Players[7].CurrentSpurtLength - 1) do
    CheckSpurt(7, S8);


end;